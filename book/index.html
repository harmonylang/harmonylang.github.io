
<html>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="styles/harmony.css">
  <link rel="stylesheet" type="text/css" href="styles/light.css">
  <link rel="stylesheet" type="text/css" href="styles/prism.css">
  <link rel="stylesheet" type="text/css" href="mathtmp.css">
  <script src="js/harmony.js"></script>
  <script src="js/prism.js"></script>
  <script src="js/prism-harmony.js"></script>
  <body class="line-numbers">
    <div id="nav">
      <nav role="navigation">
        <div id="menuToggle">
          <input type="checkbox" />
          <span></span>
          <span></span>
          <span></span>
          <ul id="menu" class="nobullet">
<li><a href="#sec-1">1: On Concurrent Programming</a></li>
<li><a href="#sec-2">2: Hello World!</a></li>
<li><a href="#sec-16">3: The Problem of Concurrent Programming</a></li>
<li><a href="#sec-28">4: The Harmony Virtual Machine</a></li>
<li><a href="#sec-36">5: Critical Sections</a></li>
<li><a href="#sec-44">6: Peterson's Algorithm</a></li>
<li><a href="#sec-53">7: Harmony Methods and Pointers</a></li>
<li><a href="#sec-58">8: Specification</a></li>
<li><a href="#sec-62">9: Spinlock</a></li>
<li><a href="#sec-67">10: Lock Implementations</a></li>
<li><a href="#sec-78">11: Concurrent Data Structures</a></li>
<li><a href="#sec-88">12: Fine-Grained Locking</a></li>
<li><a href="#sec-95">13: Testing: Checking Behaviors</a></li>
<li><a href="#sec-104">14: Debugging</a></li>
<li><a href="#sec-109">15: Conditional Waiting</a></li>
<li><a href="#sec-118">16: Split Binary Semaphores</a></li>
<li><a href="#sec-131">17: Starvation</a></li>
<li><a href="#sec-134">18: Monitors</a></li>
<li><a href="#sec-146">19: Deadlock</a></li>
<li><a href="#sec-155">20: Actors and Message Passing</a></li>
<li><a href="#sec-159">21: Barrier Synchronization</a></li>
<li><a href="#sec-166">22: Example: A Concurrent File Service</a></li>
<li><a href="#sec-179">23: Interrupts</a></li>
<li><a href="#sec-187">24: Non-Blocking Synchronization</a></li>
<li><a href="#sec-190">25: Alternating Bit Protocol</a></li>
<li><a href="#sec-196">26: Leader Election</a></li>
<li><a href="#sec-200">27: Transactions and Two Phase Commit</a></li>
<li><a href="#sec-207">28: Chain Replication</a></li>
<li><a href="#sec-212">29: Working with Actions</a></li>
<li><a href="#sec-215">30: Replicated Atomic Read/Write Register</a></li>
<li><a href="#sec-219">31: Distributed Consensus</a></li>
<li><a href="#sec-226">32: Paxos</a></li>
<li><a href="#sec-230">33: Needham-Schroeder Authentication Protocol</a></li>
<li>&nbsp;</li>
<li><a href='#sec-234'>Bibliography</a></li>
<li>&nbsp;</li>
<li><a href="#sec-235">A: Harmony Language Details</a></li>
<li><a href="#sec-286">B: Modules</a></li>
<li><a href="#sec-295">C: The Harmony Virtual Machine</a></li>
<li><a href="#sec-300">D: How Harmony Works</a></li>
<li><a href="#sec-304">E: Simplified Grammar</a></li>
<li><a href="#sec-305">F: Directly checking linearizability</a></li>
<li><a href="#sec-308">G: Manual Pages</a></li>
<li>&nbsp;</li>
<li><a href="#sec-315">Acknowledgments</a></li>
<li>&nbsp;</li>
<li><a href='#sec-316'>Index</a></li>
<li><a href='#sec-317'>Glossary</a></li>
</ul>

        </div>
      </nav>
    </div>
    <div id="content">











































<p>
<center><img src="titlepage.png" width="70%"></img>
</center>

Permission is granted to copy, distribute and/or modify this
document under the terms of the
Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
(CC BY-NC-SA 4.0) at
<a href='http://creativecommons.org/licenses/by-nc-sa/4.0'>http://creativecommons.org/licenses/by-nc-sa/4.0</a>.<p><h1>Table of Contents</h1>
<ul class="nobullet">
<li><a href="#sec-1">Chapter 1: On Concurrent Programming</a></li>
<li><a href="#sec-2">Chapter 2: Hello World!</a></li>
<li><a href="#sec-16">Chapter 3: The Problem of Concurrent Programming</a></li>
<li><a href="#sec-28">Chapter 4: The Harmony Virtual Machine</a></li>
<li><a href="#sec-36">Chapter 5: Critical Sections</a></li>
<li><a href="#sec-44">Chapter 6: Peterson's Algorithm</a></li>
<li><a href="#sec-53">Chapter 7: Harmony Methods and Pointers</a></li>
<li><a href="#sec-58">Chapter 8: Specification</a></li>
<li><a href="#sec-62">Chapter 9: Spinlock</a></li>
<li><a href="#sec-67">Chapter 10: Lock Implementations</a></li>
<li><a href="#sec-78">Chapter 11: Concurrent Data Structures</a></li>
<li><a href="#sec-88">Chapter 12: Fine-Grained Locking</a></li>
<li><a href="#sec-95">Chapter 13: Testing: Checking Behaviors</a></li>
<li><a href="#sec-104">Chapter 14: Debugging</a></li>
<li><a href="#sec-109">Chapter 15: Conditional Waiting</a></li>
<ul class="nobullet">
<li><a href="#sec-112">Section 15.1: Reader/Writer Locks</a></li>
<li><a href="#sec-117">Section 15.2: Bounded Buffer</a></li>
</ul>
<li><a href="#sec-118">Chapter 16: Split Binary Semaphores</a></li>
<li><a href="#sec-131">Chapter 17: Starvation</a></li>
<li><a href="#sec-134">Chapter 18: Monitors</a></li>
<li><a href="#sec-146">Chapter 19: Deadlock</a></li>
<li><a href="#sec-155">Chapter 20: Actors and Message Passing</a></li>
<li><a href="#sec-159">Chapter 21: Barrier Synchronization</a></li>
<li><a href="#sec-166">Chapter 22: Example: A Concurrent File Service</a></li>
<li><a href="#sec-179">Chapter 23: Interrupts</a></li>
<li><a href="#sec-187">Chapter 24: Non-Blocking Synchronization</a></li>
<li><a href="#sec-190">Chapter 25: Alternating Bit Protocol</a></li>
<li><a href="#sec-196">Chapter 26: Leader Election</a></li>
<li><a href="#sec-200">Chapter 27: Transactions and Two Phase Commit</a></li>
<li><a href="#sec-207">Chapter 28: Chain Replication</a></li>
<li><a href="#sec-212">Chapter 29: Working with Actions</a></li>
<li><a href="#sec-215">Chapter 30: Replicated Atomic Read/Write Register</a></li>
<li><a href="#sec-219">Chapter 31: Distributed Consensus</a></li>
<li><a href="#sec-226">Chapter 32: Paxos</a></li>
<li><a href="#sec-230">Chapter 33: Needham-Schroeder Authentication Protocol</a></li>
<li>&nbsp</li>
<li><a href="#sec-234">Bibliography</a></li>
<li>&nbsp</li>
<li><a href="#sec-235">Appendix A: Harmony Language Details</a></li>
<ul class="nobullet">
<li><a href="#sec-236">Section A.1: Value Types and Operators</a></li>
<li><a href="#sec-246">Section A.2: Statements</a></li>
<li><a href="#sec-274">Section A.3: Harmony is not object-oriented</a></li>
<li><a href="#sec-275">Section A.4: Constants, Global and Local Variables</a></li>
<li><a href="#sec-276">Section A.5: Operator Precedence</a></li>
<li><a href="#sec-277">Section A.6: Tuples, Lists, and Pattern Matching</a></li>
<li><a href="#sec-278">Section A.7: Dynamic Allocation</a></li>
<li><a href="#sec-284">Section A.8: Comments</a></li>
<li><a href="#sec-285">Section A.9: Type Checking</a></li>
</ul>
<li><a href="#sec-286">Appendix B: Modules</a></li>
<ul class="nobullet">
<li><a href="#sec-287">Section B.1: The <var>action</var> module</a></li>
<li><a href="#sec-288">Section B.2: The <var>alloc</var> module</a></li>
<li><a href="#sec-289">Section B.3: The <var>bag</var> module</a></li>
<li><a href="#sec-290">Section B.4: The <var>fork</var> module</a></li>
<li><a href="#sec-291">Section B.5: The <var>hoare</var> module</a></li>
<li><a href="#sec-292">Section B.6: The <var>list</var> module</a></li>
<li><a href="#sec-293">Section B.7: The <var>set</var> module</a></li>
<li><a href="#sec-294">Section B.8: The <var>synch</var> module</a></li>
</ul>
<li><a href="#sec-295">Appendix C: The Harmony Virtual Machine</a></li>
<ul class="nobullet">
<li><a href="#sec-296">Section C.1: Machine Instructions</a></li>
<li><a href="#sec-297">Section C.2: Addresses and Method Calls</a></li>
<li><a href="#sec-298">Section C.3: Contexts and Threads</a></li>
<li><a href="#sec-299">Section C.4: Formal Specification</a></li>
</ul>
<li><a href="#sec-300">Appendix D: How Harmony Works</a></li>
<ul class="nobullet">
<li><a href="#sec-301">Section D.1: Compiler</a></li>
<li><a href="#sec-302">Section D.2: Model Checker</a></li>
<li><a href="#sec-303">Section D.3: Model Checker Output Analysis</a></li>
</ul>
<li><a href="#sec-304">Appendix E: Simplified Grammar</a></li>
<li><a href="#sec-305">Appendix F: Directly checking linearizability</a></li>
<li><a href="#sec-308">Appendix G: Manual Pages</a></li>
<li>&nbsp</li>
<li><a href="#sec-315">Acknowledgments</a></li>
<li>&nbsp</li>
<li><a href="#sec-316">Index</a></li>
<li><a href="#sec-317">Glossary</a></li>
</ul>
</ul>

<h1>List of Figures</h1>
<table border="0">
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-3'>Figure 2.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/hello1.hny'>code/hello1.hny</a>] Hello World!</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-4'>Figure 2.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/hello3.hny'>code/hello3.hny</a>] Harmony program with two possible outputs</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-5'>Figure 2.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/hello4.hny'>code/hello4.hny</a>] Harmony program with an infinite number of possible outputs</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-6'>Figure 2.4</a></td><td> Demonstrating Harmony methods and threads</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-7'>Figure 2.5</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/hello7.hny'>code/hello7.hny</a>] Various interleavings of threads</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-8'>Figure 2.6</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/hello8.hny'>code/hello8.hny</a>] Making groups of operations atomic reduces interleaving</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-9'>Figure 2.7</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/triangle.hny'>code/triangle.hny</a>] Computing triangle numbers</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-10'>Figure 2.8</a></td><td> Running the code in <a href='#sec-9'>Figure 2.7</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-11'>Figure 2.9</a></td><td> Running the code in <a href='#sec-9'>Figure 2.7</a> for <var>N</var> = 100</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-17'>Figure 3.1</a></td><td> A sequential and a concurrent program</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-18'>Figure 3.2</a></td><td> The output of running the code in <a href='#sec-17'>Figure 3.1</a>(b)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-19'>Figure 3.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/Up.hny'>code/Up.hny</a>] Incrementing the same variable twice in parallel</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-20'>Figure 3.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/Upr.hny'>code/Upr.hny</a>] What actually happens in <a href='#sec-19'>Figure 3.3</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-21'>Figure 3.5</a></td><td> The output of running the code in <a href='#sec-19'>Figure 3.3</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-22'>Figure 3.6</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/Upf.hny'>code/Upf.hny</a>] Demonstrating the <b>finally</b> clause.</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-26'>Figure 3.7</a></td><td> [<a href='https://harmony.cs.cornell.edu/python/Up.py'>python/Up.py</a>] Python implementation of <a href='#sec-19'>Figure 3.3</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-27'>Figure 3.8</a></td><td> [<a href='https://harmony.cs.cornell.edu/python/UpMany.py'>python/UpMany.py</a>] Using Python to increment <var>N</var> times</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-31'>Figure 4.1</a></td><td> The first part of the HVM bytecode corresponding to <a href='#sec-19'>Figure 3.3</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-32'>Figure 4.2</a></td><td> The
<a href="https://harmony.cs.cornell.edu/output/Up.html">HTML output</a>
of running Harmony on <a href='#sec-19'>Figure 3.3</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-35'>Figure 4.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/UpEnter.hny'>code/UpEnter.hny</a>] Incorrect attempt at fixing the code of <a href='#sec-19'>Figure 3.3</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-37'>Figure 5.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/csbarebones.hny'>code/csbarebones.hny</a>] Modeling a critical section</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-38'>Figure 5.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/cs.hny'>code/cs.hny</a>] Harmony model of a critical section</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-39'>Figure 5.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/naiveLock.hny'>code/naiveLock.hny</a>] Na&iuml;ve implementation of a shared lock and the markdown output of running Harmony</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-40'>Figure 5.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/naiveFlags.hny'>code/naiveFlags.hny</a>] Na&iuml;ve use of flags to solve mutual exclusion</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-41'>Figure 5.5</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/naiveTurn.hny'>code/naiveTurn.hny</a>] Na&iuml;ve use of turn variable to solve mutual exclusion</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-45'>Figure 6.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/Peterson.hny'>code/Peterson.hny</a>] Peterson's Algorithm</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-46'>Figure 6.2</a></td><td> Venn diagram classifying all states and a trace</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-52'>Figure 6.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/csonebit.hny'>code/csonebit.hny</a>] Mutual exclusion using a flag per thread</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-54'>Figure 7.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/PetersonMethod.hny'>code/PetersonMethod.hny</a>] Peterson's Algorithm accessed through methods</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-55'>Figure 7.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/hanoi.hny'>code/hanoi.hny</a>] Towers of Hanoi</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-56'>Figure 7.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/clock.hny'>code/clock.hny</a>] Harmony program that finds page replacement anomalies</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-59'>Figure 8.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/lock.hny'>code/lock.hny</a>] Specification of a lock</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-60'>Figure 8.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/lock_demo.hny'>code/lock_demo.hny</a>] Using a lock to implement a
critical section</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-61'>Figure 8.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/UpLock.hny'>code/UpLock.hny</a>] <a href='#sec-19'>Figure 3.3</a> fixed with a lock</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-63'>Figure 9.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/spinlock.hny'>code/spinlock.hny</a>] Mutual Exclusion using a &quot;spinlock&quot; based on test-and-set</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-68'>Figure 10.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/lock_tas.hny'>code/lock_tas.hny</a>] Implementation of the lock
specification in <a href='#sec-59'>Figure 8.1</a> using a spinlock based on
test-and-set</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-69'>Figure 10.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/lock_ticket.hny'>code/lock_ticket.hny</a>] Implementation of the lock
specification in <a href='#sec-59'>Figure 8.1</a> using a ticket lock</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-70'>Figure 10.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/lock_test1.hny'>code/lock_test1.hny</a>] A test program for locks
(based on \autoref{fig:cs})</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-71'>Figure 10.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/modules/lock_susp.hny'>modules/lock_susp.hny</a>] Lock implementation using suspension</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-76'>Figure 10.5</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/xy.hny'>code/xy.hny</a>] Incomplete code for <a href='#sec-73'>Exercise 10.2</a> with desired invariant  <span 
class="cmmi-10">x </span>+ <span 
class="cmmi-10">y </span>= 100 </td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-77'>Figure 10.6</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/atm.hny'>code/atm.hny</a>] Withdrawing money from an ATM</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-79'>Figure 11.1</a></td><td> A sequential and a concurrent specification of a queue</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-80'>Figure 11.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queue_test1.hny'>code/queue_test1.hny</a>] Using a concurrent queue</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-81'>Figure 11.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queue_lock.hny'>code/queue_lock.hny</a>] An implementation of a concurrent queue data structure and a depiction of a queue with three elements</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-82'>Figure 11.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queue_MS.hny'>code/queue_MS.hny</a>] A queue with separate locks for enqueuing and dequeuing items and a depiction of a queue with two elements</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-89'>Figure 12.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/setobj.hny'>code/setobj.hny</a>] Specification of a concurrent
set object</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-90'>Figure 12.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/setobj_test1.hny'>code/setobj_test1.hny</a>] Test code for set objects</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-91'>Figure 12.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/setobj_linkedlist.hny'>code/setobj_linkedlist.hny</a>] Implementation of a set of values using a linked list with fine-grained locking</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-96'>Figure 13.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queue_test_seq.hny'>code/queue_test_seq.hny</a>] Sequential queue test</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-97'>Figure 13.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queue_btest1.hny'>code/queue_btest1.hny</a>] Concurrent queue test.  The
behavior DFA is for  <span 
class="cmtt-10">NOPS</span> = 2 .</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-98'>Figure 13.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/python/queue_btest1.py'>python/queue_btest1.py</a>] Python implementation of <a href='#sec-97'>Figure 13.2</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-99'>Figure 13.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queue_nonatom_seq.hny'>code/queue_nonatom_seq.hny</a>] Sequential but not a concurrent
queue implementation</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-105'>Figure 14.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queue_broken.hny'>code/queue_broken.hny</a>] Another buggy queue implementation</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-106'>Figure 14.2</a></td><td> Running <a href='#sec-97'>Figure 13.2</a> against <a href='#sec-105'>Figure 14.1</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-107'>Figure 14.3</a></td><td> 
<a href="https://harmony.cs.cornell.edu/output/queuebug.html">HTML output</a> of
<a href='#sec-106'>Figure 14.2</a> but for <var>NOPS</var>=3</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-108'>Figure 14.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queue_fix.hny'>code/queue_fix.hny</a>] Queue implementation with hand-over-hand locking</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-110'>Figure 15.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rwlock.hny'>code/rwlock.hny</a>] Specification of reader/writer locks</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-111'>Figure 15.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rwlock_test1.hny'>code/rwlock_test1.hny</a>] Test code for reader/writer locks</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-113'>Figure 15.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rwlock_cheat.hny'>code/rwlock_cheat.hny</a>] "Cheating" reader/writer lock</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-114'>Figure 15.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rwlock_btest.hny'>code/rwlock_btest.hny</a>] A behavioral test of reader/writer locks</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-115'>Figure 15.5</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rwlock_busy.hny'>code/rwlock_busy.hny</a>] Busy waiting reader/writer lock</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-116'>Figure 15.6</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/boundedbuffer.hny'>code/boundedbuffer.hny</a>] Bounded buffer specification</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-119'>Figure 16.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rwlock_sbs.hny'>code/rwlock_sbs.hny</a>] Reader/Writer Lock using Split Binary Semaphores</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-130'>Figure 16.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/gpu.hny'>code/gpu.hny</a>] A thread-unsafe GPU allocator</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-132'>Figure 17.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rwlock_fair.hny'>code/rwlock_fair.hny</a>] Reader/Writer Lock SBS implementation addressing fairness</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-135'>Figure 18.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/modules/hoare.hny'>modules/hoare.hny</a>] Implementation of Hoare monitors</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-136'>Figure 18.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/boundedbuffer_hoare.hny'>code/boundedbuffer_hoare.hny</a>] Bounded Buffer implemented using
a Hoare monitor</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-137'>Figure 18.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/modules/synch.hny'>modules/synch.hny</a>]
Implementation of condition variables in the <var>synch</var> module</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-138'>Figure 18.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rwlock_cv.hny'>code/rwlock_cv.hny</a>] Reader/Writer Lock using Mesa-style condition variables</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-144'>Figure 18.5</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/qsort.hny'>code/qsort.hny</a>] Iterative qsort() implementation</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-145'>Figure 18.6</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/qsorttest.hny'>code/qsorttest.hny</a>] Test program for <a href='#sec-144'>Figure 18.5</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-147'>Figure 19.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/Diners.hny'>code/Diners.hny</a>] Dining Philosophers</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-148'>Figure 19.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/DinersCV.hny'>code/DinersCV.hny</a>] Dining Philosophers that grab both forks at the same time</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-149'>Figure 19.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/DinersAvoid.hny'>code/DinersAvoid.hny</a>] Dining Philosophers that carefully avoid getting into a deadlock scenario</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-154'>Figure 19.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/bank.hny'>code/bank.hny</a>] Bank accounts</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-156'>Figure 20.1</a></td><td> Depiction of three actors.  The producer does not receive messages.</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-157'>Figure 20.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/counter.hny'>code/counter.hny</a>] An illustration of the actor approach</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-160'>Figure 21.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/barrier_test1.hny'>code/barrier_test1.hny</a>] Test program for <a href='#sec-161'>Figure 21.2</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-161'>Figure 21.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/barrier.hny'>code/barrier.hny</a>] Barrier implementation</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-162'>Figure 21.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/barrier_test2.hny'>code/barrier_test2.hny</a>] Demonstrating the double-barrier pattern</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-163'>Figure 21.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/bsort.hny'>code/bsort.hny</a>] Parallel bubble sort</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-167'>Figure 22.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file.hny'>code/file.hny</a>] Specification of the file system</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-168'>Figure 22.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file_btest.hny'>code/file_btest.hny</a>] Test program for a concurrent file system</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-169'>Figure 22.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/disk.hny'>code/disk.hny</a>] Specification of a disk</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-170'>Figure 22.4</a></td><td> The file system data structure: (a) disk layout
(1 superblock, <i>n</i> blocks,  <span 
class="cmmi-10">b</span>
 bitmap blocks,
 <span 
class="cmmi-10">m </span> inode blocks, 4 inodes per block);
(b) inode for a file with 3 data blocks</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-171'>Figure 22.5</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File system implementation preamble</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-172'>Figure 22.6</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File system interface implementation</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-173'>Figure 22.7</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File server and worker threads</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-174'>Figure 22.8</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File system initialization</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-175'>Figure 22.9</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File system bitmap maintenance</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-176'>Figure 22.10</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] Handling of read-only file requests</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-177'>Figure 22.11</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] Handling of write requests</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-178'>Figure 22.12</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/wal.hny'>code/wal.hny</a>] Specification of a Write Ahead Log</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-180'>Figure 23.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/trap.hny'>code/trap.hny</a>] How to use <b>trap</b></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-181'>Figure 23.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/trap2.hny'>code/trap2.hny</a>] A race condition with interrupts</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-182'>Figure 23.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/trap3.hny'>code/trap3.hny</a>] Locks do not work with interrupts</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-183'>Figure 23.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/trap4.hny'>code/trap4.hny</a>] Disabling and enabling interrupts</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-184'>Figure 23.5</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/trap5.hny'>code/trap5.hny</a>] Example of an interrupt-safe method</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-185'>Figure 23.6</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/trap6.hny'>code/trap6.hny</a>] Code that is both interrupt-safe and thread-safe</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-188'>Figure 24.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/hw.hny'>code/hw.hny</a>] Non-blocking queue</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-191'>Figure 25.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/abp.hny'>code/abp.hny</a>] Alternating Bit Protocol</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-192'>Figure 25.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/abptest.hny'>code/abptest.hny</a>] Test code for alternating bit protocol</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-197'>Figure 26.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/leader.hny'>code/leader.hny</a>] A leader election protocol on a ring</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-201'>Figure 27.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/2pc.hny'>code/2pc.hny</a>] Two Phase Commit protocol: code for banks</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-202'>Figure 27.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/2pc.hny'>code/2pc.hny</a>] Two Phase Commit protocol: code for transaction coordinators</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-208'>Figure 28.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/rsm.hny'>code/rsm.hny</a>] Replicated State Machine</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-209'>Figure 28.2</a></td><td> The DFA generated by <a href='#sec-208'>Figure 28.1</a> when <var>NOPS</var>=2
and <var>NREPLICAS</var>=2</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-210'>Figure 28.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/chain.hny'>code/chain.hny</a>] Chain Replication (part 1)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-211'>Figure 28.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/chain.hny'>code/chain.hny</a>] Chain Replication (part 2)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-213'>Figure 29.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/chainaction.hny'>code/chainaction.hny</a>] Chain Replication specification using actions (part 1)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-214'>Figure 29.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/chainaction.hny'>code/chainaction.hny</a>] Chain Replication specification using actions (part 2)</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-216'>Figure 30.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/register.hny'>code/register.hny</a>] An atomic read/write register</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-217'>Figure 30.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/abdtest.hny'>code/abdtest.hny</a>] Behavioral test for atomic read/write registers and the output for the case that <var>NREADERS</var> = <var>NWRITERS</var> = 1</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-218'>Figure 30.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/abd.hny'>code/abd.hny</a>] An implementation of a replicated atomic read/write register</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-220'>Figure 31.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/consensus.hny'>code/consensus.hny</a>] Distributed consensus code and behavior DFA</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-221'>Figure 31.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/bosco.hny'>code/bosco.hny</a>] A crash-tolerant consensus protocol</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-222'>Figure 31.3</a></td><td> The behavior DFA for <a href='#sec-221'>Figure 31.2</a></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-223'>Figure 31.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/bosco2.hny'>code/bosco2.hny</a>] Reducing the state space</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-227'>Figure 32.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/paxos.hny'>code/paxos.hny</a>] A version of the Paxos protocol</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-231'>Figure 33.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/needhamschroeder.hny'>code/needhamschroeder.hny</a>] Needham-Schroeder protocol and an attack</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-260'>Figure B.1</a></td><td> Using <b>save</b> and <b>go</b> to implement <code>fork()</code></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-279'>Figure B.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/stacktest.hny'>code/stacktest.hny</a>] Testing a stack implementation.</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-280'>Figure B.3</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/stack1.hny'>code/stack1.hny</a>] Stack implemented using a dynamically updated list.</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-281'>Figure B.4</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/stack2.hny'>code/stack2.hny</a>] Stack implemented using static lists.</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-282'>Figure B.5</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/stack3.hny'>code/stack3.hny</a>] Stack implemented using a recursive tuple data structure.</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-283'>Figure B.6</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/stack4.hny'>code/stack4.hny</a>] Stack implemented using a linked list.</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-306'>Figure G.1</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/queuelin.hny'>code/queuelin.hny</a>] Queue implementation with linearization points</td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;</td><td><a href='#sec-307'>Figure G.2</a></td><td> [<a href='https://harmony.cs.cornell.edu/code/qtestconc.hny'>code/qtestconc.hny</a>] Concurrent queue test</td></tr>
</table>
<p><div id='sec-1'>
<h1>Chapter 1. On Concurrent Programming</h1>

<p>Programming with concurrency is hard.  On the one hand concurrency
can make programs faster than sequential ones, but having multiple
<a id="index:thread:1"></a>
threads read and update shared variables
<a id="index:shared-variable:1"></a>
concurrently and synchronize with one another makes programs more
complicated than programs where only one thing happens at a time.
<a id="gls:concurrent-execution:1"></a>
<a id="gls:shared-variable:1"></a>
<a id="gls:sequential-execution:1"></a>
<a id="gls:determinism:1"></a>
<a id="gls:atomicity:1"></a>
Why are concurrent
programs more complicated than sequential ones?
There are, at least, two reasons:
<ul><li> The execution of a sequential
<a id="index:sequential:1"></a>
program is mostly <i>deterministic</i>.
<a id="index:determinism:1"></a>
If you run it twice with the same input, the same output will be produced.
Bugs are typically easily reproducible and easy to track down, for example
by instrumenting the program.
On the other hand,
the output of running concurrent programs depends on how the
execution of the various threads are <i>interleaved</i>.
Some bugs may occur only occasionally and
may never occur when the program is instrumented to find them
(so-called <i>Heisenbugs</i>---overhead caused by instrumentation
leads to timing changes that makes such bugs less likely to occur).
<a id="index:Heisenbug:1"></a>
<li> In a sequential program, each statement and each function can be
thought of as happening <i>atomically</i> (indivisibly)
<a id="index:atomicity:1"></a>
because there is no other activity interfering with their execution.
Even though a statement or function may
be compiled into multiple machine instructions, they are executed back-to-back
until completion.  Not so with a concurrent program, where other threads
may update memory locations while a statement or function is being executed.
</ul>
The lack of determinism and atomicity in concurrent programs make them
not only hard to reason about, but also hard to test.
<a id="index:test:1"></a>
Running the same test of concurrent code twice is likely to produce
two different results.  More problematically, a test may trigger a
bug only for certain &quot;lucky&quot; executions.  Due to the probabilistic
nature of concurrent code, some bugs may be highly unlikely to get
triggered even when running a test millions of times.  And even if
a bug does get triggered, the source of the bug may be hard to find
because it is hard to reproduce.<p><a id="gls:model-checking:1"></a><p>This book is intended to help people with understanding and
developing concurrent code, which includes programs for distributed
systems.  In particular, it uses a tool
called Harmony that helps with <i>testing</i> concurrent code.
The approach is based on <i>model checking</i> [<a href="#cite-CES86">8</a>]:
<a id="index:model-checking:1"></a>
instead of relying
on luck, Harmony will run <i>all possible executions</i> of a particular
test program.  So, even if a bug is unlikely to occur, if the test
<i>can</i> expose the bug it <i>will</i>.  Moreover, if the bug is
found, the model checker precisely shows how to trigger the bug in
the smallest number of steps.<p>Model checking is not a replacement for formal verification.
<a id="index:formal-verification:1"></a>
Formal verification proves that a program is correct.  Model checking only
verifies that a program is correct for some <i>model</i>.  Think of
a model as a test program.
Because model checking tries every possible execution, the test
program needs to be simple---otherwise it may take longer than we
care to wait for or run out of memory.
In particular, the model needs to have a relatively small number of
reachable states.<p>If model checking does not prove a program correct, why is it
useful?
To answer that question, consider a sorting algorithm.
Suppose we create a test program, a model, that tries sorting
<i>all</i> lists of up to five numbers chosen from the set
{1, 2, 3, 4, 5 }.  Model checking proves that for those particular
scenarios the sorting algorithm works: the output is a sorted
permutation of the input.  In some sense it is an excellent test:
it will have considered all <i>corner cases</i>,
<a id="index:corner-case:1"></a>
including lists where all
numbers are the same, lists that are already sorted or reversely
sorted, etc.  If there is a bug in the sorting algorithm, most
likely it would be triggered and the model checker would produce a
scenario that would make it easy to find the source of the bug.<p>However, if the model checker does not find any bugs, we do not
know for sure that the algorithm works for lists of more than
five numbers or for lists that have values other than the numbers
1 through 5.  Still, we would expect that the likelihood that there
are bugs remaining in the sorting algorithm is small.
That said, it would be easy to write a program
that sorts all lists of up to five numbers correctly but fails to
do so for a list of 6 numbers.  (Hint: simply use an <b>if</b>
statement.)<p><a id="gls:invariant:1"></a><p>While model checking does not in general prove an algorithm correct,
it can help with proving an algorithm correct.
The reason is that many correctness properties can be proved using
<i>invariants</i>:
<a id="index:invariant:1"></a>
predicates that must hold for every state in the
execution of a program.  A model checker can find violations of
proposed invariants when evaluating a model and provide valuable early
feedback to somebody who is trying to construct a proof, even an
informal one.
We will include examples
of such invariants as they often provide excellent insight into
why a particular algorithm works.<p>So, what is Harmony?
Harmony is a concurrent programming language.  It was designed to teach
the basics of concurrent and distributed programming, but it is also useful for
testing new concurrent algorithms or even sequential and distributed
algorithms.  Harmony programs are not intended to be &quot;run&quot; like programs
in most other programming languages---instead Harmony programs are
model checked to test that the program has certain desirable
properties and does not suffer from bugs.<p>The syntax and semantics of Harmony is similar to that of Python.
Python is familiar to many programmers and is easy to learn and
use.  We will assume that the reader is familiar with the basics
of Python programming.  We also will assume that the reader
understands some basics of machine architecture and how programs
are executed.  For example, we assume that the reader is familiar
with the concepts of CPU, memory, register, stack, and machine
instructions.<p>Harmony is heavily influenced by Leslie Lamport's work on
TLA+, TLC, and PlusCal [<a href="#cite-Lamport02">30</a>, <a href="#cite-Lamport09">31</a>],
Gerard Holzmann's work on Promela and SPIN [<a href="#cite-SPIN">26</a>],
and University of Washington's DSLabs system [<a href="#cite-MWA19">36</a>].
Some of the examples in this book are derived from those sources.
Harmony is designed to have a lower learning curve than those
systems, but is not as powerful.  When you finish this book
and want to learn more, we strongly encourage checking
those out.
Another excellent resource is Fred Schneider's book ``On
Concurrent Programming'' [<a href="#cite-Schneider97">41</a>].
(This chapter is named after that book.)<p>The book proceeds as follows:<p><ul><li> <a href='#sec-2'>Chapter 2</a> introduces the Harmony programming
language, as it provides the language for presenting synchronization
problems and solutions.
<li> <a href='#sec-16'>Chapter 3</a> illustrates the problem of
concurrent programming through a simple example in which two threads
are concurrently incrementing a counter.
<li> <a href='#sec-28'>Chapter 4</a> presents the
Harmony virtual machine to understand the problem
underlying concurrency better.
<li> <a href='#sec-36'>Chapter 5</a> introduces the concept of a
<i>critical section</i> and presents various flawed implementations
of critical sections to demonstrate that implementing a critical section
is not trivial.
<li> <a href='#sec-44'>Chapter 6</a> introduces <i>Peterson's Algorithm</i>, an
elegant (although not very efficient or practical) solution to implementating a critical section.
<li> <a href='#sec-53'>Chapter 7</a> gives some more details on the Harmony
language needed for the rest of the book.
<li> <a href='#sec-58'>Chapter 8</a> talks about how Harmony can be used as
a specification language.  It introduces how to specify atomic
constructs.
<li> <a href='#sec-62'>Chapter 9</a> introduces atomic <i>locks</i>
for implemented critical sections.
<li> <a href='#sec-67'>Chapter 10</a> looks at various ways in which the lock specification
in <a href='#sec-58'>Chapter 8</a> can be implemented.
<li> <a href='#sec-78'>Chapter 11</a> gives an introduction to building concurrent
data structures.
<li> <a href='#sec-88'>Chapter 12</a> gives an example of fine-grained locking
methods that allow more concurrency than coarse-grained approaches..
<li> <a href='#sec-95'>Chapter 13</a> discusses approaches to testing
concurrent code in Harmony.
<li> <a href='#sec-104'>Chapter 14</a> instead goes into how to find a bug
in concurrent code using the Harmony output.
<li> <a href='#sec-109'>Chapter 15</a> talks about threads having to wait for
certain conditions.  As examples, it presents the reader/writer lock
problem and the bounded buffer problem.
<li> <a href='#sec-118'>Chapter 16</a> presents <i>Split Binary Semaphores</i>, a
general technique for solving synchronization problems.
<li> <a href='#sec-131'>Chapter 17</a> talks about <i>starvation</i>:
the problem that in some
synchronization approaches threads may not be able to get access to a
resource they need.
<li> <a href='#sec-134'>Chapter 18</a> presents
<i>monitors</i> and <i>condition variables</i>,
another approach to thread synchronication.
<li> <a href='#sec-146'>Chapter 19</a> describes <i>deadlock</i>
where a set of threads are indefinitely waiting for one another to
release a resource.
<li> <a href='#sec-155'>Chapter 20</a> presents the <i>actor model</i>
and <i>message passing</i> as an approach to synchronization.
<li> <a href='#sec-159'>Chapter 21</a> describes <i>barrier synchronization</i>,
useful in high-performance computing applications such as parallel simulations.
<li> <a href='#sec-166'>Chapter 22</a> presents a concurrent file system as as larger example
of a concurrent program.
<li> <a href='#sec-179'>Chapter 23</a> discusses how to handle interrupts,
a problem closely related to---but not the same as---synchronizing threads.
<li> <a href='#sec-187'>Chapter 24</a> introduces <i>non-blocking</i> or
<i>wait-free</i> synchronization algorithms,
which prevent threads waiting for one another more than a bounded number of
steps.
<li> <a href='#sec-190'>Chapter 25</a> presents a problem and a solution to the distributed
systems problem of having two threads communicate reliably over an unreliable
network.
<li> <a href='#sec-196'>Chapter 26</a> presents a protocol for electing a leader on
a ring of processors, where each processor is uniquely identified and 
only knows its successor on the ring.
<li> <a href='#sec-200'>Chapter 27</a> describes atomic database transactions and the two-phase commit protocol used to implement them.
<li> <a href='#sec-207'>Chapter 28</a> describes <i>state machine replication</i> and
the <i>chain replication</i> protocol to support replication.
<li> <a href='#sec-212'>Chapter 29</a> describes an alternative way to write
concurrent and distributed specifications in Harmony, using chain
replication as an example.
<li> <a href='#sec-215'>Chapter 30</a> presents a protocol for a fault-tolerant
replicated object that supports only read and write operations.
<li> <a href='#sec-219'>Chapter 31</a> demonstrates a fault-tolerant distributed consensus
algorithm (aka protocol) expressed in Harmony.
<li> <a href='#sec-226'>Chapter 32</a> shows how one can specify and check the well-known
Paxos consensus protocol.
<li> <a href='#sec-230'>Chapter 33</a> demonstrates using Harmony to find a (known) bug in the original Needham-Schroeder authentication protocol.
</ul>

If you already know about concurrent and distributed programming and
are just interested in a &quot;speed course&quot; on Harmony, I would recommend
reading <a href='#sec-2'>Chapter 2</a>, <a href='#sec-28'>Chapter 4</a>,
<a href='#sec-53'>Chapter 7</a>, <a href='#sec-58'>Chapter 8</a>, and <a href='#sec-78'>Chapter 11</a>.
The appendices contain various details about Harmony itself, including
an appendix on convenient Harmony modules (<a href='#sec-286'>Appendix B</a>),
and an appendix that explains how Harmony works (<a href='#sec-300'>Appendix D</a>).
</div>





<p><div id='sec-2'>
<h1>Chapter 2. Hello World!</h1>

<p>

<p><div id='sec-3'>
<center><img src="figures/hello1.png" width="45%"></img>
</center>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>print</b> "hello world"
</code></pre>

</center>
<h4>Figure 2.1. [<a href='https://harmony.cs.cornell.edu/code/hello1.hny'>code/hello1.hny</a>] Hello World!</h4>


</div>

The first programming book that I read cover to cover was
<i>The C Programming Language</i>
(first edition) by Brian W. Kernighan and Dennis M. Ritchie, which
was around 1980.  I did not know at the time that 10 years later Dennis,
the designer of the C programming language, would be my boss at
AT&T Bell Labs
in Murray Hill, NJ, while Brian would be my colleague in the same lab.
The first C program in the book printed
the string &quot;hello, world&quot;.  Since then, most programming tutorials for
pretty much any programming language start with that example.<p>Harmony, too, has a Hello World program.
<a href='#sec-3'>Figure 2.1</a> shows the program and the corresponding output.
After installation (see <a href='https://harmony.cs.cornell.edu'>https://harmony.cs.cornell.edu</a>), you
can run it as follows from the command line:
<center>$ harmony code/hello1.hny
</center>
Try it out (here <code>$</code> represents a shell prompt).
For this to work, make sure <code>harmony</code> is in your command shell's
search path.
The code for examples in this book can be found in the <code>code</code>
folder under the name listed in the caption of the example.
If you need to, you can download the sources separately from
<a href='https://harmony.cs.cornell.edu/sources.zip'>https://harmony.cs.cornell.edu/sources.zip</a>.
In this case, the file <code>code/hello1.hny</code> contains the
code in <a href='#sec-3'>Figure 2.1</a>.
The output is a <i>Deterministic State Machine</i> (DFA).  The green circle
represents the initial state and the double circle represents the final
state.  There is one <i>transition</i>, labeled with the string
&quot;hello world&quot;.  The DFA describes (or <i>recognizes</i>) all possible
outputs that the program can generate.  In this case, there is only one.<p><a id="index:choose-operator:1"></a>
But programs can usually have more than one execution and produce multiple
different outputs as a result.  This is usually as a result of different
inputs, but Harmony programs do not have inputs. Instead,
<a href='#sec-4'>Figure 2.2</a> demonstrates
<i>nondetermistic choice</i> in Harmony programs.  In this case, the
program chooses to print either &quot;hello&quot; or &quot;world&quot;.  The corresponding
DFA captures both possibilities.
You can think of the <b>choose</b> operator as enumerating all possible
inputs to the program.<p><a href='#sec-5'>Figure 2.3</a> shows a program that has an infinite number of possible
outputs by using a loop with a non-deterministic stopping condition.
Harmony usually requires that any program must be able
to terminate, so the loop is conditioned on a nondeterministic choice between
<b>False</b> and <b>True</b>.  The possible outputs consist of zero or
more copies of the string &quot;hello world&quot;.  Note that this single state DFA
(where the initial state and the final state happen to be the same)
captures an infinite number of possible executions of the program.<p><div id='sec-4'>
<center><img src="figures/hello3.png" width="30%"></img>
</center>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>print</b> <b>choose</b> { "hello", "world" }
</code></pre>

</center>
<h4>Figure 2.2. [<a href='https://harmony.cs.cornell.edu/code/hello3.hny'>code/hello3.hny</a>] Harmony program with two possible outputs</h4>


</div>

<div id='sec-5'>
<center><img src="figures/hello4.png" width="10%"></img>
</center>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>while</b> <b>choose</b> { <b>False</b>, <b>True</b> }:
    <b>print</b> "hello world"
</code></pre>

</center>
<h4>Figure 2.3. [<a href='https://harmony.cs.cornell.edu/code/hello4.hny'>code/hello4.hny</a>] Harmony program with an infinite number of possible outputs</h4>


</div>

<div id='sec-6'>
 <center><table border='0'>
 <tr>
<td>
<img src="figures/hello5.png" width="90%"></img></td>

<td>
<img src="figures/hello6.png" width="90%"></img></td>


</tr>
<tr>
<td>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>p</var>(<i>s</i>):
    <b>print</b> <i>s</i>

<var>p</var>("hello")
<var>p</var>("world")
</code></pre>
</td>

<td>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>p</var>(<i>s</i>):
    <b>print</b> <i>s</i>

<b>spawn</b> <var>p</var>("hello")
<b>spawn</b> <var>p</var>("world")
</code></pre>
</td>


</tr>
<tr>
<td>
(a) [<a href='https://harmony.cs.cornell.edu/code/hello5.hny'>code/hello5.hny</a>]</td>

<td>
[<a href='https://harmony.cs.cornell.edu/code/hello6.hny'>code/hello6.hny</a>]</td>

</tr>
</table>
</center>
<h4>Figure 2.4. Demonstrating Harmony methods and threads</h4>


</div>

<a href='#sec-6'>Figure 2.4</a> demonstrates <i>methods</i> and <i>threads</i> in Harmony.
In <a href='#sec-6'>Figure 2.4</a>(a), the code simply prints the
strings &quot;hello&quot; and &quot;world&quot;, in that order.
Notice that this leads to an intermediate
state after &quot;hello&quot; is printed but before &quot;world&quot; is.  However, there
is still only one execution possible. <a href='#sec-6'>Figure 2.4</a>(b) shows two
threads, one printing &quot;hello&quot; and one printing &quot;world&quot;.  Because the
threads run concurrently, the program can either output &quot;hello world&quot; or
&quot;world hello&quot;.  Printing in Harmony is atomic, so &quot;hweolrllod&quot; is not
a possible output.<p><div id='sec-7'>
<center><img src="figures/hello7.png" width="90%"></img>
</center>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>hello</var>(<i>name</i>):
    <b>print</b> "hello"
    <b>print</b> <i>name</i>

<b>spawn</b> <var>hello</var>("Lesley")
<b>spawn</b> <var>hello</var>("Robbert")
</code></pre>

</center>
<h4>Figure 2.5. [<a href='https://harmony.cs.cornell.edu/code/hello7.hny'>code/hello7.hny</a>] Various interleavings of threads</h4>


</div>

<div id='sec-8'>
<center><img src="figures/hello8.png" width="90%"></img>
</center>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>hello</var>(<i>name</i>):
    <b>atomically</b>:
        <b>print</b> "hello"
        <b>print</b> <i>name</i>

<b>spawn</b> <var>hello</var>("Lesley")
<b>spawn</b> <var>hello</var>("Robbert")
</code></pre>

</center>
<h4>Figure 2.6. [<a href='https://harmony.cs.cornell.edu/code/hello8.hny'>code/hello8.hny</a>] Making groups of operations atomic reduces interleaving</h4>


</div>

<a href='#sec-7'>Figure 2.5</a> shows two threads, one printing the strings
&quot;hello&quot; and &quot;Robbert&quot;, while the other prints &quot;hello&quot; and
&quot;Lesley&quot;.  Now there are four possible outputs depending on
how the two threads are interleaved, including
&quot;hello hello Lesley Robbert&quot;.  This is probably not what
the programmer wanted.  <a href='#sec-8'>Figure 2.6</a> shows another
important feature of Harmony: <i>atomic blocks</i>.  The
program is similar to <a href='#sec-7'>Figure 2.5</a>, but the programmer
specified that the two print statements in a thread should
be executed as an atomic unit.  As a result, there are only
two interleavings possible.<p>Harmony is a programming language that borrows much of
Python's syntax.
Like Python, Harmony is an imperative,
dynamically typed programming language.
There are also some important differences:
<ul><li> Harmony purposely only supports basic operator precedence or associativity.
Use parentheses liberally to remove ambiguity.
<li> Harmony does not support floating point;
<li> Python is object-oriented, supporting classes with methods and
inheritance; Harmony has objects but does not support classes.
Harmony supports pointers, allowing construction of
complicated data structures.
<li> In Python, lists, dictionaries, and sets are objects.  In
Harmony, they are values.
</ul>
There are also less important differences that you will discover as
you get more familiar with programming in Harmony.<p><p><div id='sec-9'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>N</var> = 10

<b>def</b> <var>triangle</var>(<i>n</i>) <b>returns</b> <i>result</i>:   <i># computes the n'th triangle number</i>
    <i>result</i> = 0
    <b>for</b> <i>i</i> <b>in</b> {1..n}:     <i># for each integer from 1 to n inclusive</i>
        <i>result</i> += <i>i</i>      <i># add i to result</i>

<i>x</i> = <b>choose</b> {0..N}        <i># select an x between 0 and N inclusive</i>
<b>assert</b> <var>triangle</var>(<i>x</i>) == ((<i>x</i> * (<i>x</i> + 1)) / 2)
</code></pre>

</center>
<h4>Figure 2.7. [<a href='https://harmony.cs.cornell.edu/code/triangle.hny'>code/triangle.hny</a>] Computing triangle numbers</h4>


</div>

<div id='sec-10'>
<center><pre><code class="language-none">$ harmony --noweb code/triangle.hny
</code></pre>
<ul>
<li>Phase 1: compile Harmony program to bytecode</li>
<li>Phase 2: run the model checker (nworkers = 8)
<ul>
<li>13 states (time 0.00s, mem=0.000GB)</li>
</ul></li>
<li>Phase 3: analysis
<ul>
<li>13 components (0.00 seconds)</li>
<li>Check for data races</li>
<li><strong>No issues found</strong></li>
</ul></li>
<li>Phase 4: write results to code/triangle.hco</li>
<li>Phase 5: loading code/triangle.hco</li>
</ul>

<p>open file:///.../code/triangle.htm for detailed information</p>
$
</center>
<h4>Figure 2.8. Running the code in <a href='#sec-9'>Figure 2.7</a></h4>


</div>

<div id='sec-11'>
<center>$ harmony -c N=100 --noweb code/triangle.hny
<ul>
<li>Phase 1: compile Harmony program to bytecode</li>
<li>Phase 2: run the model checker (nworkers = 8)
<ul>
<li>103 states (time 0.00s, mem=0.000GB)</li>
</ul></li>
<li>Phase 3: analysis
<ul>
<li>103 components (0.00 seconds)</li>
<li>Check for data races</li>
<li><strong>No issues found</strong></li>
</ul></li>
<li>Phase 4: write results to code/triangle.hco</li>
<li>Phase 5: loading code/triangle.hco</li>
</ul>

<p>open file:///.../code/triangle.htm for detailed information</p>
$
</center>
<h4>Figure 2.9. Running the code in <a href='#sec-9'>Figure 2.7</a> for <var>N</var> = 100</h4>


</div>

<a href='#sec-9'>Figure 2.7</a> shows another example of a Harmony program.
The example is a sequential program
and has a method <var>triangle</var> that takes
an integer number as argument.  The method declares a variable called
<i>result</i> that eventually contains the result of the
method (there is no <b>return</b> statement in Harmony).  The method
also has a bound variable called <i>n</i> containing the value of the
argument.  The { <i>x..y</i> } notation represents a set containing the numbers
from <i>x</i> to <i>y</i> (inclusive).
(Harmony does not have a <code>range</code> operator like Python.)
The last two lines in the program are the most interesting.
The first assigns to <i>x</i> some unspecified value in the range <code>0..N</code>
and the second verifies that <var>triangle</var>(<i>x</i>) equals  <span 
class="cmmi-10">x</span>(<span 
class="cmmi-10">x </span>+ 1)<span 
class="cmmi-10">&#x2215;</span>2 .<p>Running this Harmony program (<a href='#sec-10'>Figure 2.8</a>)
will try all possible executions, which
includes all possible values for <i>x</i>.  The <code>--noweb</code>
flag tells Harmony not to automatically pop up the web browser window.
The text output from running Harmony is in <code>Markdown</code> format.<p>The <b>assert</b> statement checks that the output is
correct.  If the program is correct, Harmony reports the size of the
&quot;state graph&quot; (13 states in this case).  If not, Harmony also
reports what went wrong, typically by displaying a summary of an execution in
which something went wrong.<p>In Harmony, constants have a default specified value,
but those can be overridden on the command
line using the <code>-c</code> option.
<a id="index:constant:1"></a>
<a href='#sec-11'>Figure 2.9</a> shows how to
test the code for <var>N</var> = 100.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-12"><b>[Ex. 2.1]</b>:  Write a Harmony program that uses <b>choose</b> instead of <b>spawn</b> to create the same
output DFA as <a href='#sec-6'>Figure 2.4</a>(b).
<li id="sec-13"><b>[Ex. 2.2]</b>:  Add the line <b>print</b>(<i>x</i>, <var>triangle</var>(<i>x</i>)) to the end of the
program and create an output png file.  Before you look at it, what
do you think it should look like?
<li id="sec-14"><b>[Ex. 2.3]</b>:  See what happens if, instead of initializing <i>result</i> to 0,
you initialize it to 1.  (You do not need to understand the error report at this time.  They will be explained in more detail in <a href='#sec-28'>Chapter 4</a>.)
<li id="sec-15"><b>[Ex. 2.4]</b>:  Write a Harmony program that computes squares by repeated adding.  So, the program
should compute the square of <i>x</i> by adding <i>x</i> to an initial value of 0 <i>x</i> times.
</ul>
</div>

<div id='sec-16'>
<h1>Chapter 3. The Problem of Concurrent Programming</h1>

<p>

<p><div id='sec-17'>
 <center><table border='0'>
 <tr>
<td>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><i>shared</i> = <b>True</b>

<b>def</b> <var>f</var>(): <b>assert</b> <i>shared</i>
<b>def</b> <var>g</var>(): <i>shared</i> = <b>False</b>

<var>f</var>()
<var>g</var>()
</code></pre>
</td>

<td>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><i>shared</i> = <b>True</b>

<b>def</b> <var>f</var>(): <b>assert</b> <i>shared</i>
<b>def</b> <var>g</var>(): <i>shared</i> = <b>False</b>

<b>spawn</b> <var>f</var>()
<b>spawn</b> <var>g</var>()
</code></pre>
</td>


</tr>
<tr>
<td>
(a) [<a href='https://harmony.cs.cornell.edu/code/prog1.hny'>code/prog1.hny</a>] Sequential</td>

<td>
(b) [<a href='https://harmony.cs.cornell.edu/code/prog2.hny'>code/prog2.hny</a>] Concurrent</td>

</tr>
</table>
</center>
<h4>Figure 3.1. A sequential and a concurrent program</h4>


</div>

<div id='sec-18'>
<center><ul>
<li>Phase 1: compile Harmony program to bytecode</li>
<li>Phase 2: run the model checker (nworkers = 8)
<ul>
<li>10 states (time 0.00s, mem=0.000GB)</li>
</ul></li>
<li>Phase 3: analysis
<ul>
<li><strong>Safety Violation</strong></li>
</ul></li>
<li>Phase 4: write results to code/prog2.hco</li>
<li>Phase 5: loading code/prog2.hco</li>
</ul>

<hr />

<p><strong>Summary: something went wrong in an execution</strong></p>

<p>Here is a summary of an execution that exhibits the issue:</p>

<ul>
<li>Schedule thread T0: <strong>init</strong>()
<ul>
<li>Line 1: Initialize shared to True</li>
<li><strong>Thread terminated</strong></li>
</ul></li>
<li>Schedule thread T2: g()
<ul>
<li>Line 4: Set shared to False (was True)</li>
<li><strong>Thread terminated</strong></li>
</ul></li>
<li>Schedule thread T1: f()
<ul>
<li>Line 3: Harmony assertion failed</li>
</ul></li>
</ul>
</center>
<h4>Figure 3.2. The output of running the code in <a href='#sec-17'>Figure 3.1</a>(b)</h4>


</div>

<a id="gls:thread:1"></a><p>Concurrent programming, aka multithreaded programming, involves multiple
threads
<a id="index:thread:2"></a>
running in parallel while sharing variables.
<a href='#sec-17'>Figure 3.1</a> shows two programs.  Program (a) is sequential.
It sets <i>shared</i> to <b>True</b>, asserts that
<i>shared</i> = <b>True</b> and finally sets <i>shared</i> to <b>False</b>.
If you run the program through Harmony, it will not find any problems
because there is only one execution possible and 1) in that execution
the assertion does not fail and 2) the execution terminates.
Program (b) is concurrent---it executes methods <var>f</var>() and
<var>g</var>() in parallel.
If method <var>g</var>() runs and completes before <var>f</var>(), then
the assertion in <var>f</var>() will fail when <var>f</var>() runs.
This problem is an example of non-determinism: methods <var>f</var>()
and <var>g</var>() can run in either order.
In one order, the assertion fails, while in the other it does not.
But since Harmony checks all possible executions, it will find
the problematic one.<p><a href='#sec-18'>Figure 3.2</a> shows the output of running <a href='#sec-17'>Figure 3.1</a>(b)
through Harmony.  Underneath the line, there is a summary of what
happened in one of the executions.  First, the initialization thread
runs and sets the global variable <i>shared</i> to <b>True</b>.  Then, the thread
running <var>g</var>() runs to completion, setting <i>shared</i> to <b>False</b>.
Finally, the thread running <var>f</var>() runs, and the assertion fails.<p><p><a href='#sec-19'>Figure 3.3</a> presents a more subtle example that illustrates
non-atomicity.
The program initializes two shared variables:
an integer <i>count</i> and
an array <i>done</i> with two booleans.
The program then spawns two threads.
The first runs <var>incrementer</var>(0); the second runs <var>incrementer</var>(1).<p>Method <var>incrementer</var> takes a parameter called <i>self</i>.
It increments <i>count</i> and sets <i>done</i>[<i>self</i>] to <b>True</b>.
It then waits until the other thread is done.
(<b>await</b> <i>c</i> is shorthand for <b>while</b> <b>not</b> <i>c</i>: <b>pass</b>.)
After that, method <var>incrementer</var>
verifies that the value of <i>count</i> equals 2.<p>Note that although the threads are <i>spawned</i> one at a time,
they will execute concurrently.  It is, for example, quite possible
that <code>incrementer(1)</code> finishes before <var>incrementer</var>(0)
even gets going.
And because Harmony tries every possible execution, it will consider
that particular execution as well.
What would the value of <i>count</i> be at the end of that execution?<p><div id='sec-19'>
 <center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>count</i> = 0
<i>done</i> = [ <b>False</b>, <b>False</b> ]

<b>def</b> <var>incrementer</var>(<i>self</i>):
    <i>count</i> = <i>count</i> + 1
    <i>done</i>[<i>self</i>] = <b>True</b>
    <b>await</b> <i>done</i>[1 - <i>self</i>]
    <b>assert</b> <i>count</i> == 2

<b>spawn</b> <var>incrementer</var>(0)
<b>spawn</b> <var>incrementer</var>(1)
</code></pre>

</center>
<h4>Figure 3.3. [<a href='https://harmony.cs.cornell.edu/code/Up.hny'>code/Up.hny</a>] Incrementing the same variable twice in parallel</h4>


</div>

<blockquote><ul><li> Before you run the program, what do you think will happen?  Is the
program correct in that <i>count</i> will always end up being 2?
(You may assume that <code>load</code> and <code>store</code> instructions of the
underlying virtual machine architecture are atomic (indivisible)---in fact
they are.)
</ul>
</blockquote>

<div id='sec-20'>
 <center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>count</i> = 0
<i>done</i> = [ <b>False</b>, <b>False</b> ]

<b>def</b> <var>incrementer</var>(<i>self</i>):
    <b>var</b> <var>register</var> = <i>count</i>    <i># load shared variable count into a private register</i>
    <var>register</var> += 1           <i># increment the register</i>
    <i>count</i> = <var>register</var>        <i># store its value into variable count</i>
    <i>done</i>[<i>self</i>] = <b>True</b>
    <b>await</b> <i>done</i>[1 - <i>self</i>]
    <b>assert</b> <i>count</i> == 2

<b>spawn</b> <var>incrementer</var>(0)
<b>spawn</b> <var>incrementer</var>(1)
</code></pre>

</center>
<h4>Figure 3.4. [<a href='https://harmony.cs.cornell.edu/code/Upr.hny'>code/Upr.hny</a>] What actually happens in <a href='#sec-19'>Figure 3.3</a></h4>


</div>

<a id="gls:machine-instruction:1"></a>
<p>What is going on is that the Harmony program is compiled to machine instructions,
<a id="index:machine-instruction:1"></a>
and it is the machine instructions that are executed by the underlying Harmony
machine.  The details of this appear in <a href='#sec-28'>Chapter 4</a>,
but suffice it to
say that the machine has instructions that load values from memory and store
values into memory.  Importantly, it does not have instructions to atomically
increment or decrement values in shared memory locations.
So, to increment a value in memory,
the machine must do at least three machine instructions.
<a href='#sec-20'>Figure 3.4</a> illustrates this.  (The <b>var</b> statement
declares a new local variable <i>register</i>.)
Conceptually, the machine
<ol><li> loads the value of <i>count</i> from its memory location into a register;
<li> adds 1 to the register;
<li> stores the new value into the memory location of <i>count</i>.
</ol>

When running multiple threads, each essentially runs an instantiation of
the machine, and they do so in parallel.  As they execute, their machine
instructions are interleaved
<a id="index:interleaving:1"></a>
in unspecified and often unpredictable ways.
A program is correct if it works for any interleaving of threads.
Harmony will try all possible interleavings of the threads
executing machine instructions.<p>If the threads run one at a time, then <i>count</i> will be incremented
twice and ends up being 2.  However, the following is also
a possible interleaving of <var>incrementer</var>(0) and <code>incrementer(1)</code>:
<ol><li> <var>incrementer</var>(1) loads the value of <i>count</i>, which is 0;
<li> <code>incrementer(0)</code> loads the value of <i>count</i>, which is still 0;
<li> <code>incrementer(0)</code> adds 1 to the value that it loaded (0), and
stores  1  into <i>count</i>;
<li> <var>incrementer</var>(1) adds 1 to the value that it loaded (0), and
stores  1
 into <i>count</i>;
<li> <var>incrementer</var>(1) sets <i>done</i>[1] to <b>True</b>;
<li> <code>incrementer(0)</code> sets <i>done</i>[0] to <b>True</b>.
</ol>

The result in this particular interleaving is that <i>count</i> ends up
being 1.
This is known as a <i>race condition</i>.
<a id="index:race-condition:1"></a>
When running Harmony, it will
report violations of assertions.  It also provides an example
of an interleaving, like the one above, in which an assertion fails.
<a href='#sec-21'>Figure 3.5</a> shows the output of running <a href='#sec-19'>Figure 3.3</a>
through Harmony.<p><a id="gls:race-condition:1"></a><p><div id='sec-21'>
<center><ul>
<li>Phase 1: compile Harmony program to bytecode</li>
<li>Phase 2: run the model checker (nworkers = 8)
<ul>
<li>42 states (time 0.00s, mem=0.000GB)</li>
</ul></li>
<li>Phase 3: analysis
<ul>
<li><strong>Safety Violation</strong></li>
</ul></li>
<li>Phase 4: write results to code/Up.hco</li>
<li>Phase 5: loading code/Up.hco</li>
</ul>

<hr />

<p><strong>Summary: something went wrong in an execution</strong></p>

<p>Here is a summary of an execution that exhibits the issue:</p>

<ul>
<li>Schedule thread T0: <strong>init</strong>()
<ul>
<li>Line 1: Initialize count to 0</li>
<li>Line 2: Initialize done to [ False, False ]</li>
<li><strong>Thread terminated</strong></li>
</ul></li>
<li>Schedule thread T2: incrementer(1)
<ul>
<li>Preempted in incrementer(1)
about to store 1 into count in line 5</li>
</ul></li>
<li>Schedule thread T1: incrementer(0)
<ul>
<li>Line 5: Set count to 1 (was 0)</li>
<li>Line 6: Set done[0] to True (was False)</li>
<li>Preempted in incrementer(0)</li>
</ul></li>
<li>Schedule thread T2: incrementer(1)
<ul>
<li>Line 5: Set count to 1 (unchanged)</li>
<li>Line 6: Set done[1] to True (was False)</li>
<li>Line 8: Harmony assertion failed</li>
</ul></li>
</ul>
</center>
<h4>Figure 3.5. The output of running the code in <a href='#sec-19'>Figure 3.3</a></h4>


</div>

If one thinks of the assertion as providing the specification of the
program, then clearly its implementation does not satisfy its specification.
Either the specification or the implementation (or both) must have a bug.
We could change the specification by changing the assertion as follows:<p><center><b>assert</b> (<i>count</i> == 1) <b>or</b> (<i>count</i> == 2)
</center>

This would fix the issue,[footnote: 
Actually, Harmony still complains, this time
about a <i>data race</i>, about which you will learn in <a href='#sec-28'>Chapter 4</a>.]

but more likely it is the program that must be fixed, not the specification.<p><div id='sec-22'>
 <center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>count</i> = 0

<b>finally</b> <i>count</i> == 2

<b>def</b> <var>incrementer</var>():
    <i>count</i> = <i>count</i> + 1

<b>spawn</b> <var>incrementer</var>()
<b>spawn</b> <var>incrementer</var>()
</code></pre>

</center>
<h4>Figure 3.6. [<a href='https://harmony.cs.cornell.edu/code/Upf.hny'>code/Upf.hny</a>] Demonstrating the <b>finally</b> clause.</h4>


</div>

<a href='#sec-19'>Figure 3.3</a> uses flags <i>done</i>[0] and <i>done</i>[1] to check if
both threads have finished incrementing <i>count</i>.
Harmony provides a more convenient way to check if some condition holds
when all threads have terminated.
<a href='#sec-22'>Figure 3.6</a> demonstrates the Harmony <b>finally</b> clause.
The <b>finally</b> clause is like
the <b>assert</b> clause, but the condition is only checked when all
threads have finished.  This eliminates the need for a shared variable
like <i>done</i>, simplifies the code, and makes the intention clearer.<p>The exercises below have you try the same thing (having threads
concurrently increment an integer variable) in Python.  As you will
see, the bug is not easily triggered when you run a Python version of
the program.  But in Harmony Murphy's Law applies:
if something can go wrong, it will.  Usually that is not a good thing,
but in Harmony it is.  It allows you to find bugs in your concurrent
programs much more easily than with a conventional programming environment.<p>
<h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-23"><b>[Ex. 3.1]</b>:  Harmony programs can usually be easily translated into
Python by hand.  For example,
<a href='#sec-26'>Figure 3.7</a> is a Python version of <a href='#sec-19'>Figure 3.3</a>.
<ol><li> Run <a href='#sec-26'>Figure 3.7</a> using Python.  Does the assertion fail?
<li> Using a script, run <a href='#sec-26'>Figure 3.7</a> 1000 times.
For example, if you are using the bash shell (in Linux or Mac OS X, say), you can do the following:
<center><pre><code class="language-none">for i in {1..1000}
do
    python Up.py
done
</code></pre>
</center>
If you're using Windows, the following batch script does the trick:
<center><pre><code class="language-none">FOR /L %%i IN (1, 1, 1000) DO python Up.py
PAUSE
</code></pre>
</center>
How many times does the assertion fail (if any)?
</ol>
<li id="sec-24"><b>[Ex. 3.2]</b>:  <a href='#sec-27'>Figure 3.8</a> is a version of <a href='#sec-26'>Figure 3.7</a> that has each
incrementer thread increment <i>count</i> <var>N</var> times.  Run <a href='#sec-27'>Figure 3.8</a>
10 times (using Python).
Report how many times the assertion fails and what the value of <i>count</i>
was for each of the failed runs.
Also experiment with lower values of <var>N</var>.
How large does <var>N</var> need to be for assertions to fail?
(Try powers of 10 for <var>N</var>.)
<li id="sec-25"><b>[Ex. 3.3]</b>:  Can you think of a fix to <a href='#sec-19'>Figure 3.3</a>?  Try one or two different fixes
and run them through Harmony.  Do not worry about having to come up with a correct fix at this
time---the important thing is to develop an understanding of concurrency.
(Also, you do not get to use the <b>atomically</b> keyword
or a <i>lock</i>, yet.)
</ul>

<div id='sec-26'>
<center><pre><code class="language-none">import threading

count = 0
done = [ False, False ]

def incrementer(self):
    global count
    count = count + 1
    done[self] = True
    while not done[1 - self]:
        pass
    assert count == 2

threading.Thread(target=incrementer, args=(0,)).start()
threading.Thread(target=incrementer, args=(1,)).start()
</code></pre>

</center>
<h4>Figure 3.7. [<a href='https://harmony.cs.cornell.edu/python/Up.py'>python/Up.py</a>] Python implementation of <a href='#sec-19'>Figure 3.3</a></h4>


</div>

<div id='sec-27'>
<center><pre><code class="language-none">import threading

N = 1000000
count = 0
done = [ False, False ]

def incrementer(self):
    global count
    for i in range(N):
        count = count + 1
    done[self] = True
    while not done[1 - self]:
        pass
    assert count == 2*N, count

threading.Thread(target=incrementer, args=(0,)).start()
threading.Thread(target=incrementer, args=(1,)).start()
</code></pre>

</center>
<h4>Figure 3.8. [<a href='https://harmony.cs.cornell.edu/python/UpMany.py'>python/UpMany.py</a>] Using Python to increment <var>N</var> times</h4>


</div>
</div>

<div id='sec-28'>
<h1>Chapter 4. The Harmony Virtual Machine</h1>


<a id="index:Harmony-Virtual-Machine:1"></a><p>Harmony programs are compiled to Harmony <i>bytecode</i>
<a id="index:bytecode:1"></a>
(a list of machine instructions for a virtual machine),
which in turn is executed by the Harmony virtual machine (HVM).
<a id="index:virtual-machine:1"></a>
<a id="index:Harmony-Virtual-Machine:2"></a>
<a id="index:HVM:1"></a>
The Harmony compiler, <code>harmony</code>, places the bytecode for file
<i>x</i>.<code>hny</code> in file <i>x</i>.<code>hvm</code>.
The model checker (called <i>Charm</i>) executes the code in
<i>x</i>.<code>hvm</code> and places its output in a file
called <i>x</i>.<code>hco</code>.
From the <i>x</i>.<code>hco</code> file, <code>harmony</code> creates a
detailed human-readable output file in <i>x</i>.<code>hvb</code> and
an interactive HTML file called <i>x</i>.<code>htm</code>.
The <i>x</i>.<code>htm</code> file is automatically opened in your default web
browser unless you specify the <code>--noweb</code> flag to <code>harmony</code>.<p>To understand the problem of concurrent computing, it
is important to have a basic understanding of machine instructions,
and in our case those of the HVM.<p><div id='sec-29'>
<h2 id="sec-29">Harmony Values</h2><p>Harmony programs, and indeed the HVM,  manipulate Harmony values.
Harmony values are recursively defined:
they include booleans (<b>False</b> and <b>True</b>),
integers (but not floating point numbers),
strings (enclosed by single or double quotes),
sets and lists of Harmony values, and dictionaries
<a id="index:dictionary:1"></a>
that map Harmony values to other Harmony values.
Strings that start with a letter or an underscore and only contain
letters, digits, and underscores can be written without quotes by
preceding it with a dot.  So, .<i>example</i> is the same string
as "example".<p>A dictionary maps keys to values.
Unlike Python, which requires that keys must be hashable,
any Harmony value can be a key, including another dictionary.
Dictionaries are written as
 <span 
class="cmsy-10">{</span><span 
class="cmmi-10">k</span><sub><span 
class="cmr-7">0</span></sub> : <span 
class="cmmi-10">v</span><sub><span 
class="cmr-7">0</span></sub><span 
class="cmmi-10">,</span><span 
class="cmmi-10">&#x00A0;k</span><sub><span 
class="cmr-7">1</span></sub> : <span 
class="cmmi-10">v</span><sub><span 
class="cmr-7">1</span></sub><span 
class="cmmi-10">,</span><span 
class="cmmi-10">&#x00A0;...</span><span 
class="cmsy-10">} </span>.
The empty dictionary is written as {:}.
If <i>d</i> is a dictionary, and <i>k</i> is a key, then the
following expression retrieves the Harmony value that <i>k</i> maps to in <i>d</i>:
<center><i>d</i> <i>k</i>
</center>
The meaning of <i>d</i> <var>a</var> <i>b</i>  <span 
class="cmmi-10">...</span>
 is (((<i>d</i> <var>a</var>) <i>b</i>)  <span 
class="cmmi-10">... </span>).
This notation is unfamiliar to Python programmers,
but in Harmony square brackets can be used
in the same way as parentheses, so you can express the same thing in the form
that is familiar to Python programmers:
<center><i>d</i>[<i>k</i>]
</center>
However, if <i>d</i> = { .<i>count</i>: 3 }, then you can write
<i>d.count</i>
(which has value 3) instead of having to write
<i>d</i>[.<i>count</i>] or <i>d</i>["count"] (although any of those
will work).
Thus a dictionary can be made to look much like a Python object.<p>In Harmony (unlike Python), lists and tuples are the same type.
As in Python, you can create a singleton tuple (or list) by including a comma.
For example, (1,) is a tuple consisting just of the number 1.
Importantly,  (1) = 1<span 
class="cmmi-10">&#x2260;</span>(1<span 
class="cmmi-10">,</span>) .
Because, square brackets and parentheses work the same in Harmony,
[<var>a</var>, <i>b</i>, <i>c</i>] (which looks like a Python list)
is the same Harmony value as (<var>a</var>, <i>b</i>, <i>c</i>) (which looks like a Python tuple).
So, if <i>x</i> = [<b>False</b>, <b>True</b>],
then <i>x</i>[0] = <b>False</b> and <i>x</i>[1] = <b>True</b>, just like in Python.
However, when creating a singleton list, make sure you include the
comma, as in [<b>False</b>,].  The expression [<b>False</b>] just means <b>False</b>.<p>Harmony is not an object-oriented language, so objects don't have
built-in methods.  However, Harmony does have some powerful operators to
make up for some of that.
For example, dictionaries have two handy unary operators.
If <i>d</i> is a
dictionary, then <b>keys</b> <i>d</i> (or equivalently <b>keys</b>(<i>d</i>))
returns the set of keys and <b>len</b> <i>d</i> returns the size of
this set.<p><a href='#sec-236'>Section A.1</a> provides details on all the types of values that
Harmony currently supports.
</div>

<div id='sec-30'>
<h2 id="sec-30">Harmony Bytecode</h2><p>A Harmony program is translated into HVM bytecode.
To make it amenable to efficient model checking,
the HVM is not an ordinary virtual machine, but its architecture
is nonetheless representative of conventional computers and
virtual machines such as the Java Virtual Machine.<p><a id="index:register:1"></a>
<a id="gls:context:1"></a>
<a id="index:thread-local:1"></a>
Instead of bits and bytes, a HVM manipulates Harmony values.
A HVM has the following components:
<ul><li> Code:  This is an immutable and finite list of HVM instructions,
generated from a Harmony program.  The types of instructions will be described later.
<li> Shared memory: A HVM has just one memory location containing
a Harmony value.
<li> Threads:  Any thread
can spawn an unbounded number of other threads and threads may terminate.
Each thread has a program counter that indexes into the code,
<a id="index:program-counter:1"></a>
a stack of Harmony values,
and a private <i>register</i> that contains a
Harmony value.[footnote: 
Currently, another thread register
contains thread-local data.  We do not use it (yet) in this book.]

</ul>

The register of a thread contains the local variables of the
method that the thread is currently executing.  It is saved and restored by
method invocations.
The state of a thread is called a <i>context</i> (aka <i>continuation</i>):
<a id="index:context:1"></a>
<a id="index:continuation:1"></a>
it contains the values of its program counter, stack, and registers.
The HVM state
consists of the value of its memory and the multiset (or <i>bag</i>)
<a id="index:bag:1"></a>
<a id="index:multiset:1"></a>
of contexts.  It is a multiset of contexts because two threads can
have the same context at the same time.<p><div id='sec-31'>
<center><pre><code class="language-none">   0 Frame __init__ ()
code/Up.hny:1 count = 0
   1 Push 0
   2 Store count
code/Up.hny:2 done = [ False, False ]
   3 Push [False, False]
   4 Store done
code/Up.hny:4 def incrementer(self):
   5 Jump 35
   6 Frame incrementer self
code/Up.hny:5     count = count + 1
   7 Load count
   8 Push 1
   9 2-ary +
   10 Store count
</code></pre>
</center>
<h4>Figure 4.1. The first part of the HVM bytecode corresponding to <a href='#sec-19'>Figure 3.3</a></h4>


</div>

It may seem strange that there is only one memory location.
However, this is not a limitation because Harmony values are unbounded trees.
The shared memory is a dictionary that maps strings (names of shared
variables) to other Harmony values.
We call this a <i>directory</i>.
<a id="index:directory:1"></a>
Thus, a directory represents the state of a collection of variables named
by the strings.
Because directories are Harmony values themselves and Harmony values
include dictionaries and lists that themselves contain other Harmony
values,
directories can be organized into a tree.
Each node in a directory tree is then identified
by a sequence of Harmony values, like a path name in the file system
hierarchy.  We call such a sequence an <i>address</i>.
<a id="index:address:1"></a>
For example, in <a href='#sec-19'>Figure 3.3</a> the memory is a dictionary with two
entries: .<i>count</i> and <i>done</i>.  And the value of entry
<i>done</i> is a list with indexes 0 and 1.
So, for example, the address of <i>done</i>[0] is the sequence [<i>done</i>, 0].
An address is itself a Harmony value.<p><a id="gls:stack-machine:1"></a><p>Compiling the code in <a href='#sec-19'>Figure 3.3</a> results in the HVM bytecode
listed in <a href='#sec-31'>Figure 4.1</a>.
You can obtain this code by invoking <code>harmony</code> with the <code>-a</code> flag
like so:
<center><pre><code class="language-none">harmony -a Up.hny
</code></pre>
</center>
Each thread in the HVM is predominantly a <i>stack machine</i>,
<a id="index:stack-machine:1"></a>
but it also a register.
Like shared memory, the register contains a dictionary so it
can represent the values of multiple named variables.
<a id="index:sequential-consistency:1"></a>
All instructions are atomically executed.
The Harmony memory model is <i>sequentially consistent</i>: all
accesses are in program order.
Most instructions pop values from the stack or push values onto the stack.
At first there is one thread, named <code>__init__</code>,
which initializes the state.
It starts executing at instruction 0 and keeps executing until
it reaches the last instruction in the program.
In this case, it executes instructions 0 through 5 first.
The last instruction in that sequence is a <code>JUMP</code>
instruction that sets the program counter to 35
(skipping over the code for <var>incrementer</var> method).
The <code>__init__</code> thread then executes the
remaining instructions and finishes.
Once initialization completes, any threads that were spawned
(in this case <var>incrementer</var>(0) and <code>incrementer(1)</code>)
can run.<p>At program counter 6 is the code for the <var>incrementer</var> method.
All methods start with a <code>Frame</code> instruction and end with a
<code>Return</code> instruction.
<a href='#sec-296'>Section C.1</a> provides a list of all HVM machine instructions,
in case you want to read about the details.
The <code>Frame</code> instruction lists the name of the method and the
names of its arguments.
The code generated from  <span 
class="cmti-10">count</span> := <span 
class="cmti-10">count</span> + 1  in Line 5 of
<code>Up.hny</code> is as follows (see <a href='#sec-31'>Figure 4.1</a>):<p><ol start="7"><li> The <code>Load</code> instruction pushes the value of the
<i>count</i> variable onto the stack.
<li> The <code>Push</code> instruction pushes the constant 1
onto the stack of the thread.
<li> <code>2-ary</code> is a <code>+</code> operation with 2 arguments.
It pops two values from the stack (the value of <i>count</i> and 1),
adds them, and pushes the result back onto the stack.
<li> The <code>Store</code> instruction pops
a Harmony value (the sum of the <i>count</i> variable and 1) and
stores it in the <i>count</i> variable.
</ol>
</div>

You can think of Harmony as trying every possible interleaving of threads executing
instructions.
Harmony can report the following failure types:
<ul><li> <code>Safety violation</code>: This means something went wrong with
at least one of the executions of the program that it tried.  This
can include a failing assertion, behavior violations, divide by zero,
using an uninitialized
or non-existent variable, dividing a set by an integer, and so on.
Harmony will print a trace of the shortest bad execution that it found.
<li> <code>Non-terminating State</code>: Harmony found one or more states
from which there does not exist an execution such that all threads
terminate.  Harmony will not only print the non-terminating state with
the shortest trace, but also the list of threads
at that state, along with their program counters.
<li> <code>Behavior Violation</code>:  The program can terminate in a state
not allowed by the behavioral specification (<a href='#sec-95'>Chapter 13</a>).
<li> <code>Active Busy Waiting</code>:  There are states in which
some thread cannot make progress without the help of another thread,
but does not block (<a href='#sec-109'>Chapter 15</a>).
<li> <code>Data Race</code>: There are states in which two or more threads
concurrently access a shared variable, at least one of which is a store
operation (<a href='#sec-67'>Chapter 10</a>).
</ul>

Harmony checks for these types of failure conditions in the given
order: if there are multiple failure conditions, only the first is
reported.
<i>Active busy waiting</i> (<a href='#sec-109'>Chapter 15</a>) is not
technically an indication of a synchronization problem, but instead an
indication of an inefficient solution to a synchronization problem---
one that uses up CPU cycles unnecessarily.
A <i>data race</i> may not be a bug either---whether or
not it is might depend on the semantics of the underlying memory
operations and are therefore generally undesirable.
Harmony may also warn about behaviors, in particular if the generated
behavior is only a subset of the provided behavior.<p><div id='sec-32'>
<center><img src="figures/Up0.png" width="90%"></img>
</center>
<h4>Figure 4.2. The
<a href="https://harmony.cs.cornell.edu/output/Up.html">HTML output</a>
of running Harmony on <a href='#sec-19'>Figure 3.3</a></h4>


</div>

Harmony generates a detailed and self-explanatory text output file
(see <code>code/Up.hvb</code>) and
an interactive HTML file that allows exploring more details
of the execution.
Open the suggested HTML file and you should see something like
<a href='#sec-32'>Figure 4.2</a>.<p>In the top right, the HTML file contains the reported issue in red.
Underneath it, a table shows the four turns in the execution.
Instead of listing explicitly the program counters of the executed
instructions, the HTML file contains a list of blocks for each
executed instruction.  We call this the <i>timeline</i>.
You can click on such a block to see the state of the Harmony
virtual machine just after executing the corresponding instruction.
If a thread has finished its turn, there is also information on the
status of that thread.  For example, at the end of turn 2,
<var>incrementer</var>[0] is about to store the value 1 in variable <i>count</i>,
but at that point is preempted by <var>incrementer</var>[1].
The table also lists the program counter of the thread at each turn,
the values of the shared variables, and any values the thread
may have printed (none in this case).
Underneath the table it shows the line of Harmony source code that is being
executed in blue (with the specific part of the line that is being evaluated
in green), and the HVM instruction that is about to be executed in
green (along with an explanation in parentheses).<p>The bottom left shows
the bytecode of the program being executed.  It has alternating
grey and white sections.  Each section corresponds to a line of
Harmony code.  The instruction that is about to be executed,
if any, is highlighted in red.  (In this case, the state shown
is a failed state and no instruction will be executed next.)
If you hover the mouse over a machine instruction, it provides a
brief explanation of what the instruction does.<p>The bottom right contains a table with the state of each thread.
Status information for a thread can include:
<ul><li> <code>runnable</code>: the thread is runnable but not
currently running.  In Harmony, threads are interleaved and so
at most one thread is actually running;
<li> <code>running</code>: the thread is currently executing
instructions;
<li> <code>terminated</code>: the thread has completed all its
instructions;
<li> <code>failed</code>: the thread has encountered an error,
such as violating an assertion or divide by zero;
<li> <code>blocked</code>: the thread cannot make progress until
another thread has updated the shared state.  For example, this
occurs when one of the implementers is waiting for the other
to set its <i>done</i> flag;
<li> <code>atomic</code>: the thread is in <i>atomic</i> mode,
not allowing other threads to be scheduled.  This is, for example,
the case when an assertion is being checked;
<li> <code>read-only</code>: the thread is in <i>read-only</i> mode,
not able to modify shared state.  Assertions can execute
arbitrary code including methods, but they are not allowed to
modify the shared state.
</ul>

The stack of each thread is subdivided into two parts: the
<i>stack trace</i> and the <i>stack top</i>.
A stack trace is a list of methods that are being invoked.
In this case, the <var>incrementer</var> method does not invoke any
other methods, and so the list is of length 1.
For each entry in the stack trace, it shows the method name and
arguments, as well as the variables of the method.
The stack top shows the values on the stack beyond the stack trace.<p>When you load the HTML file, it shows the state after executing
the last instruction.
As mentioned above, you can go to any point in the execution by
clicking on one of the blocks in the timeline.
When you do so, the current turn and thread will be highlighted
in green.
There are also various handy keyboard shortcuts:
<table border='0'>
<tr>
<td>
<i>Right arrow</i>:</td>
 <td>
go to the next instruction;</td>


</tr>
<tr>
<td>
<i>Left arrow</i>:</td>
 <td>
go to the previous instruction;</td>


</tr>
<tr>
<td>
<i>Down arrow</i>:</td>
 <td>
go to the next turn;</td>


</tr>
<tr>
<td>
<i>Up arrow</i>:</td>
 <td>
go to the previous turn;</td>


</tr>
<tr>
<td>
<i>Enter (aka Return)</i>:</td>
 <td>
go to the next line of Harmony code;</td>


</tr>
<tr>
<td>
<i>0</i>:</td>
 <td>
go to the initial state.</td>

</tr>
</table>

If you want to see an animation of the entire execution, one instruction
at a time, you can first hit 0 and then hold down the right arrow.
If you want to see it one line of Harmony code at a time, hold down the
enter (aka return) key instead.
If you hold down the down arrow key, the movie will
go by very quickly.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-33"><b>[Ex. 4.1]</b>:  <a href='#sec-35'>Figure 4.3</a> shows an attempt at trying to fix the code of
    <a href='#sec-19'>Figure 3.3</a>.  Run it through Harmony and see what happens.  Based on
    the error output, describe in English what is wrong with the code by describing,
    in broad steps, how running the program can get into a bad state.
<li id="sec-34"><b>[Ex. 4.2]</b>:  What if we moved Line 5 of <a href='#sec-35'>Figure 4.3</a> to after the <b>if</b>
    statement (between Lines 7 and 8)?  Do you think that would work?  Run it through
    Harmony and describe either why it works or why it does not work.
</ul>

<div id='sec-35'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>count</i> = 0

<i>entered</i> = <i>done</i> = [ <b>False</b>, <b>False</b> ]

<b>def</b> <var>incrementer</var>(<i>self</i>):
    <i>entered</i>[<i>self</i>] = <b>True</b>
    <b>if</b> <i>entered</i>[1 - <i>self</i>]:        <i># if the other thread has already started</i>
        <b>await</b> <i>done</i>[1 - <i>self</i>]     <i># wait until it is done</i>
    <i>count</i> = <i>count</i> + 1
    <i>done</i>[<i>self</i>] = <b>True</b>
    <b>await</b> <i>done</i>[1 - <i>self</i>]
    <b>assert</b> <i>count</i> == 2

<b>spawn</b> <var>incrementer</var>(0)
<b>spawn</b> <var>incrementer</var>(1)
</code></pre>

</center>
<h4>Figure 4.3. [<a href='https://harmony.cs.cornell.edu/code/UpEnter.hny'>code/UpEnter.hny</a>] Incorrect attempt at fixing the code of <a href='#sec-19'>Figure 3.3</a></h4>


</div>
</div>

<div id='sec-36'>
<h1>Chapter 5. Critical Sections</h1>

<p><p><div id='sec-37'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>thread</var>():
    <b>while</b> <b>True</b>:
        <i># Critical section is here</i>
        <b>pass</b>
    
<b>spawn</b> <var>thread</var>()
<b>spawn</b> <var>thread</var>()
</code></pre>

</center>
<h4>Figure 5.1. [<a href='https://harmony.cs.cornell.edu/code/csbarebones.hny'>code/csbarebones.hny</a>] Modeling a critical section</h4>


</div>

Hopefully you have started thinking of how to solve the concurrency
problem and you may already have prototyped some solutions.
In this chapter, we will go through a few reasonable but broken attempts.
At the heart of the problem is that we would like make sure that, when
the <i>count</i> variable is being updated, no other thread is
trying to do the same thing.  This is called a <i>critical section</i>
(aka critical region)  [<a href="#cite-EWD35">13</a>, <a href="#cite-Dijkstra65">15</a>, <a href="#cite-EWD123">16</a>]:
a set of instructions where only one thread is allowed to execute at a
time.
<a id="index:critical-section:1"></a>
<a id="index:critical-region:1"></a><p><a id="gls:critical-section:1"></a>
<a id="gls:thread-safety:1"></a><p>Critical sections are useful when accessing a shared data
structure, particularly when that access requires multiple underlying
machine instructions.  A counter is a very simple example of
a data structure (it is an array of bits), but---as we have
seen---incrementing it requires multiple instructions.
A more involved one would be accessing a binary tree.
Adding a node to a binary tree, or re-balancing a tree, often requires
multiple operations.  Maintaining &quot;consistency&quot; is certainly much easier
if during this time no other
thread also tries to access the binary tree.
Typically, you want some invariant property of the data structure to hold
at the beginning and at the end of the critical section, but in the middle
the invariant may be temporarily broken---this is not a problem as critical
sections guarantee that no other
thread will be able to see it.
An implementation of a data structure that can be safely accessed by multiple
threads and is free of race conditions is called <i>thread-safe</i>.
<a id="index:thread-safety:1"></a>
<a id="index:thread:3"></a><p><a id="gls:mutual-exclusion:1"></a><p>A critical section is often modeled as threads in an infinite loop
entering and exiting the critical section.
<a href='#sec-37'>Figure 5.1</a> shows the Harmony code.
We need to ensure is that there can never be two threads in the
critical section.
This property is called <i>mutual exclusion</i>.
<a id="index:mutual-exclusion:1"></a>
Mutual exclusion by itself is easy to ensure.
For example, we could insert the following code to enter the
critical section:
<center><b>await</b> <b>False</b>
</center>
This code will surely prevent two or more threads from executing
in the critical section at the same time.
But it does so by preventing <i>any</i> thread from reaching
the critical section.
We clearly need another property besides mutual exclusion.<p><div id='sec-38'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i># number of threads in the critical section</i>
<i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<b>def</b> <var>thread</var>():
    <b>while</b> <b>choose</b> { <b>False</b>, <b>True</b> }:
        <i># Enter critical section</i>
        <b>atomically</b> <i>in_cs</i> += 1

        <i># Critical section is here</i>
        <b>pass</b>

        <i># Exit critical section</i>
        <b>atomically</b> <i>in_cs</i> -= 1
    
<b>spawn</b> <var>thread</var>()
<b>spawn</b> <var>thread</var>()
</code></pre>

</center>
<h4>Figure 5.2. [<a href='https://harmony.cs.cornell.edu/code/cs.hny'>code/cs.hny</a>] Harmony model of a critical section</h4>


</div>

Mutual exclusion is an example of a <i>safety property</i>,
<a id="index:safety-property:1"></a>
a property that ensures that <i>nothing bad will happen</i>, in this case
two threads being in the critical section.
What we need now is a <i>liveness property</i>:
<a id="index:liveness-property:1"></a>
we want to ensure that
<i>eventually something good will happen</i>.
There are various possible liveness properties we could use,
but here we will propose the following informally: if
(1) there exists a non-empty
set  <span 
class="cmmi-10">S </span> of threads that are trying to enter the critical section and
(2) threads in the critical section always leave eventually, then
eventually one thread in 
<span 
class="cmmi-10">S </span> will enter the critical section.
We call this <i>progress</i>.
<a id="index:progress:1"></a><p>In order to detect violations of progress, and other liveness problems in
algorithms in general, Harmony requires that every execution must be
able to reach a state in which all threads have terminated.
Clearly, even if mutual exclusion holds in <a href='#sec-37'>Figure 5.1</a>,
the spawned threads never terminate.<p>We will instead model threads in critical sections using the framework in
<a href='#sec-38'>Figure 5.2</a>: a thread can <i>choose</i> to enter a
critical section more than once, but it can also choose to terminate, even
without entering the critical section ever.
(Recall that Harmony will try every possible execution, and so it will evaluate
both choices.)
As it turns out, there is an advantage to doing it this way: we can also
test if a thread can enter when there is no other thread trying to enter
the critical section.  As we will see below, this is not always obvious.<p>Moreover, this code specifies that at most one thread can be executing
in the critical section.  It does this using a counter <i>in_cs</i>
that is atomically incremented when entering the critical section
and atomically decremented when leaving the critical section.
The code specifies the invariant that <i>in_cs</i> must be either 0
or 1.  You can think of this as the type of <i>in_cs</i>.<p>We will now consider various approaches toward implementing this
specification.<p><div id='sec-39'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<i>lockTaken</i> = <b>False</b>

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <i># Enter critical section</i>
        <b>await</b> <b>not</b> <i>lockTaken</i>
        <i>lockTaken</i> = <b>True</b>

        <b>atomically</b> <i>in_cs</i> += 1
        <i># Critical section</i>
        <b>atomically</b> <i>in_cs</i> -= 1

        <i># Leave critical section</i>
        <i>lockTaken</i> = <b>False</b>
    
<b>spawn</b> <var>thread</var>(0)
<b>spawn</b> <var>thread</var>(1)
</code></pre>

</center>
<center><p><strong>Summary: something went wrong in an execution</strong></p>

<p>Here is a summary of an execution that exhibits the issue:</p>

<ul>
<li>Schedule thread T0: <strong>init</strong>()
<ul>
<li>Line 1: Initialize in_cs to 0</li>
<li>Line 4: Initialize lockTaken to False</li>
<li><strong>Thread terminated</strong></li>
</ul></li>
<li>Schedule thread T3: thread(1)
<ul>
<li>Line 7: Choose True</li>
<li>Preempted in thread(1)
about to store True into lockTaken in line 10</li>
</ul></li>
<li>Schedule thread T2: thread(0)
<ul>
<li>Line 7: Choose True</li>
<li>Line 10: Set lockTaken to True (was False)</li>
<li>Line 12: Set in_cs to 1 (was 0)</li>
<li>Preempted in thread(0)
about to execute atomic section in line 14</li>
</ul></li>
<li>Schedule thread T3: thread(1)
<ul>
<li>Line 10: Set lockTaken to True (unchanged)</li>
<li>Line 12: Set in_cs to 2 (was 1)</li>
<li>Preempted in thread(1)
about to execute atomic section in line 14</li>
</ul></li>
<li>Schedule thread T1: invariant()
<ul>
<li>Line 2: Harmony assertion failed</li>
</ul></li>
</ul>
</center>
<h4>Figure 5.3. [<a href='https://harmony.cs.cornell.edu/code/naiveLock.hny'>code/naiveLock.hny</a>] Na&iuml;ve implementation of a shared lock and the markdown output of running Harmony</h4>


</div>

<div id='sec-40'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<i>flags</i> = [ <b>False</b>, <b>False</b> ]

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <i># Enter critical section</i>
        <i>flags</i>[<i>self</i>] = <b>True</b>
        <b>await</b> <b>not</b> <i>flags</i>[1 - <i>self</i>]

        <b>atomically</b> <i>in_cs</i> += 1
        <i># Critical section</i>
        <b>atomically</b> <i>in_cs</i> -= 1

        <i># Leave critical section</i>
        <i>flags</i>[<i>self</i>] = <b>False</b>

<b>spawn</b> <var>thread</var>(0)
<b>spawn</b> <var>thread</var>(1)
</code></pre>

</center>
<center><p><strong>Summary: some execution cannot terminate</strong></p>

<p>Here is a summary of an execution that exhibits the issue:</p>

<ul>
<li>Schedule thread T0: <strong>init</strong>()
<ul>
<li>Line 1: Initialize in_cs to 0</li>
<li>Line 4: Initialize flags to [ False, False ]</li>
<li><strong>Thread terminated</strong></li>
</ul></li>
<li>Schedule thread T1: thread(0)
<ul>
<li>Line 7: Choose True</li>
<li>Line 9: Set flags[0] to True (was False)</li>
<li>Preempted in thread(0)
about to load variable flags[1] in line 10</li>
</ul></li>
<li>Schedule thread T2: thread(1)
<ul>
<li>Line 7: Choose True</li>
<li>Line 9: Set flags[1] to True (was False)</li>
<li>Preempted in thread(1)
about to load variable flags[0] in line 10</li>
</ul></li>
</ul>

<hr />

<p><strong>Final state</strong> (all threads have terminated or are blocked):</p>

<ul>
<li>Threads:
<ul>
<li>T1: (blocked) thread(0)
<ul>
<li>about to load variable flags[1] in line 10</li>
</ul></li>
<li>T2: (blocked) thread(1)
<ul>
<li>about to load variable flags[0] in line 10</li>
</ul></li>
</ul></li>
</ul>
</center>
<h4>Figure 5.4. [<a href='https://harmony.cs.cornell.edu/code/naiveFlags.hny'>code/naiveFlags.hny</a>] Na&iuml;ve use of flags to solve mutual exclusion</h4>


</div>

<div id='sec-41'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<i>turn</i> = 0

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <i># Enter critical section</i>
        <i>turn</i> = 1 - <i>self</i>
        <b>await</b> <i>turn</i> == <i>self</i>

        <b>atomically</b> <i>in_cs</i> += 1
        <i># Critical section</i>
        <b>atomically</b> <i>in_cs</i> -= 1

        <i># Leave critical section</i>

<b>spawn</b> <var>thread</var>(0)
<b>spawn</b> <var>thread</var>(1)
</code></pre>

</center>
<center><p><strong>Summary: some execution cannot terminate</strong></p>

<p>Here is a summary of an execution that exhibits the issue:</p>

<ul>
<li>Schedule thread T0: <strong>init</strong>()
<ul>
<li>Line 1: Initialize in_cs to 0</li>
<li>Line 4: Initialize turn to 0</li>
<li><strong>Thread terminated</strong></li>
</ul></li>
<li>Schedule thread T2: thread(1)
<ul>
<li>Line 7: Choose False</li>
<li><strong>Thread terminated</strong></li>
</ul></li>
<li>Schedule thread T1: thread(0)
<ul>
<li>Line 7: Choose True</li>
<li>Line 9: Set turn to 1 (was 0)</li>
<li>Preempted in thread(0)
about to load variable turn in line 10</li>
</ul></li>
</ul>

<hr />

<p><strong>Final state</strong> (all threads have terminated or are blocked):</p>

<ul>
<li>Threads:
<ul>
<li>T1: (blocked) thread(0)
<ul>
<li>about to load variable turn in line 10</li>
</ul></li>
<li>T2: (terminated) thread(1)</li>
</ul></li>
</ul>
</center>
<h4>Figure 5.5. [<a href='https://harmony.cs.cornell.edu/code/naiveTurn.hny'>code/naiveTurn.hny</a>] Na&iuml;ve use of turn variable to solve mutual exclusion</h4>


</div>

<a id="gls:lock:1"></a><p>You may already have heard of the concept of a <i>lock</i>
<a id="index:lock:1"></a>
and have realized that
it could be used to implement a critical section.
The idea is that the lock is like a baton that at most one thread can own
(or hold) at a time.
A thread that wants to enter the critical section at a time must obtain the
lock first and release it upon exiting the critical section.

Using a lock is a good thought, but how does one implement one?
<a href='#sec-39'>Figure 5.3</a> presents an attempt at mutual exclusion based on a
na&iuml;ve (and, as it turns out, incorrect) implementation of a lock.
Initially the lock is not owned, indicated by <i>lockTaken</i> being <b>False</b>.
To enter the critical section, a thread waits until <i>lockTaken</i> is <b>False</b>
and then sets it to <b>True</b> to indicate that the lock has been taken.
The thread then executes the critical section.  Finally, the thread
releases the lock by setting <i>lockTaken</i> back to <b>False</b>.<p>Unfortunately, if we run the program through Harmony, we find that
the assertion fails.  <a href='#sec-39'>Figure 5.3</a> also shows the Harmony
output.  <var>thread</var>(1) finds that the lock is available, but just
before it stores <b>True</b> in <i>lockTaken</i>, <var>thread</var>(0) gets to
run.  (Recall that you can hover your mouse over a machine instruction
in order to see what it does.) Because <i>lockTaken</i> is still
<b>False</b>, it too believes it can acquire the lock, and stores
<b>True</b> in <i>lockTaken</i> and moves on to the critical section.
Finally, <var>thread</var>(1) moves on, also stores <b>True</b> into <i>lockTaken</i>
and also moves into the critical section.
The <i>lockTaken</i> variable suffers from
the same sort of race condition as the <i>count</i> variable in
<a href='#sec-19'>Figure 3.3</a>: testing and setting the lock consists of several
instructions.  It is thus possible for both threads to believe the
lock is available and to obtain the lock at the same time.<p>Preventing multiple threads from updating the same variable,
<a href='#sec-40'>Figure 5.4</a> presents a solution based on each thread having
a flag indicating that it is trying to enter the critical section.
A thread can write its own flag and read the flag of its peer.
After setting its flag, the thread waits until the other thread
( 1 <span 
class="cmsy-10">-</span> <span 
class="cmti-10">self</span>  ) is not trying to enter the critical section.
If we run this program, the assertion does not fail.  In fact, this
solution does prevent both threads being in the critical section at
the same time.<p>To see why, first note the following invariant: if thread <i>i</i> is in the
critical section, then <i>flags</i>[<i>i</i>] = <b>True</b>.
Without loss of generality,
suppose that thread 0 sets <i>flags</i>[0] at time  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">0</span></sub> .
Thread 0 can only reach the critical section if at some time  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">1</span></sub> ,
 <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">1</span></sub> <span 
class="cmmi-10">&#x003E; t</span><sub><span 
class="cmr-7">0</span></sub> , it finds that <i>flags</i>[1] = <b>False</b>.
Because of the invariant, <i>flags</i>[1] = <b>False</b> implies that
thread 1 is not in the critical section at time  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">1</span></sub>
.
Let  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">2</span></sub>  be the time at which thread 0 sets <i>flags</i>[0]
to <b>False</b>.  Thread 0 is in the critical section sometime
between  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">1</span></sub>  and  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">2</span></sub>
.
It is easy to see that thread 1 cannot enter the critical section
between  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">1</span></sub>  and  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">2</span></sub> , because <i>flags</i>[1] = <b>False</b> at
time  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">1</span></sub>
.  To reach the critical section between  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">1</span></sub>  and  <span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">2</span></sub> ,
it would first have to set <i>flags</i>[1] to <b>True</b> and
then wait until <i>flags</i>[0] = <b>False</b>.  But that does not happen
until time 
<span 
class="cmmi-10">t</span><sub><span 
class="cmr-7">2</span></sub> .<p>However, if you run the program through Harmony,
it turns out the solution
does have a problem: if both try to enter the critical section at the same
time, they may end up waiting for one another indefinitely.
(This is a form of <i>deadlock</i>, which will be discussed in
<a href='#sec-146'>Chapter 19</a>.)
Thus the
solution violates <i>progress</i>.<p>The final na&iuml;ve solution that we propose
is based on a variable called <i>turn</i>.
Each thread politely lets the other thread have a turn first.
When <i>turn</i> = <i>i</i>, thread <i>i</i> can
enter the critical section, while thread  1 <span 
class="cmsy-10">- </span><span 
class="cmmi-10">i </span> has to wait.
An invariant of this solution is that while thread <i>i</i> is in the critical
section, <i>turn</i> = <i>i</i>.
Since <i>turn</i> cannot be 0 and 1 at
the same time, mutual exclusion is satisfied.
The solution also has the nice property that the thread that has been waiting the
longest to enter the critical section can go next.<p>Run the program through Harmony.  It turns out that this solution also violates
<i>progress</i>, albeit for a different reason:
if thread <i>i</i> terminates instead of entering the critical section,
thread  1 <span 
class="cmsy-10">- </span><span 
class="cmmi-10">i </span>, politely, ends up waiting indefinitely for its turn.
Too bad, because it would have been a great solution if both
threads try to enter the critical section ad infinitum.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-42"><b>[Ex. 5.1]</b>:  Run <a href='#sec-38'>Figure 5.2</a> using Harmony.  As there is no protection of the critical
section, mutual exclusion is violated,
the assertion should fail, and a trace should be reported.
Now insert
<center><b>await</b> <b>False</b>
</center>
just before entering the critical section
in <a href='#sec-38'>Figure 5.2</a> and run Harmony again.
Mutual exclusion is guaranteed but progress is violated.
Harmony should print a trace
to a state from which a terminating state cannot be reached.
Describe in English the difference in the failure reports before
and after inserting the code.
<li id="sec-43"><b>[Ex. 5.2]</b>:  See if you can come up with some different approaches that satisfy both
mutual exclusion and progress.  Try them with Harmony and see if they work or not.
If they don't, try to understand why.
If you get <i>active busy waiting</i> or <i>data race</i> reports, you probably
found a correct solution; you'll learn later how to suppress those.
Do not despair if you can't figure out how to develop a solution that satisfies both
mutual exclusion and progress---as we will find out, it is possible but not obvious.
</ul>
</div>

<div id='sec-44'>
<h1>Chapter 6. Peterson's Algorithm</h1>


<a id="index:Peterson's-Algorithm:1"></a><p><div id='sec-45'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<b>sequential</b> <i>flags</i>, <i>turn</i>
<i>flags</i> = [ <b>False</b>, <b>False</b> ]
<i>turn</i> = <b>choose</b>({0, 1})

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <i># Enter critical section</i>
        <i>flags</i>[<i>self</i>] = <b>True</b>
        <i>turn</i> = 1 - <i>self</i>
        <b>await</b> (<b>not</b> <i>flags</i>[1 - <i>self</i>]) <b>or</b> (<i>turn</i> == <i>self</i>)

        <b>atomically</b> <i>in_cs</i> += 1
        <i># Critical section</i>
        <b>atomically</b> <i>in_cs</i> -= 1

        <i># Leave critical section</i>
        <i>flags</i>[<i>self</i>] = <b>False</b>

<b>spawn</b> <var>thread</var>(0)
<b>spawn</b> <var>thread</var>(1)
</code></pre>

</center>
<h4>Figure 6.1. [<a href='https://harmony.cs.cornell.edu/code/Peterson.hny'>code/Peterson.hny</a>] Peterson's Algorithm</h4>


</div>

<a id="gls:sequential-consistency:1"></a>
In 1981, Gary L. Peterson came up with a beautiful solution to the mutual exclusion
problem, now known as ``Peterson's Algorithm'' [<a href="#cite-Peterson81">38</a>].
The algorithm is an amalgam of the (incorrect) algorithms in
<a href='#sec-40'>Figure 5.4</a> and <a href='#sec-41'>Figure 5.5</a>, and is presented
in <a href='#sec-45'>Figure 6.1</a>.
(The first line specifies that the <i>flags</i> and <i>turn</i>
variables are assumed to satisfy <i>sequential consistency</i>---it prevents
Harmony from complaining about data races involving these variables,
explained in <a href='#sec-62'>Chapter 9</a>.)<p>A thread first indicates its interest in entering the critical section
by setting its flag.
It then politely gives way to the other thread should it also want to
enter the critical section---if both do so at the same time one will
win because writes to memory in Harmony are atomic.
The thread continues to be polite, waiting
until either the other thread is nowhere near the critical section
(<i>flag</i>[1 - <i>self</i>] = <b>False</b>) or has given way (<i>turn</i> = <i>self</i>).
Running the algorithm with Harmony shows that it satisfies both mutual
exclusion and progress.<p><div id='sec-46'>
<center><img src="figures/states.png" width="80%"></img>
</center>
<h4>Figure 6.2. Venn diagram classifying all states and a trace</h4>


</div>

<a id="gls:state:1"></a>
<a id="gls:thread-variable:1"></a><p>Why does it work?  We will focus here on how one might go about proving
mutual exclusion for an algorithm such as Peterson's.
It turns out that doing so is not easy.
If you are interested in learning more about concurrent programming
but not necessarily in how to prove concurrent programs correct, you
may choose to skip the rest of this chapter.
If you are still here, you have to understand a little bit more about
how the Harmony virtual machine (HVM) works.
In <a href='#sec-28'>Chapter 4</a> we talked about the concept of <i>state</i>:
<a id="index:state:1"></a>
at any point in time the HVM is in a specific state.
A state is comprised of the values of the shared variables as well as
the values of the thread variables
<a id="index:thread-variable:1"></a>
of each thread, including its
program counter and the contents of its stack.
Each time a thread executes a HVM machine instruction, the
state changes (if only because the program counter of the thread
changes).  We call that a <i>step</i>.
<a id="index:step:1"></a>
Steps in Harmony are atomic.<p><a id="gls:step:1"></a>
<a id="gls:trace:1"></a><p>The HVM starts in an initial state in which there is only
one thread (<var>__init__</var>()) and its program counter is 0.
A <i>trace</i>
<a id="index:trace:1"></a>
is a sequence of steps starting from the initial state,
resulting in a sequence of states.
When making a step, there are two sources of non-determinism
<a id="index:non-determinism:1"></a>
in Harmony.
One is when
there is more than one thread that can make a step.  The other is
when a thread executes a <b>choose</b> operation and there is
more than one choice.
Because there is non-determinism, there are multiple possible traces.
We call a state <i>reachable</i>
<a id="index:reachable-state:1"></a>
if it is either the initial state
or it can be reached from the initial state through a finite trace.
A state is final
when there are no threads left to make state changes.<p>It is often useful to classify states.
<i>Initial</i>, <i>final</i>, and <i>reachable</i>, and <i>unreachable</i>
are all examples of classes of states.
<a href='#sec-46'>Figure 6.2</a> depicts a Venn diagram of various classes of states
and a trace.
One way to classify states is to define a predicate over states.
All states in which <i>x</i> = 1, or all states where
there are two or more threads executing, are examples of such predicates.
For our purposes, it is useful to define a predicate that says that at
most one thread is in the critical section.  We shall call such states
<i>exclusive</i>.<p>An <i>invariant</i> of a program
<a id="index:invariant:2"></a>
is a predicate that holds over all states that are reachable by that program.
We want to show that exclusivity is an invariant because mutual exclusion means
that all reachable states are exclusive.
In other words, we want to show that the set of reachable states of executing
the program
is a subset of the set of states where there is at most one thread in the critical
section.<p>One way to prove that a predicate is an invariant is through induction
on the number of steps.  First you prove that the predicate holds over
the initial state.  Then you prove that for every reachable state,
and for every step from that reachable state, the predicate also holds
over the resulting state.
For this to work you would need a predicate that describes exactly which
states are reachable.
But we do not have such a predicate: we know how to define the set
of reachable states inductively, but---given an arbitrary state---it is not
easy to see whether it is reachable or not.<p>To solve this problem, we will use what is called an
<i>inductive invariant</i>.
<a id="index:inductive-invariant:1"></a>
An inductive invariant  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /> </span> is a predicate over states that satisfies the following:
<ul><li>  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /> </span> holds in the initial state.
<li> For any state in which  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /> </span> holds (including unreachable ones) and for any
thread in the state, if the thread takes a step, then  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /> </span> also holds in the
resulting state.
</ul>

One candidate for such a predicate is exclusivity itself.
After all, it certainly holds over the initial state.
And as Harmony has already determined, exclusivity is an invariant:
it holds over every reachable state.
Unfortunately, exclusivity is not an <i>inductive</i> invariant.
To see why, consider the following state <i>s</i>: let thread 0 be at label <i>cs</i>
and thread 1 be at the start of the <b>await</b> statement.
Also, in state <i>s</i>,  <span 
class="cmti-10">turn</span> = 1 .  Now let
thread 1 make a step.  Because 
<span 
class="cmti-10">turn</span> = 1 ,
thread 1 will stop waiting and also enter the critical
section, entering a state that is not exclusive.
So, exclusivity is an invariant (holds over every reachable state, as demonstrated
by Harmony),
but not an inductive invariant.
It will turn out that <i>s</i> is not reachable.<p>We are looking for an inductive invariant that <i>implies</i> exclusivity.
In other words, the set of states where the inductive invariant holds
must be a subset of the set of states where there is at most one thread in
the critical section.<p>Let us begin with considering the following important property:
 <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>) = <span 
class="cmtt-10">thread</span>(<span 
class="cmmi-10">i</span>)@[10<img 
src="mathtmp0x.png" alt="&#x22C5;&#x22C5;&#x22C5;"  class="@cdots" >17] <span 
class="cmsy-10">&#x21D2;</span> <span 
class="cmti-10">flags</span>[<span 
class="cmmi-10">i</span>]
,
that is, if thread <i>i</i> is executing in lines 10 through 17, then  <span 
class="cmti-10">flags</span>[<span 
class="cmmi-10">i</span>] 
is set.
Although it does not, by itself, imply exclusivity, we can show that
 <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  is an inductive invariant (for both threads 0 and 1).
To wit, it holds in the initial state, because in the initial state thread <i>i</i> does
not even exist yet.
Now we have to show that if  <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  holds in some state, then
 <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  also holds in a next state.
Since only thread <i>i</i> ever changes  <span 
class="cmti-10">flags</span>[<span 
class="cmmi-10">i</span>]
, we only need to
consider steps by thread <i>i</i>.
Since  <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  holds, there are two cases to consider:
<ol><li> states in which  <span 
class="cmti-10">flags</span>[<span 
class="cmmi-10">i</span>] = <span 
class="cmtt-10">true</span> 
<li> states in which  <span 
class="cmsy-10">¬</span><span 
class="cmtt-10">thread</span>(<span 
class="cmmi-10">i</span>)@[10<img 
src="mathtmp1x.png" alt="&#x22C5;&#x22C5;&#x22C5;"  class="@cdots" >17] 
(because false implies anything)
</ol>
In each case, we need to show that if thread <i>i</i> takes a step, then
 <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  still holds.
In the first case, there is only one step that thread <i>i</i> can take that would
set  <span 
class="cmti-10">flags</span>[<span 
class="cmmi-10">i</span>]  to false: the step from line 17 to line 18.  But executing the line
would also take the thread out of lines  10<img 
src="mathtmp2x.png" alt="&#x22C5;&#x22C5;&#x22C5;"  class="@cdots" >17 , so  <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)
 continues to hold.
In the second case (thread <i>i</i> is not executing in lines  10<img 
src="mathtmp3x.png" alt="&#x22C5;&#x22C5;&#x22C5;"  class="@cdots" >17 ), the only step
that would cause thread <i>i</i> to execute in lines  10<img 
src="mathtmp4x.png" alt="&#x22C5;&#x22C5;&#x22C5;"  class="@cdots" >17  would be the step in line 9.
But in that case  <span 
class="cmti-10">flags</span>[<span 
class="cmmi-10">i</span>]  would end up being true, so
 <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  continues to hold as well.
So,  <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)
 is an inductive invariant (for both threads 0 and 1).<p>While  <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  does not imply mutual exclusion, it does imply the following useful
invariant:  <span 
class="cmtt-10">thread</span>(<span 
class="cmmi-10">i</span>)@<span 
class="cmmi-10">cs </span><span 
class="cmsy-10">&#x21D2;</span> <span 
class="cmti-10">flags</span>[<span 
class="cmmi-10">i</span>]
: when thread <i>i</i> is
at the critical section,  <span 
class="cmti-10">flags</span>[<span 
class="cmmi-10">i</span>]  is set.  This seems obvious from the code,
but now you know how to prove it.
We will use a similar technique to prove the exclusivity is invariant.<p>We need a stronger inductive invariant than  <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  to prove mutual exclusion.
What else do we know when thread <i>i</i> is in the critical section?
Let  <span 
class="cmsy-10"><img 
src="cmsy10-43.png" alt="C" class="10x-x-43" /></span>(<span 
class="cmmi-10">i</span>) = <span 
class="cmsy-10">¬</span><span 
class="cmti-10">flags</span>[1 <span 
class="cmsy-10">- </span><span 
class="cmmi-10">i</span>] <span 
class="cmsy-10">&#x2228;</span> <span 
class="cmti-10">turn</span> = <span 
class="cmmi-10">i </span>, that is,
the condition on the <b>await</b> statement for thread <i>i</i>.
In a sequential program,  <span 
class="cmsy-10"><img 
src="cmsy10-43.png" alt="C" class="10x-x-43" /></span>(<span 
class="cmmi-10">i</span>)
 would clearly hold if thread <i>i</i> is in
the critical section:  <span 
class="cmtt-10">thread</span>(<span 
class="cmmi-10">i</span>)@<span 
class="cmmi-10">cs </span><span 
class="cmsy-10">&#x21D2;<img 
src="cmsy10-43.png" alt="C" class="10x-x-43" /></span>(<span 
class="cmmi-10">i</span>) .
However, because thread  1 <span 
class="cmsy-10">- </span><span 
class="cmmi-10">i</span>
 is executing concurrently, this property does not
hold.
You can use Harmony to verify this.  Just place the following command
in the critical section of the program:<p><center><b>assert</b> (<b>not</b> <i>flags</i>[1 - <i>self</i>]) <b>or</b> (<i>turn</i> == <i>self</i>)
</center>


When running Harmony, this assertion will fail.
You can check the HTML output to see what happened.
Suppose thread 0 is at the critical section,  <span 
class="cmti-10">flags</span>[0]  = true,
 <span 
class="cmti-10">turn</span> = 1 , and thread 1 just finished the step in line 7,
setting  <span 
class="cmti-10">flags</span>[1]  to true.  Then  <span 
class="cmmi-10">C</span>(0)  is violated.
But it suggests a new property:

<span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(<span 
class="cmmi-10">i</span>) = <span 
class="cmtt-10">thread</span>(<span 
class="cmmi-10">i</span>)@<span 
class="cmtt-10">cs</span> <span 
class="cmsy-10">&#x21D2;<img 
src="cmsy10-43.png" alt="C" class="10x-x-43" /></span>(<span 
class="cmmi-10">i</span>) <span 
class="cmsy-10">&#x2228;</span><span 
class="cmtt-10">thread</span>(1 <span 
class="cmsy-10">- </span><span 
class="cmmi-10">i</span>)@12 .
That is, if thread <i>i</i> is at the critical section, then
either  <span 
class="cmsy-10"><img 
src="cmsy10-43.png" alt="C" class="10x-x-43" /></span>(<span 
class="cmmi-10">i</span>)
 holds or thread  1 <span 
class="cmsy-10">- </span><span 
class="cmmi-10">i </span> is about to execute line 12.<p>
 <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(<span 
class="cmmi-10">i</span>)  is an invariant for 
<span 
class="cmmi-10">i </span>= 0<span 
class="cmmi-10">,</span>1 .
Moreover, if  <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /></span>(<span 
class="cmmi-10">i</span>)  and  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(<span 
class="cmmi-10">i</span>)  both hold for  <span 
class="cmmi-10">i </span>= 0<span 
class="cmmi-10">,</span>1 ,
then mutual exclusion holds.  We can show this using proof by
contradiction.  Suppose mutual exclusion is violated and thus both threads are in
the critical section.  By  <span 
class="cmsy-10"><img 
src="cmsy10-46.png" alt="F" class="10x-x-46" /> </span> it must be the case that both
<i>flags</i> are true.  By  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /> </span> and the fact that neither thread
is about to execute Line 12, we know that both  <span 
class="cmmi-10">C</span>(0)  and  <span 
class="cmmi-10">C</span>(1)  must hold.
This then implies that 
<span 
class="cmti-10">turn</span> = 0 <span 
class="cmsy-10">&#x2227;</span> <span 
class="cmti-10">turn</span> = 1 , providing
the desired contradiction.<p>We claim that  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(<span 
class="cmmi-10">i</span>)  is an inductive invariant.
First, since neither thread in in the critical section in the initial state,
it is clear that  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(<span 
class="cmmi-10">i</span>)
 holds in the initial state.
Without loss of generality, suppose  <span 
class="cmmi-10">i </span>= 0  (a benefit from the fact that the algorithm is
symmetric for both threads).  We still have to show that if we are in a state
in which  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(0)  holds, then any step will result in a
state in which 
<span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(0)  still holds.<p>First consider the case that thread 0 is at label <i>cs</i>.  If thread 0
were to take a step, then in the next state thread 0 would be no longer
at that label and  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(0)  would hold trivially over the next state.
Therefore we only need to consider a step by thread 1.
From  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /> </span> we know that one of the following three cases must hold before
thread 1 takes a step:
<ol><li> <i>flags</i>[1] = <b>False</b>;
<li> <i>turn</i> = 0;
<li> thread 1 is about to execute Line 12.
</ol>

Let us consider each of these cases.
We have to show that if thread 1 takes a step, then one of those
cases must hold after the step.
In the first case, if thread 1 takes a step, there are two possibilities:
either  <span 
class="cmmi-10">flags</span>[1]  will still be <b>False</b> (in which case the first case
continues to hold), or  <span 
class="cmmi-10">flags</span>[1]  will be <b>True</b>
and thread 1 will be about to execute Line 12 (in which case the third case
will hold).
We know that thread 1 never sets <i>turn</i> to 1, so
if the second case holds before the step, it will also hold after the step.
Finally, if thread 1 is about to execute Line 12 before the step, then after
the step <i>turn</i> will equal 0, and therefore the second case will hold
after the step.<p>Now consider the case where thread 0 is not in the critical section,
and therefore 
<span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(0)  holds trivially because false implies
anything.
There are three cases to consider:
<ol><li> Thread 1 takes a step.  But then thread 0 is still not in the critical
section and  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(0)  continues to hold;
<li> Thread 0 takes a step but still is not in the critical section.
Then again  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(0)  continues to hold.
<li> Thread 0 takes a step and ends up in the critical section.
Because thread 0 entered the critical section, we know that
<i>flags</i>}[1] = <b>False</b> <b>or</b> <i>turn</i> = 0 because
of the <code>await</code> condition.
And hence  <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>(0)  continues to hold in that case as well.
</ol>

We have now demonstrated mutual exclusion in Peterson's Algorithm in two
different ways: one by letting Harmony explore all possible executions, the
other using inductive invariants and proof by induction.  The former
is certainly easier, but it does not provide intuition for why the
algorithm works.  The second provides much more insight.<p>Even though they are not strictly necessary, we encourage you
to include invariants in your Harmony code.
They can provide important insights into why the code works.<p>A cool anecdote is the following.  When the author of Harmony had to teach
Peterson's Algorithm, he refreshed his memory by looking at the Wikipedia
page.  The page claimed that the following predicate is invariant:
if thread <i>i</i> is in the critical section, then  <span 
class="cmsy-10"><img 
src="cmsy10-43.png" alt="C" class="10x-x-43" /></span>(<span 
class="cmmi-10">i</span>)  (i.e.,
 <span 
class="cmsy-10"><img 
src="cmsy10-47.png" alt="G" class="10x-x-47" /></span>
 without the disjunct that thread  1 <span 
class="cmsy-10">- </span><span 
class="cmmi-10">i </span> is about to execute Line 12.
We already saw that this is not an invariant.
(The author fixed the Wikipedia page with the help of Fred B. Schneider.)<p>This anecdote suggests the following.  If you need to do a proof by induction
of an algorithm, you have to come up with an inductive invariant.
Before trying to prove the algorithm, you can check that the predicate is
at least invariant by testing it using Harmony.  Doing so could potentially
avoid wasting your time on a proof that will not work because the
predicate is not invariant, and therefore not an inductive invariant either.
Moreover, analyzing the counterexample provided by Harmony may well
suggest how to fix the predicate.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-47"><b>[Ex. 6.1]</b>:  <a href='#sec-52'>Figure 6.3</a> presents another solution to the
mutual exclusion problem.  It is similar to the one in
<a href='#sec-40'>Figure 5.4</a>, but has a thread <i>back out and try again</i>
if it finds that the other thread is either trying to enter the critical
section or already has.  Compare this algorithm with Peterson's.
Why does Harmony complain about <i>active busy waiting</i>?
Does the algorithm <i>guarantee</i> that at least one thread can enter the
critical section?
<li id="sec-48"><b>[Ex. 6.2]</b>:   Can you find one or more inductive invariants for the algorithm in
<a href='#sec-52'>Figure 6.3</a> to prove it correct?
Here's a pseudo-code version of the algorithm to help you.  Each line
is an atomic action:
<center><pre><code class="language-none">    initially: flagX = flagY = False

    thread X:                          thread Y:
        X0: flagX = True                   Y0: flagY = True
        X1: if not flagY goto X4           Y1: if not flagX goto Y4
        X2: flagX = False                  Y2: flagY = False
        X3: goto X0                        Y3: goto Y0
        X4: ...critical section...         Y4: ...critical section...
        X5: flagX = False                  Y5: flagY = False
</code></pre>
</center>
<li id="sec-49"><b>[Ex. 6.3]</b>:  
A colleague of the author asked if the first two assignments in
Peterson's algorithm (setting <i>flags</i>[<i>self</i>]
to <b>True</b> and <i>turn</i> to 1 - <i>self</i> can be reversed.
After all, they are different variables assigned independent values---in a
sequential program one could surely swap the two assignments.
See if you can figure out for yourself if the two assignments can be
reversed.  Then run the program in <a href='#sec-45'>Figure 6.1</a> after reversing
the two assignments and describe in English what happens.
<li id="sec-50"><b>[Ex. 6.4]</b>:  Bonus question:
Can you generalize Peterson's algorithm to more than two threads?
<li id="sec-51"><b>[Ex. 6.5]</b>:  Bonus question:
Implement
<a href="https://en.wikipedia.org/wiki/Dekker's_algorithm">Dekker's Algorithm</a>,
Dijkstra's Algorthm  [<a href="#cite-Dijkstra65">15</a>],
<a href="https://en.wikipedia.org/wiki/Eisenberg_&_McGuire_algorithm">Eisenstein and McGuire's Algorithm</a>,
<a href="https://en.wikipedia.org/wiki/Szymanski's_algorithm">Szyma&nacute;ski's Algorithm</a>, or
<a href="https://en.wikipedia.org/wiki/Lamport's_bakery_algorithm">Lamport's Bakery Algorithm</a>.
Note that the last one uses unbounded state, so you should modify the threads so they
only try to enter the critical section a bounded number of times.
</ul>

<div id='sec-52'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<b>sequential</b> <i>flags</i>
<i>flags</i> = [ <b>False</b>, <b>False</b> ]

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <i># Enter critical section</i>
        <i>flags</i>[<i>self</i>] = <b>True</b>
        <b>while</b> <i>flags</i>[1 - <i>self</i>]:
            <i>flags</i>[<i>self</i>] = <b>False</b>
            <i>flags</i>[<i>self</i>] = <b>True</b>
        
        <b>atomically</b> <i>in_cs</i> += 1
        <i># Critical section</i>
        <b>atomically</b> <i>in_cs</i> -= 1

        <i># Leave critical section</i>
        <i>flags</i>[<i>self</i>] = <b>False</b>

<b>spawn</b> <var>thread</var>(0)
<b>spawn</b> <var>thread</var>(1)
</code></pre>

</center>
<h4>Figure 6.3. [<a href='https://harmony.cs.cornell.edu/code/csonebit.hny'>code/csonebit.hny</a>] Mutual exclusion using a flag per thread</h4>


</div>
</div>

<div id='sec-53'>
<h1>Chapter 7. Harmony Methods and Pointers</h1>


<a id="index:Harmony-method:1"></a><p>A method <i>m</i> with argument <var>a</var> is invoked in its
most basic form as follows (assigning the result to <i>r</i>).
<center><i>r</i> = <i>m</i> <var>a</var>
</center>
That's right, no parentheses are required.  In fact, if you invoke
<i>m</i>(<var>a</var>), the argument is (<var>a</var>), which is the same
as <var>a</var>.
If you invoke <i>m</i>(), the argument is (),
which is the empty tuple.
If you invoke <i>m</i>(<var>a</var>, <i>b</i>), the argument is (<var>a</var>, <i>b</i>),
the tuple consisting of values <var>a</var> and <i>b</i>.<p>You may note that all this looks familiar.  Indeed, the syntax
is the same as that for dictionaries and lists
(see <a href='#sec-28'>Chapter 4</a>).
Dictionaries, lists, and methods all map Harmony values to Harmony
values, and their syntax is indistinguishable.
If <var>f</var> is a method, list, or dictionary,
and <i>x</i> is some Harmony value, then
<var>f</var> <i>x</i>, <var>f</var>(<i>x</i>), and <var>f</var>[<i>x</i>] are all the same expression in Harmony.<p>


<p><div id='sec-54'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>P_enter</var>(<i>pm</i>, <i>pid</i>):
    <i>pm</i>-&gt;<i>flags</i>[<i>pid</i>] = <b>True</b>
    <i>pm</i>-&gt;<i>turn</i> = 1 - <i>pid</i>
    <b>await</b> (<b>not</b> <i>pm</i>-&gt;<i>flags</i>[1 - <i>pid</i>]) <b>or</b> (<i>pm</i>-&gt;<i>turn</i> == <i>pid</i>)

<b>def</b> <var>P_exit</var>(<i>pm</i>, <i>pid</i>):
    <i>pm</i>-&gt;<i>flags</i>[<i>pid</i>] = <b>False</b>

<b>def</b> <var>P_mutex</var>() <b>returns</b> <i>result</i>:
    <i>result</i> = { .<i>turn</i>: <b>choose</b>({0, 1}), .<i>flags</i>: [ <b>False</b>, <b>False</b> ] }

<i>#### The code above can go into its own Harmony module ####</i>

<i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<b>sequential</b> <i>mutex</i>
<i>mutex</i> = <var>P_mutex</var>()

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <var>P_enter</var>(?<i>mutex</i>, <i>self</i>)

        <b>atomically</b> <i>in_cs</i> += 1
        <i># Critical section</i>
        <b>atomically</b> <i>in_cs</i> -= 1

        <var>P_exit</var>(?<i>mutex</i>, <i>self</i>)

<b>spawn</b> <var>thread</var>(0)
<b>spawn</b> <var>thread</var>(1)
</code></pre>

</center>
<h4>Figure 7.1. [<a href='https://harmony.cs.cornell.edu/code/PetersonMethod.hny'>code/PetersonMethod.hny</a>] Peterson's Algorithm accessed through methods</h4>


</div>

Harmony does not have a <b>return</b> statement.
Using the <b>returns</b> clause of <b>def</b>, a result variable can be declared,
for example: <b>def</b> <var>f</var>() <b>returns</b> <i>something</i>.  The result of the method
should be assigned to variable <i>something</i>.
If there is no <b>returns</b> clause, then (for backwards compatibility reasons)
the method has a default result variable called <i>result</i>.  The default
value of <i>result</i> is <b>None</b> for compatibility with Python.<p>Harmony also does not support
<b>break</b> or <b>continue</b> statements in loops.  One reason for their absence is
that, particularly in concurrent programming, such control flow directions are highly
error-prone.  It's too easy to forget to, say, release a lock when returning a value in the
middle of a method---a major source of bugs in practice.<p>Harmony is not an object-oriented language like Python is.  In Python,
you can pass a reference to an object to a method, and that method
can then update the object.  In Harmony, it is also sometimes convenient
to have a method update a shared variable specified as an argument.
For this, as mentioned in <a href='#sec-28'>Chapter 4</a>,
each shared variable has an <i>address</i>, itself a Harmony value.
<a id="index:address:2"></a>
If <i>x</i> is a shared variable, then the expression ?<i>x</i> is the address of <i>x</i>.
If a variable contains an address, we call that variable a <i>pointer</i>.
<a id="index:pointer:1"></a>
If <i>p</i> is a pointer to a shared variable, then the
expression !<i>p</i> is the value of the shared variable.
In particular, !?<i>x</i> = <i>x</i>.
This is similar to how C pointers work (<code>*&</code><i>x</i> = <i>x</i>).<p>Often, pointers point to dictionaries, and so if <i>p</i> is such a pointer,
then (!<i>p</i>).<i>field</i> would evaluate to the specified field in the dictionary.
Note that the parentheses in this expression
are needed, as !<i>p.field</i> would wrongly evaluate
!(<i>p.field</i>).
(!<i>p</i>).<i>field</i> is such a common expression that, like C, Harmony supports the
shorthand <i>p</i>-&gt;<i>field</i>, which greatly improves readability.<p><a href='#sec-54'>Figure 7.1</a> again shows Peterson's algorithm,
but this time with methods defined to enter and exit the critical
section.
The name <i>mutex</i> is often used to denote a variable or value
that is used for mutual exclusion.
<code>P_mutex</code> is a method that returns a &quot;mutex,&quot; which, in this
case, is a dictionary that contains Peterson's Algorithm's shared memory state:
a turn variable and two flags.
Both methods <var>P_enter</var> and <var>P_exit</var> take two arguments:
a pointer to a mutex and the thread identifier (0 or 1).
<i>pm</i>-&gt;<i>turn</i> is the value of the .<i>turn</i> key
in the dictionary that <i>pm</i> points to. <p>You can put the first three methods in its own Harmony source file
and include it using the Harmony <b>import</b> statement.
<a id="index:import-statement:1"></a>
<a id="index:module:1"></a>
This would make the code usable by multiple applications.<p>Finally, methods can have local variables.
Method variables are either mutable (writable) or immutable (read-only).
The arguments to a method and the bound variable (or
variables) within a <b>for</b> statement are immutable;
the result variable is mutable.
Using the <b>var</b> statement, new mutable local variables can be
declared.
For example, <b>var</b> <i>x</i> = 3 declares a new mutable local variable
<i>x</i>.
The <b>let</b> statement allows declaring new immutable local variables.
For example:
<b>let</b> <i>x</i> = 3: <i>y</i> += <i>x</i> adds 3 to the global variable <i>y</i>.
See <a href='#sec-275'>Section A.4</a> for more information.<p>

<div id='sec-55'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>current</i> = [ [1, 2, 3], [], [] ]

<b>while</b> <i>current</i>[2] != [1, 2, 3]:
    <b>let</b> <i>moves</i> = { (<i>s</i>, <i>d</i>) <b>for</b> <i>s</i> <b>in</b> {0..2} <b>for</b> <i>d</i> <b>in</b> {0..2}
        <b>where</b> <i>current</i>[<i>s</i>] != []
        <b>where</b> (<i>current</i>[<i>d</i>] == []) <b>or</b> (<i>current</i>[<i>s</i>][0] &lt; <i>current</i>[<i>d</i>][0]) }
    <b>let</b> (<i>src</i>,<i>dst</i>) = <b>choose</b> <i>moves</i>:
        <b>print</b> <b>str</b>(<i>src</i>) + " -> " + <b>str</b>(<i>dst</i>)
        <i>current</i>[<i>dst</i>] = [<i>current</i>[<i>src</i>][0],] + <i>current</i>[<i>dst</i>]
        <b>del</b> <i>current</i>[<i>src</i>][0]

<b>assert</b> <b>False</b>
</code></pre>

</center>
<h4>Figure 7.2. [<a href='https://harmony.cs.cornell.edu/code/hanoi.hny'>code/hanoi.hny</a>] Towers of Hanoi</h4>


</div>

As an example of using <b>let</b>,
<a href='#sec-55'>Figure 7.2</a> solves the <i>Towers of Hanoi</i> problem.
If you are not familiar with this problem:
there are three towers with disks of varying sizes.
In the initial configuration, the first tower has three disks (of
sizes 1, 2, and 3), with the largest disk at the bottom, while the
other two towers are empty.  You are allowed to move a top disk
from one tower to another, but you are not allowed to stack a larger
disk on a smaller one.  The objective is to move the disks from the
first tower to the third one.
The program tries valid moves at random until it finds a solution.
Curiously, the program then asserts <b>False</b>.  This is to cause
the model checker to stop and output the trace.  If you look in the
output column of the trace, you will find the minimal number of moves
necessary to solve the problem.<p>It is even cooler to remove that assertion and let Harmony generate
all possible solutions to the problem.<p>

<div id='sec-56'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>FIFO</var> = <b>False</b>

<b>def</b> <var>CLOCK</var>(<i>n</i>) <b>returns</b> <i>result</i>:
    <i>result</i> = { .<i>entries</i>: [<b>None</b>,] * <i>n</i>, .<i>recent</i>: {}, .<i>hand</i>: 0, .<i>misses</i>: 0 }

<b>def</b> <var>ref</var>(<i>clock</i>, <i>x</i>):
    <b>if</b> <i>x</i> <b>not</b> <b>in</b> <i>clock</i>-&gt;<i>entries</i>:
        <b>while</b> <i>clock</i>-&gt;<i>entries</i>[<i>clock</i>-&gt;<i>hand</i>] <b>in</b> <i>clock</i>-&gt;<i>recent</i>:
            <i>clock</i>-&gt;<i>recent</i> -= {<i>clock</i>-&gt;<i>entries</i>[<i>clock</i>-&gt;<i>hand</i>]}
            <i>clock</i>-&gt;<i>hand</i> = (<i>clock</i>-&gt;<i>hand</i> + 1) % <b>len</b>(<i>clock</i>-&gt;<i>entries</i>)
        <i>clock</i>-&gt;<i>entries</i>[<i>clock</i>-&gt;<i>hand</i>] = <i>x</i>
        <i>clock</i>-&gt;<i>hand</i> = (<i>clock</i>-&gt;<i>hand</i> + 1) % <b>len</b>(<i>clock</i>-&gt;<i>entries</i>)
        <i>clock</i>-&gt;<i>misses</i> += 1
    <b>if</b> <b>not</b> <var>FIFO</var>:
        <i>clock</i>-&gt;<i>recent</i> |= {<i>x</i>}

<i>clock3</i>, <i>clock4</i>, <i>refs</i> = <var>CLOCK</var>(3), <var>CLOCK</var>(4), []

<b>const</b> <var>VALUES</var> = { 1..5 }

<b>var</b> <i>last</i> = {}
<b>for</b> <i>i</i> <b>in</b> {1..100}:
    <b>let</b> <i>x</i> = <i>i</i> <b>if</b> <i>i</i> &lt; 5 <b>else</b> <b>choose</b>(<var>VALUES</var> - <i>last</i>):
        <i>refs</i> = <i>refs</i> + [<i>x</i>,]
        <var>ref</var>(?<i>clock3</i>, <i>x</i>); <var>ref</var>(?<i>clock4</i>, <i>x</i>)
        <b>assert</b>(<i>clock4.misses</i> &lt;= <i>clock3.misses</i>)
        <i>last</i> = {<i>x</i>}
</code></pre>

</center>
<h4>Figure 7.3. [<a href='https://harmony.cs.cornell.edu/code/clock.hny'>code/clock.hny</a>] Harmony program that finds page replacement anomalies</h4>


</div>

If you are ready to learn about how locks are implemented in practice,
you can now skip the rest of this chapter.  But if you would like to
see a cool example of using the concepts introduced in this chapter,
hang on for a sequential Harmony program that finds anomalies in page
replacement algorithms.
In 1969, B&eacute;l&aacute;dy et al. published a paper [<a href="#cite-Belady69">3</a>]
that showed that making a
cache larger does not necessarily lead to a higher hit ratio.  He showed
this for a scenario using a FIFO replacement policy when the cache is full. 
The program in <a href='#sec-56'>Figure 7.3</a> will find exactly the same scenario
if you define <var>FIFO</var> to be <b>True</b>.  Moreover, if you define
<var>FIFO</var> to be <b>False</b>, it will find a scenario for the
CLOCK replacement policy [<a href="#cite-clock">10</a>], often used in modern operating systems.<p>In this program, <var>CLOCK</var> maintains the state of a cache
(in practice, typically pages in memory).
The set <i>recent</i> maintains whether an access to the cache
for a particular reference was recent or not.
(It is not used if <var>FIFO</var> is <b>True</b>.)
The integer <i>misses</i> maintains the number of cache misses.
Method <var>ref</var>(<i>ck</i>, <i>x</i>) is invoked when <i>x</i> is
referenced and checked against the cache <i>ck</i>.<p>The program declares two caches: one with 3 entries (<i>clock3</i>)
and one with 4 entries (<i>clock4</i>).
The interesting part is in the last block of code.
It runs every sequence of references of up to 100 entries, using
references in the range 1 through 5.
Note that all the constants chosen in this program (3, 4, 5, 100)
are the result of some experimentation---you can try other ones.
To reduce the search space, the first four references are pinned
to 1, 2, 3, and 4.
Further reducing the search space, the program never repeats the
same reference twice in a row (using the local variable <i>last</i>).<p>The two things to note here is the use of the <b>choose</b>
expression and the <b>assert</b> statement.  Using <b>choose</b>,
we are able to express searching through all possible strings of
references without a complicated nested iteration.
Using <code>assert</code>, we are able to express the anomaly we are
looking for.<p>In case you want to check if you get the right results.  For <var>FIFO</var>,
the program finds the same anomaly that
B&eacute;l&aacute;dy et al. found: 1 2 3 4 1 2 5 1 2 3 4 5.
For the <var>CLOCK</var> algorithm the program actually finds a shorter
reference string: 1 2 3 4 2 1 2 5 1 2.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-57"><b>[Ex. 7.1]</b>:  (This is just for fun or exercise as it is not a concurrent or
distributed problem.)
Implement a Harmony program that finds solutions to the
&quot;cabbage, goat, and wolf&quot; problem.  In this problem, a person
accompanied by these three items has to cross a stream in a small
boat, but can only take one item at a time. So, the person has to
cross back and forth several times, leaving two items on one or
the other shore by themselves.
Unfortunately, if left to themselves, the goat would
eat the cabbage and the wolf would eat the goat.  What crossings
does the person need to make in order not to lose any items?
</ul>
</div>

<div id='sec-58'>
<h1>Chapter 8. Specification</h1>

<p><div id='sec-59'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>Lock</var>() <b>returns</b> <i>result</i>:
    <i>result</i> = <b>False</b>

<b>def</b> <var>acquire</var>(<i>lk</i>):
    <b>atomically</b> <b>when</b> <b>not</b> !<i>lk</i>:
        !<i>lk</i> = <b>True</b>

<b>def</b> <var>release</var>(<i>lk</i>):
    <b>atomically</b>:
        <b>assert</b> !<i>lk</i>
        !<i>lk</i> = <b>False</b>
</code></pre>

</center>
<h4>Figure 8.1. [<a href='https://harmony.cs.cornell.edu/code/lock.hny'>code/lock.hny</a>] Specification of a lock</h4>


</div>

<div id='sec-60'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <i>lock</i> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>

<b>const</b> <var>NTHREADS</var> = 5

<i>thelock</i> = <var>Lock</var>()

<b>def</b> <var>thread</var>():
    <var>acquire</var>(?<i>thelock</i>)
    <b>pass</b>             <i># critical section is here</i>
    <var>release</var>(?<i>thelock</i>)

<b>for</b> <i>i</i> <b>in</b> {1..NTHREADS}:
    <b>spawn</b> <var>thread</var>()
</code></pre>

</center>
<h4>Figure 8.2. [<a href='https://harmony.cs.cornell.edu/code/lock_demo.hny'>code/lock_demo.hny</a>] Using a lock to implement a
critical section</h4>


</div>

<div id='sec-61'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>

<b>sequential</b> <i>done</i>

<i>count</i> = 0
<i>countlock</i> = <var>Lock</var>()
<i>done</i> = [ <b>False</b>, <b>False</b> ]

<b>def</b> <var>thread</var>(<i>self</i>):
    <var>acquire</var>(?<i>countlock</i>)
    <i>count</i> = <i>count</i> + 1
    <var>release</var>(?<i>countlock</i>)
    <i>done</i>[<i>self</i>] = <b>True</b>
    <b>await</b> <i>done</i>[1 - <i>self</i>]
    <b>assert</b> <i>count</i> == 2

<b>spawn</b> <var>thread</var>(0)
<b>spawn</b> <var>thread</var>(1)
</code></pre>

</center>
<h4>Figure 8.3. [<a href='https://harmony.cs.cornell.edu/code/UpLock.hny'>code/UpLock.hny</a>] <a href='#sec-19'>Figure 3.3</a> fixed with a lock</h4>


</div>

So far, we have used Harmony to <i>implement</i> various algorithms.
But Harmony can also be used to <i>specify</i> what an algorithm is
supposed to do.
For example, <a href='#sec-59'>Figure 8.1</a> specifies the intended behavior
of a lock.
In this case, a lock is a boolean, initially <b>False</b>,
with two operations, <code>acquire()</code> and <code>release()</code>.
The <code>acquire()</code> operation waits until the lock is <b>False</b>
and then sets it to <b>True</b> in an atomic operation.
The <code>release()</code> operation sets the lock back to <b>False</b>.
The code is similar to <a href='#sec-39'>Figure 5.3</a>, except that waiting
for the lock to become available and taking it is executed as an
atomic operation.<p>The code in <a href='#sec-59'>Figure 8.1</a> is similar to the code in
Harmony's <var>synch</var> module.
(The module generalizes locks to <i>binary semaphores</i>
(<a href='#sec-118'>Chapter 16</a>), but the lock interface is the same.)
<a href='#sec-60'>Figure 8.2</a> shows how locks may be used to implement
a critical section.
<a href='#sec-61'>Figure 8.3</a> gives an example of how locks may be used
to fix the program of <a href='#sec-19'>Figure 3.3</a>.<p>Note that the code of <a href='#sec-59'>Figure 8.1</a> is executable in Harmony.
However, the <b>atomically</b> keyword is not available in general
programming languages and should not be used for implementation.
Peterson's algorithm is an implementation of a lock, although only for
two processes.  In the following chapters, we will look at more general
ways of implementing locks using atomic constructions that are usually
available in the underlying hardware.<p>In Harmony, any statement can be preceded by the <b>atomically</b>
keyword.  It means that statement as a whole is to be executed atomically.
The <b>atomically</b> keyword can be used to specify the behavior of
methods such as <var>acquire</var> and <var>release</var>.  But
an actual executable program should not use the <b>atomically</b> keyword
because---on a normal machine---it cannot be directly compiled into
machine code.
If we want to make the program executable on hardware,
we have to show how <var>Lock</var>, <var>acquire</var>, and <var>release</var>
are implemented, not just how they are specified.
<a href='#sec-62'>Chapter 9</a> presents such an implementation.<p>The code in <a href='#sec-59'>Figure 8.1</a> also uses the Harmony <b>when</b>
statement.  A <b>when</b> statement waits until a time in which
condition holds (not necessarily the first time) and then executes the
statement block.  The &quot;<b>await</b> <i>condition</i>&quot; statement is
the same as &quot;<b>when</b> <i>condition</i>: <b>pass</b>&quot;.
Combined with the <b>atomically</b> keyword, the entire statement
is executed atomically at a time that the condition holds.<p>It is important to appreciate the difference between an
<i>atomic section</i> (the statements executed within an
atomic block of statements) and a <i>critical section</i>
(protected by a lock of some sort).
The former ensures that while the
statements are executing no other thread can execute.
The latter allows multiple threads to run concurrently,
just not within the critical section.
The former is rarely available to a programmer (e.g., none of
Python, C, or Java support it), while the latter
is very common.<p>Atomic statements
are not intended to replace locks or other synchonization primitives.
When implementing synchronization solutions you should not directly use
atomic statements but use the synchronization primitives that are available
to you.  But if you want to <i>specify</i> a synchronization primitive,
then use <b>atomically</b> by all means.
You can also use atomic statements in your test code.
In fact, as mentioned before, <b>assert</b> statements are included to
test if certain conditions hold in every execution and are executed
atomically.
</div>

<div id='sec-62'>
<h1>Chapter 9. Spinlock</h1>


<a id="index:spinlock:1"></a><p>


<p><a id="gls:spinlock:1"></a><p><div id='sec-63'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>N</var> = 3

<i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<i>shared</i> = <b>False</b>
<i>private</i> = [ <b>True</b>, ] * <var>N</var>
<b>invariant</b> <b>len</b>(<i>x</i> <b>for</b> <i>x</i> <b>in</b> [<i>shared</i>,] + <i>private</i> <b>where</b> <b>not</b> <i>x</i>) &lt;= 1

<b>def</b> <var>test_and_set</var>(<i>s</i>, <i>p</i>):
    <b>atomically</b>:
        !<i>p</i> = !<i>s</i>
        !<i>s</i> = <b>True</b>

<b>def</b> <var>clear</var>(<i>s</i>):
    <b>assert</b> !<i>s</i>
    <b>atomically</b> !<i>s</i> = <b>False</b>

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <i># Enter critical section</i>
        <b>while</b> <i>private</i>[<i>self</i>]:
            <var>test_and_set</var>(?<i>shared</i>, ?<i>private</i>[<i>self</i>])

        <b>atomically</b> <i>in_cs</i> += 1
        <b>assert</b> <b>not</b> <i>private</i>[<i>self</i>]
        <b>atomically</b> <i>in_cs</i> -= 1

        <i># Leave critical section</i>
        <i>private</i>[<i>self</i>] = <b>True</b>
        <var>clear</var>(?<i>shared</i>)

<b>for</b> <i>i</i> <b>in</b> {0..N-1}:
    <b>spawn</b> <var>thread</var>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 9.1. [<a href='https://harmony.cs.cornell.edu/code/spinlock.hny'>code/spinlock.hny</a>] Mutual Exclusion using a &quot;spinlock&quot; based on test-and-set</h4>


</div>

Peterson's algorithm implements locks, but it is not efficient,
especially if generalized to multiple threads.
Worse, Peterson relies on load and store operations to be executed
atomically, but this may not be the case.
There are a variety of possible reasons for this.<p><ul><li> Variables may have more bits than the processor's data bus.
For example, variables may have 32 bits, but the data bus may only
have 16 bits.  Thus to store or load a variable takes two 16-bit
operations each.  Take, for example, a variable that has value
0xFFFFFFFF, and consider a concurrent load and store operation on
the variable.
The store operation wants to clear the variable, but because it
takes two store operations on the bus, the load operation may
return either 0xFFFF0000 or 0x0000FFFF, a value that the variable
never was supposed to have.
This is the case even if the processor supports a 32-bit load or
store machine instruction: on the data bus it is still two
operations.
<li> Modern processors sometimes re-orders load and store operations
(out-of-order execution) for improved performance.  On a sequential processor,
the re-ordering is not a problem as the processor only re-orders
operations on independent memory locations.  However, as <a href='#sec-49'>Exercise 6.3</a>
showed, Peterson's algorithm breaks down if such seemingly independent
operations are re-ordered.
Some memory caches can also cause non-atomic behavior of memory when shared
among multiple cores.
<li> Even compilers, in their code generation, may make optimizations
that can reorder operations, or even eliminate operations, on variables.
For example, a compiler may decide that it is unnecessary to read the same
variable more than once, because how could it possibly change if there
are no store operations in between?
</ul>

Peterson's algorithm relies on a <i>sequential consistent memory model</i>
and hence the <b>sequential</b> statement: without it Harmony will
complain about data races.
More precisely, the <b>sequential</b> statement says that the
program relies on memory load and store instructions operating on
the indicated variables to be performed sequentially, and that this
order should be consistent with the order of operations invoked on each
thread.
The default memory models of C and Java are not sequentially
consistent.
The unfortunately named <b>volatile</b> keyword in Java has
a similar function as Harmony's <b>sequential</b> keyword.
Like many constructions in Java, its <code>volatile</code> keyword
was borrowed from C and C++.
However, in C and C++, they do <i>not</i> provide sequential
consistency, and one cannot implement Peterson's algorithm in
C or C++ directly.<p><a id="gls:atomic-instruction:1"></a>
For proper synchronization, multi-core processors provide so-called
<i>atomic instructions</i>:
<a id="index:atomic-instruction:1"></a>special machine instructions
that can read memory and then write it in an indivisible step.
While the HVM does not have any specific built-in atomic instructions
besides loading and storing variables,
it does have support for executing multiple instructions atomically.
Any Harmony statement can be made atomic using the
<b>atomically</b> keyword.
We can use atomic statements to implement a wide variety of
atomic operations.
For example, we could fix the program in <a href='#sec-19'>Figure 3.3</a> by
constructing an atomic increment operation for a counter, like so:
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>atomic_inc</var>(<i>ptr</i>):
    <b>atomically</b> !<i>ptr</i> += 1
    
<i>count</i> = 0
<var>atomic_inc</var>(?<i>count</i>)
</code></pre>

</center>

To support implementing locks,
many CPUs have an atomic &quot;test-and-set&quot; (TAS)
<a id="index:test-and-set:1"></a>
<a id="index:TAS:1"></a>
operation.
Method <var>test_and_set</var> in <a href='#sec-63'>Figure 9.1</a> shows its specification.
Here <i>s</i> points to a shared boolean variable and <i>p</i>
to a private boolean variable, belonging to some thread.
The operation copies the value of the shared variable to the
private variable (the &quot;test&quot;)
and then sets the shared variable to <b>True</b> (&quot;set&quot;).<p><a href='#sec-63'>Figure 9.1</a> goes on to implement mutual exclusion for
a set of <var>N</var> threads.
The approach is called <i>spinlock</i>,
<a id="index:spinlock:2"></a>
because each thread is &quot;spinning&quot; (executing a tight loop) until
it can acquire the lock.
The program uses <var>N</var> + 1 boolean variables.
Variable <i>shared</i> is initialized to <b>False</b> while
<i>private</i>[<i>i</i>] for each thread <i>i</i> is initialized to <b>True</b>.<p>An important invariant,  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">1</span></sub> , of the program is that at any time at most
one of these variables is <b>False</b>.
Another invariant, 
<span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">2</span></sub>(<span 
class="cmmi-10">i</span>) , is that if thread <i>i</i> is
in the critical section, then <i>private</i>[<i>i</i>] = <b>False</b>.
Between the two (i.e.,  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">1</span></sub> <span 
class="cmsy-10">&#x2227;&#x2200;</span><span 
class="cmmi-10">i </span>: <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">2</span></sub>(<span 
class="cmmi-10">i</span>) ),
it is clear that only one thread can be in the
critical section at the same time.

To see that invariant  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">1</span></sub>
 is maintained, note that
!<i>p</i> = <b>True</b> upon entry of <var>test_and_set</var>
(because of the condition on the <b>while</b> loop that the
<var>test_and_set</var> method is invoked in).
There are two cases:
<ol><li> !<i>s</i> is <b>False</b> upon entry to <var>test_and_set</var>.
Then upon exit !<i>p</i> = <b>False</b> and !<i>s</i> = <b>True</b>,
maintaining the invariant.
<li> !<i>s</i> is <b>True</b> upon entry to <var>test_and_set</var>.
Then upon exit nothing has changed, maintaining the invariant.
</ol>
Invariant  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">1</span></sub>  is also easy to verify for exiting the critical section
because we can assume, by the induction hypothesis, that <i>private</i>[<i>i</i>] is
<b>True</b> just before exiting the critical section.
Invariant  <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">2</span></sub>(<span 
class="cmmi-10">i</span>)  is obvious as (i) thread <i>i</i> only proceeds to the critical
section if <i>private</i>(<i>i</i>] is <b>False</b>, and (ii) no other thread modifies
<i>private</i>(<i>i</i>].<p>Harmony can check these invariants.

<span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">1</span></sub>(<span 
class="cmmi-10">i</span>)  is specified in Line 8, while
 <span 
class="cmsy-10"><img 
src="cmsy10-49.png" alt="I" class="10x-x-49" /></span><sub><span 
class="cmr-7">2</span></sub>(<span 
class="cmmi-10">i</span>)  is checked by the <b>assert</b> statement in the
critical section.
The expression in Line 8 counts the number of <b>False</b> values and
checks that the result is less than or equal to 1.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-64"><b>[Ex. 9.1]</b>:  Implement an atomic swap operation.  It should take two pointer arguments
and swap the values.
<li id="sec-65"><b>[Ex. 9.2]</b>:   Implement a spinlock using the atomic swap operation.
<li id="sec-66"><b>[Ex. 9.3]</b>:  For the solution to <a href='#sec-65'>Exercise 9.2</a>,
write out the invariants that need to hold and check them using Harmony.
</ul>
</div>

<div id='sec-67'>
<h1>Chapter 10. Lock Implementations</h1>


<a id="index:lock:2"></a>
<a id="index:synch-module:1"></a><p><div id='sec-68'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>test_and_set</var>(<i>s</i>) <b>returns</b> <i>result</i>:
    <b>atomically</b>:
        <i>result</i> = !<i>s</i>
        !<i>s</i> = <b>True</b>

<b>def</b> <var>atomic_store</var>(<i>p</i>, <i>v</i>):
    <b>atomically</b> !<i>p</i> = <i>v</i>

<b>def</b> <var>Lock</var>() <b>returns</b> <i>result</i>:
    <i>result</i> = <b>False</b>

<b>def</b> <var>acquire</var>(<i>lk</i>):
    <b>while</b> <var>test_and_set</var>(<i>lk</i>):
        <b>pass</b>

<b>def</b> <var>release</var>(<i>lk</i>):
    <var>atomic_store</var>(<i>lk</i>, <b>False</b>)
</code></pre>

</center>
<h4>Figure 10.1. [<a href='https://harmony.cs.cornell.edu/code/lock_tas.hny'>code/lock_tas.hny</a>] Implementation of the lock
specification in <a href='#sec-59'>Figure 8.1</a> using a spinlock based on
test-and-set</h4>


</div>

<div id='sec-69'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>MAX_THREADS</var> = 8

<b>def</b> <var>fetch_and_increment</var>(<i>p</i>) <b>returns</b> <i>result</i>:
    <b>atomically</b>:
        <i>result</i> = !<i>p</i>
        !<i>p</i> = (!<i>p</i> + 1) % <var>MAX_THREADS</var>

<b>def</b> <var>atomic_load</var>(<i>p</i>) <b>returns</b> <i>result</i>:
    <b>atomically</b> <i>result</i> = !<i>p</i>

<b>def</b> <var>Lock</var>():
    <i>result</i> = { .<i>counter</i>: 0, .<i>dispenser</i>: 0 }

<b>def</b> <var>acquire</var>(<i>lk</i>):
    <b>let</b> <i>my_ticket</i> = <var>fetch_and_increment</var>(?<i>lk</i>-&gt;<i>dispenser</i>):
        <b>while</b> <var>atomic_load</var>(?<i>lk</i>-&gt;<i>counter</i>) != <i>my_ticket</i>:
            <b>pass</b>

<b>def</b> <var>release</var>(<i>lk</i>):
    <var>fetch_and_increment</var>(?<i>lk</i>-&gt;<i>counter</i>)
</code></pre>

</center>
<h4>Figure 10.2. [<a href='https://harmony.cs.cornell.edu/code/lock_ticket.hny'>code/lock_ticket.hny</a>] Implementation of the lock
specification in <a href='#sec-59'>Figure 8.1</a> using a ticket lock</h4>


</div>

<div id='sec-70'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <i>lock</i>

<b>const</b> <var>NTHREADS</var> = 5

<i>in_cs</i> = 0
<b>invariant</b> <i>in_cs</i> <b>in</b> { 0, 1 }

<i>thelock</i> = <i>lock.Lock</i>()

<b>def</b> <var>thread</var>():
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <i>lock.acquire</i>(?<i>thelock</i>)

        <b>atomically</b> <i>in_cs</i> += 1
        <i># Critical section</i>
        <b>atomically</b> <i>in_cs</i> -= 1

        <i>lock.release</i>(?<i>thelock</i>)

<b>for</b> <i>i</i> <b>in</b> {1..NTHREADS}:
    <b>spawn</b> <var>thread</var>()
</code></pre>

</center>
<h4>Figure 10.3. [<a href='https://harmony.cs.cornell.edu/code/lock_test1.hny'>code/lock_test1.hny</a>] A test program for locks
(based on \autoref{fig:cs})</h4>


</div>

Locks are probably the most prevalent and basic form of synchronization
in concurrent programs.  Typically, whenever you have a shared data
structure, you want to protect the data structure with a lock and
acquire the lock before access and release it immediately afterward.
In other words, you want the access to the data structure to be a
critical section.
That way, when a thread makes modifications to the data structure that take
multiple steps, other threads will not see the intermediate inconsistent
states of the data structure.<p><a id="index:data-race:1"></a>
<a id="gls:data-race:1"></a>
When there is a bug in a program because some code omitted obtaining
a lock before accessing a shared data structure, that is known as a
<i>data race</i>.
More precisely, a data race happens when there is a state in which multiple
threads are trying to access the same variable, and at least one of those
accesses updates the variable.
In many environments, including C and Java programs, the behavior of
concurrent load and store operations have tricky or even undefined
semantics.  One should therefore avoid data races, which is why Harmony
reports them even though Harmony has sequentially consistent memory.<p>Harmony does not report data races in two cases.
First, using the <b>sequential</b> statement, you can specify that
concurrent access to the specified variables is intended.
Second, if the accesses are within an atomic statement block, then they
are not considered part of a data race.<p><a href='#sec-63'>Figure 9.1</a> shows a lock implementation based on a shared
variable and a private variable for each thread.   The private
variables themselves are actually implemented as shared variables,
but they are accessed only by their respective threads.
A thread usually does not keep explicit track of whether it has a lock
or not, because it is implied by the control flow of the program---a
thread implicitly <i>knows</i> that when it is executing in a critical
section it has the lock.
There is no need to keep <i>private</i> as a shared
variable---we only did so to be able to show and check the invariants.
<a href='#sec-68'>Figure 10.1</a> shows a more straightforward implementation of a spinlock.
The lock is also cleared in an atomic statement to prevent a data race.
This approach is general for any number of threads.<p>You can test the spinlock with the program in <a href='#sec-70'>Figure 10.3</a>
using the command <code>harmony -m synch=lock_tas code/lock_test1.hny</code>.
The <code>-m</code> flag tells Harmony to use the <code>taslock.hny</code> file
for the <var>synch</var> module rather than the standard <var>synch</var> module
(which contains only a specification of the lock methods).
The test program has a collection of threads repeatedly enter a critical
section and testing that there is at most one thread in the critical section
at any time.<p><a id="index:starvation:1"></a>
The spinlock implementation suffers potentially from <i>starvation</i>:
an unlucky thread may never be able to get the lock while other threads
successfully acquire the lock one after another.  It could even happen
with just two threads: one thread might successfully acquire the lock
repeatedly in a loop, while another thread is never lucky enough to
acquire the lock in between.

A <i>ticket lock</i> (<a href='#sec-69'>Figure 10.2</a> is an implementation of a
lock that prevents starvation using an atomic <i>fetch-and-increment</i>
operator.  It is inspired by European bakeries.  A European bakery often has a
clearly displayed counter (usually just two digits) and a ticket dispenser.
Tickets are numbered 0 through 99 and repeat over and over again
(in the case of a two digit counter).
When a customer walks into the bakery, they draw a number from the dispenser
and wait until their number comes up.
Every time a customer has been helped, the counter is incremented.
(Note that this only works if there can be no more than 100 customers in
the bakery at a time.)<p><a href='#sec-69'>Figure 10.2</a> similarly uses two variables for a lock,
<i>counter</i> and <i>dispenser</i>.  When a thread acquires the
lock, it fetches the current dispenser value and increments it
modulo <var>MAX_THREADS</var>, all in one atomic operation.
In practice, <var>MAX_THREADS</var> would
be a number like  2<sup><span 
class="cmr-7">32</span></sup>  or  2<sup><span 
class="cmr-7">64</span></sup> , but since the Harmony model checker
checks every possible state, limiting <var>MAX_THREADS</var>
to a small number
significantly reduces the time to model check a Harmony program.
Plus it is easier to check that it fails when you run it with more than
<var>MAX_THREADS</var> threads.
Note that loading the counter must also be done atomically in order to
avoid a data race.
You can test the implementation using the command
<code>harmony -m synch=lock_ticket code/lock_test1.hny</code>.
To see it fail, try
<code>harmony -c NTHREADS=10 -m synch=lock_ticket code/lock_test1.hny</code>.<p>

<a id="gls:blocked-thread:1"></a><p>We now turn to a radically different way of implementing locks, one
that is commonly provided by operating systems to user processes.
We call a thread <i>blocked</i>
<a id="index:blocked-thread:1"></a>
if a thread cannot change the state or terminate unless
another thread changes the state first.
A thread trying to acquire a lock held by another thread is a good example
of a thread being blocked.
The only way forward is if the other thread releases the lock.
A thread that is in an infinite loop is also considered blocked.<p><div id='sec-71'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>list</var>

<b>def</b> <var>Lock</var>() <b>returns</b> <i>result</i>:
    <i>result</i> = { .<i>acquired</i>: <b>False</b>, .<i>suspended</i>: [] }

<b>def</b> <var>acquire</var>(<i>lk</i>):
    <b>atomically</b>:
        <b>if</b> <i>lk</i>-&gt;<i>acquired</i>:
            <b>stop</b> ?<i>lk</i>-&gt;<i>suspended</i>[<b>len</b> <i>lk</i>-&gt;<i>suspended</i>]
            <b>assert</b> <i>lk</i>-&gt;<i>acquired</i>
        <b>else</b>:
            <i>lk</i>-&gt;<i>acquired</i> = <b>True</b>

<b>def</b> <var>release</var>(<i>lk</i>):
    <b>atomically</b>:
        <b>assert</b> <i>lk</i>-&gt;<i>acquired</i>
        <b>if</b> <i>lk</i>-&gt;<i>suspended</i> == []:
            <i>lk</i>-&gt;<i>acquired</i> = <b>False</b>
        <b>else</b>:
            <b>go</b> (<var>list.head</var>(<i>lk</i>-&gt;<i>suspended</i>)) ()
            <i>lk</i>-&gt;<i>suspended</i> = <var>list.tail</var>(<i>lk</i>-&gt;<i>suspended</i>)
</code></pre>

</center>
<h4>Figure 10.4. [<a href='https://harmony.cs.cornell.edu/modules/lock_susp.hny'>modules/lock_susp.hny</a>] Lock implementation using suspension</h4>


</div>

In most operating systems, threads are virtual (as opposed to &quot;raw CPU cores&quot;)
and can be suspended until some condition changes.
For example, a thread that is trying to acquire a lock can be suspended until the lock is
available.
In Harmony, a thread can suspend itself and save its context (state) in a
shared variable.  Recall that the context of a thread contains
its program counter, stack, and register (containing the current
method's variables).
A context is a regular (if complex) Harmony value.
The syntax of the expression that a thread executes to suspend itself
is as follows:<p><center><b>stop</b> <i>s</i>
</center>

This causes the context of the thread to be saved in !<i>s</i> and
the thread to be no longer running.
Another thread can revive the thread using the <b>go</b>
<a id="index:go-statement:1"></a>
statement:<p><center><b>go</b> <i>s</i> <i>r</i>
</center>

Here <i>s</i> contains the context and <i>r</i> is a Harmony value.
It causes a thread with the context contained in <i>s</i> to be added to
the state that has just executed the <b>stop</b> <i>s</i>
<a id="index:stop-expression:1"></a>
expression.  The <b>stop</b> expression returns the value <i>r</i>.<p><a href='#sec-71'>Figure 10.4</a> shows the lock interface using suspension.
It is implemented as follows:
<ul><li> A lock maintains both a boolean indicating whether the
lock is currently acquired and a list of contexts of threads that want to
acquire the lock.
<li>  <var>acquire</var>()
<a id="index:acquire:1"></a>
acquires the lock if available and suspends the invoking thread if not.
In the latter case, the context of the thread is added to the end of the list of contexts.
Note that <b>stop</b> is called within an atomic statement block---this is
the only exception to such an atomic statement block running to completion.
While the
thread is running no other threads can run, but when the thread suspends itself
other threads can run.
<li>  <var>release</var>()
<a id="index:release:1"></a>
checks to see if any threads are waiting to acquire the lock.
If so, it uses the <var>head</var> and <var>tail</var>
methods from the <code>list</code> module (see <a href='#sec-292'>Section B.6</a>)
to resume the first thread that got
suspended and to remove its context from the list.
</ul>
Selecting the first thread is a design choice.  Another implementation could
have picked the last one, and yet another implementation could have used
<b>choose</b> to pick an arbitrary one.  Selecting the first is a common
choice in lock implementations as it prevents starvation.<p>You will find that using the <i>implementation</i> of a lock instead
of the <i>specification</i> of a lock (in the <var>synch</var> module)
often leads to the model checker searching a
significantly larger state space.
Thus it makes sense to model check larger programs in a modular fashion:
model check one module implementation at a time, using
specifications for the other modules.<p><p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-72"><b>[Ex. 10.1]</b>: 
Run <a href='#sec-61'>Figure 8.3</a> using (i) <var>synch</var> and (ii) <var>synchS</var>.
Report how many states were explored by Harmony for each module.
<li id="sec-73"><b>[Ex. 10.2]</b>:   <a href='#sec-76'>Figure 10.5</a> shows a Harmony program with two variables <i>x</i>
(initially 0) and <i>y</i> (initially 100) that can be accessed through methods
<code>setX</code> and <code>getXY</code>.  An application invariant is that <code>getXY</code>
should return a pair that sums to 100.  Add the necessary synchronization code.
<li id="sec-74"><b>[Ex. 10.3]</b>:   Implement <var>tryAcquire</var>(<i>b</i>) as an additional
interface for both the <var>synch</var> and <var>synchS</var> modules.
This interface is like <var>acquire</var>(<i>b</i>) but never blocks.  It
returns <b>True</b> if the lock was available (and now acquired) or <b>False</b>
if the lock was already acquired.
Hint: you do not have to change the existing code.
<li id="sec-75"><b>[Ex. 10.4]</b>:  People who use an ATM often first check their balance and then withdraw
a certain amount of money not exceeding their balance.  A negative balance
is not allowed.  <a href='#sec-77'>Figure 10.6</a> shows two operations on bank accounts:
one to check the balance and one to withdraw money.
Note that all operations on accounts are carefully protected by a lock
(i.e., there are no data races).
The <code>customer</code>
method models going to a particular ATM and withdrawing money not exceeding
the balance.
Running the code through Harmony reveals that there is a bug.
It is a common type of concurrency bug known as
<i>Time Of Check Time Of Execution</i> (TOCTOE).
<a id="index:Time-Of-Check-Time-Of-Execution:1"></a>
<a id="index:TOCTOE:1"></a>
In this case, by the time the withdraw operation is performed,
the balance can have changed.
Fix the code in <a href='#sec-77'>Figure 10.6</a>.  Note, you should leave the
customer code the same. You are only allowed to change the
<code>atm_</code> methods, and you cannot use the <b>atomically</b>
keyword.
</ul>



<p><div id='sec-76'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>x</i>, <i>y</i> = 0, 100

<b>def</b> <var>setX</var>(<var>a</var>):
    <i>x</i> = <var>a</var>
    <i>y</i> = 100 - <var>a</var>

<b>def</b> <var>getXY</var>() <b>returns</b> <i>xy</i>:
    <i>xy</i> = [<i>x</i>, <i>y</i>]

<b>def</b> <var>checker</var>():
    <b>let</b> <i>xy</i> = <var>getXY</var>():
        <b>assert</b> (<i>xy</i>[0] + <i>xy</i>[1]) == 100, <i>xy</i>
    
<b>spawn</b> <var>checker</var>()
<b>spawn</b> <var>setX</var>(50)
</code></pre>

</center>
<h4>Figure 10.5. [<a href='https://harmony.cs.cornell.edu/code/xy.hny'>code/xy.hny</a>] Incomplete code for <a href='#sec-73'>Exercise 10.2</a> with desired invariant  <span 
class="cmmi-10">x </span>+ <span 
class="cmmi-10">y </span>= 100 </h4>


</div>



<p><div id='sec-77'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>

<b>const</b> <var>N_ACCOUNTS</var> = 2
<b>const</b> <var>N_CUSTOMERS</var> = 2
<b>const</b> <var>N_ATMS</var> = 2
<b>const</b> <var>MAX_BALANCE</var> = 1

<i>accounts</i> = [ { .<i>lock</i>: <var>Lock</var>(), .<i>balance</i>: <b>choose</b>({0..MAX_BALANCE})}
                            <b>for</b> <i>i</i> <b>in</b> {1..N_ACCOUNTS} ]

<b>invariant</b> <b>min</b>(<i>accounts</i>[<i>acct</i>].<i>balance</i> <b>for</b> <i>acct</i> <b>in</b> {0..N_ACCOUNTS-1}) &gt;= 0

<b>def</b> <var>atm_check_balance</var>(<i>acct</i>) <b>returns</b> <i>balance</i>:  <i># return the balance on acct</i>
    <var>acquire</var>(?<i>accounts</i>[<i>acct</i>].<i>lock</i>)
    <i>balance</i> = <i>accounts</i>[<i>acct</i>].<i>balance</i>
    <var>release</var>(?<i>accounts</i>[<i>acct</i>].<i>lock</i>)

<b>def</b> <var>atm_withdraw</var>(<i>acct</i>, <i>amount</i>) <b>returns</b> <i>success</i>: <i># withdraw amount from acct</i>
    <b>assert</b> <i>amount</i> &gt;= 0
    <var>acquire</var>(?<i>accounts</i>[<i>acct</i>].<i>lock</i>)
    <i>accounts</i>[<i>acct</i>].<i>balance</i> -= <i>amount</i>
    <var>release</var>(?<i>accounts</i>[<i>acct</i>].<i>lock</i>)
    <i>success</i> = <b>True</b>

<b>def</b> <var>customer</var>(<i>atm</i>, <i>acct</i>, <i>amount</i>):
    <b>assert</b> <i>amount</i> &gt;= 0
    <b>let</b> <i>bal</i> = <var>atm_check_balance</var>(<i>acct</i>):
        <b>if</b> <i>amount</i> &lt;= <i>bal</i>:
            <var>atm_withdraw</var>(<i>acct</i>, <i>amount</i>)
        
<b>for</b> <i>i</i> <b>in</b> {1..N_ATMS}:
    <b>spawn</b> <var>customer</var>(<i>i</i>, <b>choose</b>({0..N_ACCOUNTS-1}),
                      <b>choose</b>({0..MAX_BALANCE}))
</code></pre>

</center>
<h4>Figure 10.6. [<a href='https://harmony.cs.cornell.edu/code/atm.hny'>code/atm.hny</a>] Withdrawing money from an ATM</h4>


</div>
</div>

<div id='sec-78'>
<h1>Chapter 11. Concurrent Data Structures</h1>

<p>



<p><div id='sec-79'>
 <center><table border='0'>
 <tr>
<td>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>Queue</var>() <b>returns</b> <var>empty</var>:
    <var>empty</var> = []

<b>def</b> <var>put</var>(<i>q</i>, <i>v</i>):
    !<i>q</i> += [<i>v</i>,]

<b>def</b> <var>get</var>(<i>q</i>) <b>returns</b> <i>next</i>:
    <b>if</b> !<i>q</i> == []:
        <i>next</i> = <b>None</b>
    <b>else</b>:
        <i>next</i> = (!<i>q</i>)[0]
        <b>del</b> (!<i>q</i>)[0]
</code></pre>
</td>

<td>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>Queue</var>() <b>returns</b> <var>empty</var>:
    <var>empty</var> = []

<b>def</b> <var>put</var>(<i>q</i>, <i>v</i>):
    <b>atomically</b> !<i>q</i> += [<i>v</i>,]

<b>def</b> <var>get</var>(<i>q</i>) <b>returns</b> <i>next</i>:
    <b>atomically</b>:
        <b>if</b> !<i>q</i> == []:
            <i>next</i> = <b>None</b>
        <b>else</b>:
            <i>next</i> = (!<i>q</i>)[0]
            <b>del</b> (!<i>q</i>)[0]
</code></pre>
</td>


</tr>
<tr>
<td>
(a) [<a href='https://harmony.cs.cornell.edu/code/queue_nonatom.hny'>code/queue_nonatom.hny</a>] Sequential</td>

<td>
(b) [<a href='https://harmony.cs.cornell.edu/code/queue.hny'>code/queue.hny</a>] Concurrent</td>

</tr>
</table>
</center>
<h4>Figure 11.1. A sequential and a concurrent specification of a queue</h4>


</div>

<div id='sec-80'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>queue</var>

<b>def</b> <var>sender</var>(<i>q</i>, <i>v</i>):
    <var>queue.put</var>(<i>q</i>, <i>v</i>)

<b>def</b> <var>receiver</var>(<i>q</i>):
    <b>let</b> <i>v</i> = <var>queue.get</var>(<i>q</i>):
        <b>assert</b> <i>v</i> <b>in</b> { <b>None</b>, 1, 2 }

<i>demoq</i> = <var>queue.Queue</var>()
<b>spawn</b> <var>sender</var>(?<i>demoq</i>, 1)
<b>spawn</b> <var>sender</var>(?<i>demoq</i>, 2)
<b>spawn</b> <var>receiver</var>(?<i>demoq</i>)
<b>spawn</b> <var>receiver</var>(?<i>demoq</i>)
</code></pre>

</center>
<h4>Figure 11.2. [<a href='https://harmony.cs.cornell.edu/code/queue_test1.hny'>code/queue_test1.hny</a>] Using a concurrent queue</h4>


</div>

The most common use for locks is in building concurrent data structures.
By way of example, we will first demonstrate how to build a concurrent queue.
The <code>queue</code> module can be used as follows:
<ul><li> <i>x</i> = <var>Queue</var>(): initialize a new queue <i>x</i>;
<li> <var>put</var>(?<i>x</i>, <i>v</i>): add <i>v</i> to the tail of <i>x</i>;
<li> <i>r</i> = <var>get</var>(?<i>x</i>): returns <i>r</i> = <b>None</b>
if <i>x</i> is empty or <i>r</i> = <i>v</i> if <i>v</i> was at the head of <i>x</i>.
</ul>


<a href='#sec-79'>Figure 11.1</a>(a) shows a sequential specification for such a
queue in Harmony.
It is a credible queue implementation,
but it cannot be used with threads concurrently accessing this queue.
<a href='#sec-79'>Figure 11.1</a>(b) shows the corresponding concurrent specification.
It cannot be used as an implementation for a queue, as processors generally
do not have atomic operations on lists, but it will work well as a
specification.
See <a href='#sec-80'>Figure 11.2</a> for a simple demonstration program that uses
a concurrent queue.<p>We will first implement the queue as a linked list.
The implementation in <a href='#sec-81'>Figure 11.3</a>
uses the <var>alloc</var> module for dynamic allocation
<a id="index:dynamic-allocation:1"></a>
of nodes in the list using <var>malloc</var>() and <var>free</var>().
<var>malloc</var>(<i>v</i>) returns a new memory location initialized to <i>v</i>,
which should be released with <var>free</var>() when it is no longer in use.
The queue maintains a <var>head</var> pointer to the first element in the list
and a <var>tail</var> pointer to the last element in the list.
The <var>head</var> pointer is <b>None</b> if and only if the queue is empty.
(<b>None</b> is a special address value that is not the address of any
memory location.)<p><var>Queue</var>() returns the initial value for a queue object
consisting of a <b>None</b> head and tail pointer and a lock.
The <var>put</var>(<i>q</i>, <i>v</i>) and <var>get</var>(<i>q</i>) methods both take a pointer <i>q</i> to the
queue object because both may modify the queue.
Before they access the value of the head or tail of the queue they first obtain
the lock.
When they are done, they release the lock.<p>An important thing to note in <a href='#sec-80'>Figure 11.2</a>
is Lines 7 and 8.
It would be incorrect to replace these by:<p><center><b>assert</b> <var>queue.get</var>(<i>q</i>) <b>in</b> { <b>None</b>, 1, 2 }
</center>

The reason is that <code>queue.get()</code> changes the state by
acquiring a lock, but the expressions in <b>assert</b>
statements (or <b>invariant</b> and <b>finally</b> statements)
are not allowed to change the state.<p><a href='#sec-82'>Figure 11.4</a> shows another
concurrent queue implementation [<a href="#cite-MS96">35</a>].
It is well-known, but what is not often realized is that
it requires sequentially consistent memory, which is not
said explicitly in the paper.
As a result, the algorithm must be coded very carefully to work
correctly with modern programming languages and
computer hardware.
The implementation uses separate
locks for the head and the tail,
allowing a <var>put</var> and a <var>get</var> operation
to proceed concurrently.  To avoid contention between the head and the tail,
the queue uses a dummy node at the head of the linked list.
Except initially, the dummy node is the last node that was dequeued.
Note that neither the <var>head</var> nor <var>tail</var> pointer are
ever <b>None</b>.
The problem is when the queue is empty and there are concurrent
<var>get</var> and <var>put</var> operations.
They obtain separate locks and then concurrently access the
<i>next</i> field in the dummy node---a data race with
undefined semantics in most environments.
To get around this problem, the implementation in <a href='#sec-82'>Figure 11.4</a> uses
<var>atomic_load</var> and <var>atomic_store</var> from the <var>synch</var> module.<p><div id='sec-81'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>
<b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>, <var>free</var>

<b>def</b> <var>Queue</var>() <b>returns</b> <var>empty</var>:
    <var>empty</var> = { .<i>head</i>: <b>None</b>, .<i>tail</i>: <b>None</b>, .<i>lock</i>: <var>Lock</var>() }

<b>def</b> <var>put</var>(<i>q</i>, <i>v</i>):
    <b>let</b> <i>node</i> = <var>malloc</var>({ .<i>value</i>: <i>v</i>, .<i>next</i>: <b>None</b> }):
        <var>acquire</var>(?<i>q</i>-&gt;<i>lock</i>)
        <b>if</b> <i>q</i>-&gt;<i>tail</i> == <b>None</b>:
            <i>q</i>-&gt;<i>tail</i> = <i>q</i>-&gt;<i>head</i> = <i>node</i>
        <b>else</b>:
            <i>q</i>-&gt;<i>tail</i>-&gt;<i>next</i> = <i>node</i>
            <i>q</i>-&gt;<i>tail</i> = <i>node</i>
        <var>release</var>(?<i>q</i>-&gt;<i>lock</i>)
    
<b>def</b> <var>get</var>(<i>q</i>) <b>returns</b> <i>next</i>:
    <var>acquire</var>(?<i>q</i>-&gt;<i>lock</i>)
    <b>let</b> <i>node</i> = <i>q</i>-&gt;<i>head</i>:
        <b>if</b> <i>node</i> == <b>None</b>:
            <i>next</i> = <b>None</b>
        <b>else</b>:
            <i>next</i> = <i>node</i>-&gt;<i>value</i>
            <i>q</i>-&gt;<i>head</i> = <i>node</i>-&gt;<i>next</i>
            <b>if</b> <i>q</i>-&gt;<i>head</i> == <b>None</b>:
                <i>q</i>-&gt;<i>tail</i> = <b>None</b>
            <var>free</var>(<i>node</i>)
    <var>release</var>(?<i>q</i>-&gt;<i>lock</i>)
</code></pre>

</center>
<center><img src="figures/queue.png" width="80%"></img>
</center>
<h4>Figure 11.3. [<a href='https://harmony.cs.cornell.edu/code/queue_lock.hny'>code/queue_lock.hny</a>] An implementation of a concurrent queue data structure and a depiction of a queue with three elements</h4>


</div>



<div id='sec-82'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>, <var>atomic_load</var>, <var>atomic_store</var>
<b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>, <var>free</var>

<b>def</b> <var>Queue</var>() <b>returns</b> <var>empty</var>:
    <b>let</b> <i>dummy</i> = <var>malloc</var>({ .<i>value</i>: (), .<i>next</i>: <b>None</b> }):
        <var>empty</var> = { .<i>head</i>: <i>dummy</i>, .<i>tail</i>: <i>dummy</i>, .<i>hdlock</i>: <var>Lock</var>(), .<i>tllock</i>: <var>Lock</var>() }

<b>def</b> <var>put</var>(<i>q</i>, <i>v</i>):
    <b>let</b> <i>node</i> = <var>malloc</var>({ .<i>value</i>: <i>v</i>, .<i>next</i>: <b>None</b> }):
        <var>acquire</var>(?<i>q</i>-&gt;<i>tllock</i>)
        <var>atomic_store</var>(?<i>q</i>-&gt;<i>tail</i>-&gt;<i>next</i>,  <i>node</i>)
        <i>q</i>-&gt;<i>tail</i> = <i>node</i>
        <var>release</var>(?<i>q</i>-&gt;<i>tllock</i>)

<b>def</b> <var>get</var>(<i>q</i>) <b>returns</b> <i>next</i>:
    <var>acquire</var>(?<i>q</i>-&gt;<i>hdlock</i>)
    <b>let</b> <i>dummy</i> = <i>q</i>-&gt;<i>head</i>
    <b>let</b> <i>node</i> = <var>atomic_load</var>(?<i>dummy</i>-&gt;<i>next</i>):
        <b>if</b> <i>node</i> == <b>None</b>:
            <i>next</i> = <b>None</b>
            <var>release</var>(?<i>q</i>-&gt;<i>hdlock</i>)
        <b>else</b>:
            <i>next</i> = <i>node</i>-&gt;<i>value</i>
            <i>q</i>-&gt;<i>head</i> = <i>node</i>
            <var>release</var>(?<i>q</i>-&gt;<i>hdlock</i>)
            <var>free</var>(<i>dummy</i>)
</code></pre>

</center>
<center><img src="figures/queueMS.png" width="80%"></img>
</center>
<h4>Figure 11.4. [<a href='https://harmony.cs.cornell.edu/code/queue_MS.hny'>code/queue_MS.hny</a>] A queue with separate locks for enqueuing and dequeuing items and a depiction of a queue with two elements</h4>


</div>





<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-83"><b>[Ex. 11.1]</b>:   Add a method <var>contains</var>(<i>q</i>, <i>v</i>) to
<a href='#sec-79'>Figure 11.1</a>(b) that checks to see if <i>v</i> is in queue <i>q</i>.
<li id="sec-84"><b>[Ex. 11.2]</b>:  Add a method <var>length</var>(<i>q</i>) to <a href='#sec-81'>Figure 11.3</a> that returns the length of the given queue.
The complexity of the method should be  <span 
class="cmmi-10">O</span>(1)
, which is to say that you should maintain
the length of the queue as a field member and update it in <var>put</var> and <var>get</var>.
<li id="sec-85"><b>[Ex. 11.3]</b>:   Write a method <var>check</var>(<i>q</i>)
that checks the integrity of the queue in <a href='#sec-81'>Figure 11.3</a>.
In particular, it should check the following integrity properties:
<ul><li> If the list is empty, <i>q</i>-&gt;<i>tail</i> should be <b>None</b>.
Otherwise, the last element in the linked list starting from <i>q</i>-&gt;<i>head</i>
should equal <i>q</i>-&gt;<i>head</i>. Moreover,
<i>q</i>-&gt;<i>tail</i>-&gt;<i>next</i> should be <b>None</b>;
<li> The length field that you added in <a href='#sec-85'>Exercise 11.3</a> should equal the length
of the list.
</ul>
Method <var>check</var>(<i>q</i>) should not obtain a lock; instead add the following line
just before releasing the lock in <var>put</var> and <var>get</var>:
<center><b>assert</b> <var>check</var>()
</center>
<li id="sec-86"><b>[Ex. 11.4]</b>:   Add a method  <span 
class="cmtt-10">remove</span>(<span 
class="cmmi-10">q,v</span>)  to <a href='#sec-81'>Figure 11.3</a>
that removes all occurrences of <i>v</i>, if any, from queue <i>q</i>.
<li id="sec-87"><b>[Ex. 11.5]</b>:  The test program in <a href='#sec-80'>Figure 11.2</a> is not a thorough test program.
Design and implement a test program for <a href='#sec-80'>Figure 11.2</a>.
Make sure you <i>test</i> the test program by trying it out against some buggy
queue implementations.  (You will learn more about testing concurrent programs in <a href='#sec-95'>Chapter 13</a>.)
</ul>
</div>

<div id='sec-88'>
<h1>Chapter 12. Fine-Grained Locking</h1>

<p>







<p><div id='sec-89'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>

<b>def</b> <var>SetObject</var>() <b>returns</b> <i>object</i>:
    <i>object</i> = <var>malloc</var>({})

<b>def</b> <var>insert</var>(<i>s</i>, <i>v</i>):
    <b>atomically</b> !<i>s</i> |= {<i>v</i>}

<b>def</b> <var>remove</var>(<i>s</i>, <i>v</i>):
    <b>atomically</b> !<i>s</i> -= {<i>v</i>}

<b>def</b> <var>contains</var>(<i>s</i>, <i>v</i>) <b>returns</b> <i>present</i>:
    <b>atomically</b> <i>present</i> = <i>v</i> <b>in</b> !<i>s</i>
</code></pre>

</center>
<h4>Figure 12.1. [<a href='https://harmony.cs.cornell.edu/code/setobj.hny'>code/setobj.hny</a>] Specification of a concurrent
set object</h4>


</div>

<div id='sec-90'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>setobj</var> <b>import</b> *

<i>myset</i> = <var>SetObject</var>()

<b>def</b> <var>thread1</var>():
    <var>insert</var>(<i>myset</i>, 1)
    <b>let</b> <i>x</i> = <var>contains</var>(<i>myset</i>, 1):
        <b>assert</b> <i>x</i>

<b>def</b> <var>thread2</var>(<i>v</i>):
    <var>insert</var>(<i>myset</i>, <i>v</i>)
    <var>remove</var>(<i>myset</i>, <i>v</i>)

<b>spawn</b> <var>thread1</var>()
<b>spawn</b> <var>thread2</var>(0)
<b>spawn</b> <var>thread2</var>(2)
</code></pre>

</center>
<h4>Figure 12.2. [<a href='https://harmony.cs.cornell.edu/code/setobj_test1.hny'>code/setobj_test1.hny</a>] Test code for set objects</h4>


</div>

<div id='sec-91'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>
<b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>, <var>free</var>

<b>def</b> <var>_node</var>(<i>v</i>, <i>n</i>) <b>returns</b> <i>node</i>:   <i># allocate and initialize a new list node</i>
    <i>node</i> = <var>malloc</var>({ .<i>lock</i>: <var>Lock</var>(), .<i>value</i>: <i>v</i>, .<i>next</i>: <i>n</i> })

<b>def</b> <var>_find</var>(<i>lst</i>, <i>v</i>) <b>returns</b> <i>pair</i>:
    <b>var</b> <i>before</i> = <i>lst</i>
    <var>acquire</var>(?<i>before</i>-&gt;<i>lock</i>)
    <b>var</b> <i>after</i> = <i>before</i>-&gt;<i>next</i>
    <var>acquire</var>(?<i>after</i>-&gt;<i>lock</i>)
    <b>while</b> <i>after</i>-&gt;<i>value</i> &lt; (0, <i>v</i>):
        <var>release</var>(?<i>before</i>-&gt;<i>lock</i>)
        <i>before</i> = <i>after</i>
        <i>after</i> = <i>before</i>-&gt;<i>next</i>
        <var>acquire</var>(?<i>after</i>-&gt;<i>lock</i>)
    <i>pair</i> = (<i>before</i>, <i>after</i>)

<b>def</b> <var>SetObject</var>() <b>returns</b> <i>object</i>:
    <i>object</i> = <var>_node</var>((-1, <b>None</b>), <var>_node</var>((1, <b>None</b>), <b>None</b>))

<b>def</b> <var>insert</var>(<i>lst</i>, <i>v</i>):
    <b>let</b> <i>before</i>, <i>after</i> = <var>_find</var>(<i>lst</i>, <i>v</i>):
        <b>if</b> <i>after</i>-&gt;<i>value</i> != (0, <i>v</i>):
            <i>before</i>-&gt;<i>next</i> = <var>_node</var>((0, <i>v</i>), <i>after</i>)
        <var>release</var>(?<i>after</i>-&gt;<i>lock</i>)
        <var>release</var>(?<i>before</i>-&gt;<i>lock</i>)

<b>def</b> <var>remove</var>(<i>lst</i>, <i>v</i>):
    <b>let</b> <i>before</i>, <i>after</i> = <var>_find</var>(<i>lst</i>, <i>v</i>):
        <b>if</b> <i>after</i>-&gt;<i>value</i> == (0, <i>v</i>):
            <i>before</i>-&gt;<i>next</i> = <i>after</i>-&gt;<i>next</i>
            <var>free</var>(<i>after</i>)
        <var>release</var>(?<i>before</i>-&gt;<i>lock</i>)

<b>def</b> <var>contains</var>(<i>lst</i>, <i>v</i>) <b>returns</b> <i>present</i>:
    <b>let</b> <i>before</i>, <i>after</i> = <var>_find</var>(<i>lst</i>, <i>v</i>):
        <i>present</i> = <i>after</i>-&gt;<i>value</i> == (0, <i>v</i>)
        <var>release</var>(?<i>after</i>-&gt;<i>lock</i>)
        <var>release</var>(?<i>before</i>-&gt;<i>lock</i>)
</code></pre>

</center>
<h4>Figure 12.3. [<a href='https://harmony.cs.cornell.edu/code/setobj_linkedlist.hny'>code/setobj_linkedlist.hny</a>] Implementation of a set of values using a linked list with fine-grained locking</h4>


</div>

<a id="index:big-lock:1"></a>
<a id="index:lock-granularity:1"></a>
<a id="index:fine-grained-lock:1"></a>
<a id="index:coarse-grained-lock:1"></a>
A queue has the nice property that usually only the head or the tail is accessed.
However, in many data structures it is necessary to &quot;walk&quot; the data structure,
an operation that can take significant time.
In such a case, a single lock (known as a &quot;big lock&quot;)
for the entire data structure might restrict concurrency to an unacceptable level.
To reduce the granularity of locking, each node in the data structure must be
endowed with its own lock instead.<p><a href='#sec-89'>Figure 12.1</a> gives the specification of a concurrent set object.
<code>SetObject()</code> returns a pointer to a variable that
contains an empty set, rather than returning an empty set <i>value</i>.
As such, it is more like an object in an object-oriented language than
like a value in its own right.
Values can be added to the set object using
<var>insert</var>() or deleted using <var>remove</var>().
Method <var>contains</var>() checks if a particular value is in the list.
<a href='#sec-90'>Figure 12.2</a> contains a simple (although not very thorough)
test program to demonstrate the use of set objects.<p><a href='#sec-91'>Figure 12.3</a> implements a concurrent set object using
an ordered linked list without duplicates.
The list has two dummy &quot;book-end&quot; nodes with values (-1, <b>None</b>) and
(1, <b>None</b>).  A value <i>v</i> is stored as (0, <i>v</i>)---note that for
any value <i>v</i>, (-1, <b>None</b>) &lt; (0, <i>v</i>) &lt; (1, <b>None</b>).
An invariant of the algorithm is that at any point in time the
list is &quot;valid,&quot; starting with a (-1, <b>None</b>) node and ending
with an (1, <b>None</b>) node.<p><a id="index:hand-over-hand-locking:1"></a>
Each node has a lock, a value, and <i>next</i>, a pointer to the next node
(which is <b>None</b> for the (1, <b>None</b>) node to mark the end of the list).
The <var>_find</var>(<i>lst</i>, <i>v</i>) helper method first
finds and locks two consecutive nodes <i>before</i> and <i>after</i>
such that <i>before</i>-&gt;<i>data</i>.<i>value</i> &lt; (0, <i>v</i>) &lt;= <i>after</i>-&gt;<i>data</i>.<i>value</i>.
It does so by performing something called <i>hand-over-hand locking</i>.
It first locks the first node, which is the (-1, <b>None</b>) node.
Then, iteratively, it obtains a lock on the next node and release the
lock on the last one, and so on, similar to climbing a rope
hand-over-hand.
Using <code>_find</code>, the <var>insert</var>, <var>remove</var>, and <code>contains</code>
methods are fairly straightforward to implement.<p>
<h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-92"><b>[Ex. 12.1]</b>:  Add methods to the data structure in <a href='#sec-91'>Figure 12.3</a>
that report the size of the list, the minimum value in the
list, the maximum value in the list, and the sum of the values in the list.
(All these should ignore the two end nodes.)
<li id="sec-93"><b>[Ex. 12.2]</b>:  Create a thread-safe sorted binary tree.  Implement a module <code>bintree</code>
with methods
 <span 
class="cmtt-10">BinTree</span>()
 to create a new binary tree,  <span 
class="cmtt-10">insert</span>(<span 
class="cmmi-10">t,v</span>)  that inserts <i>v</i> into
tree <i>t</i>, and  <span 
class="cmtt-10">contains</span>(<span 
class="cmmi-10">t,v</span>)
 that checks if <i>v</i> is in tree <i>t</i>.  Use a single
lock per binary tree.
<li id="sec-94"><b>[Ex. 12.3]</b>:  Create a binary tree that uses, instead of a single lock per tree,
a lock for each node in the tree.
</ul>
</div>

<div id='sec-95'>
<h1>Chapter 13. Testing: Checking Behaviors</h1>



<a id="gls:behavior:1"></a><p><div id='sec-96'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>queue</var>, <var>queueconc</var>

<b>const</b> <var>NOPS</var> = 4
<b>const</b> <var>VALUES</var> = { 1..NOPS }

<i>specq</i> = <var>queue.Queue</var>()
<i>implq</i> = <var>queueconc.Queue</var>()

<b>for</b> <i>i</i> <b>in</b> {1..NOPS}:
    <b>let</b> <i>op</i> = <b>choose</b>({ "get", "put" }):
        <b>if</b> <i>op</i> == "put":
            <b>let</b> <i>v</i> = <b>choose</b>(<var>VALUES</var>):
                <var>queueconc.put</var>(?<i>implq</i>, <i>v</i>)
                <var>queue.put</var>(?<i>specq</i>, <i>v</i>)
        <b>else</b>:
            <b>let</b> <i>v</i> = <var>queueconc.get</var>(?<i>implq</i>)
            <b>let</b> <i>w</i> = <var>queue.get</var>(?<i>specq</i>):
                <b>assert</b> <i>v</i> == <i>w</i>
</code></pre>

</center>
<h4>Figure 13.1. [<a href='https://harmony.cs.cornell.edu/code/queue_test_seq.hny'>code/queue_test_seq.hny</a>] Sequential queue test</h4>


</div>

Testing is a way to increase confidence in the correctness
of an implementation.
<a href='#sec-80'>Figure 11.2</a> demonstrates how concurrent queues
may be used, but it is not a very thorough test program
for an implementation such as the one in <a href='#sec-81'>Figure 11.3</a>
and does little to increase our confidence in its correctness.
To wit, if <var>get</var>() always returned 1, the program
would find no problems.
Similarly, <a href='#sec-90'>Figure 12.2</a> is not a good test program
for something as complicated as <a href='#sec-91'>Figure 12.3</a>.
In this chapter, we will look at approaches to testing
concurrent code.<p>As with critical sections---when testing a concurrent data structure---we
need a specification.
For example, <a href='#sec-79'>Figure 11.1</a>(a) shows a sequential specification of a
queue in Harmony.
First, we can check if the queue implementation
in <a href='#sec-81'>Figure 11.3</a> meets the sequential
queue specification in <a href='#sec-79'>Figure 11.1</a>(a).
To check if the queue implementation meets the specification,
we need to see if any sequence of queue operations in the
implementation matches a corresponding sequence in the
specification.
We say that the implementation and the specification
have the same <i>behaviors</i> or are
<i>behaviorally equivalent</i>.<p>Behaviors say something about how we got to a state.
The same state can be reached by multiple behaviors, and the behaviors
are often an integral part of whether a program is correct or not.
Just because a state satisfies some invariant---however important---does
not mean that the state is valid given the sequence of operations.
For example, a state in which the queue is empty is certainly a valid state in
its own right, but if the last operation to get there was an enqueue operation,
there must be a bug in the program.
It can therefore be important to capture the behaviors.
We could store behaviors in the state itself by adding what is
known as a <i>history variable</i> that keeps track of all the operations.
While this can be useful for correctness proofs, for model checking this approach
presents a problem: introducing this
additional state can lead to state explosion or even turn a finite model
(a model with a finite number of states) into an infinite one.
We therefore use a different approach: composing an implementation with
its specification to ensure they accept the same behaviors.<p><a href='#sec-96'>Figure 13.1</a> presents a test program that does
exactly this, for sequences of up to <var>NOPS</var>
queue operations.
It maintains two queues:
<ul><li> <i>specq</i>: the queue of the specification;
<li> <i>implq</i>: the queue of the implementation.
</ul>
For each operation, the code first chooses whether to
perform a <var>get</var> or <var>put</var> operation.
In the case of a <var>put</var> operation, the code also
chooses which value to append to the queue.
All operations are performed on both the queue implementation
and the queue specification.
In the case of <var>get</var>, the results of the operation
on both the implementation and specification are checked against one another.<p><i>Test programs themselves should be tested</i>.
Just because a test program works with a particular implementation
does not mean the implementation is correct---it may be that the implementation
is incorrect but the test program does not have enough coverage to find any
bugs in the implementation.
So, run a test program like this with a variety of queue implementations that
have known bugs in them and make sure that the test program finds them.
Conversely, a test program may be broken in that it finds bugs that do not exist.
In my experience, it is often harder to implement the test program than
the algorithm that the test program tests.<p>As with any other test program,
<a href='#sec-96'>Figure 13.1</a> may not trigger extant bugs, but
it nonetheless inspires reasonable confidence that the
queue implementation is correct, at least sequentially.
The higher <var>NOPS</var>, the higher the confidence.
It is possible to write similar programs in other languages
such as Python, but the <b>choose</b> expression in Harmony
makes it relatively easy to explore all corner cases.
For example, a common programming mistake is to forget to
update the <var>tail</var> pointer in <var>get</var>() in case
the queue becomes empty.  Normally, it is a surprisingly
tricky bug to find.  You can comment out those lines
in <a href='#sec-81'>Figure 11.3</a> and run the test program---it should
easily find the bug and explain exactly how
the bug manifests itself, adding confidence that the test program
is reasonably thorough.<p>The test program also finds some common mistakes in using
locks, such as forgetting to release a lock when the queue
is empty, but it is not designed to find concurrency bugs
in general.  If you remove all <code>acquire()</code> and
<code>release()</code> calls from <a href='#sec-81'>Figure 11.3</a>,
the test program will not (and should not)
find any errors, but it would be an incorrect implementation
of a concurrent queue.<p><div id='sec-97'>
<center><img src="figures/qtestpar.png" width="100%"></img>
</center>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>queue</var>

<b>const</b> <var>NOPS</var> = 4
<i>q</i> = <var>queue.Queue</var>()

<b>def</b> <i>put_test</i>(<i>self</i>):
    <b>print</b>("call put", <i>self</i>)
    <var>queue.put</var>(?<i>q</i>, <i>self</i>)
    <b>print</b>("done put", <i>self</i>)

<b>def</b> <i>get_test</i>(<i>self</i>):
    <b>print</b>("call get", <i>self</i>)
    <b>let</b> <i>v</i> = <var>queue.get</var>(?<i>q</i>):
        <b>print</b>("done get", <i>self</i>, <i>v</i>)

<i>nputs</i> = <b>choose</b> {1..NOPS-1}
<b>for</b> <i>i</i> <b>in</b> {1..nputs}:
    <b>spawn</b> <i>put_test</i>(<i>i</i>)
<b>for</b> <i>i</i> <b>in</b> {1..NOPS-<i>nputs</i>}:
    <b>spawn</b> <i>get_test</i>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 13.2. [<a href='https://harmony.cs.cornell.edu/code/queue_btest1.hny'>code/queue_btest1.hny</a>] Concurrent queue test.  The
behavior DFA is for  <span 
class="cmtt-10">NOPS</span> = 2 .</h4>


</div>

<div id='sec-98'>
<center><pre><code class="language-none">import queue, threading, random

NOPS = 4
q = queue.Queue()

def put_test(self):
    print("call put", self)
    q.put(self)
    print("done put", self)

def get_test(self):
    print("call get", self)
    try:
        v = q.get(block=False)
        print("done get", self, v)
    except queue.Empty:
        print("done get empty", self)

nputs = random.randint(1, NOPS - 1)
for i in range(nputs):
    threading.Thread(target=put_test, args=(i,)).start()
for i in range(NOPS - nputs):
    threading.Thread(target=get_test, args=(i,)).start()
</code></pre>

</center>
<h4>Figure 13.3. [<a href='https://harmony.cs.cornell.edu/python/queue_btest1.py'>python/queue_btest1.py</a>] Python implementation of <a href='#sec-97'>Figure 13.2</a></h4>


</div>

<div id='sec-99'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>Queue</var>() <b>returns</b> <var>empty</var>:
    <var>empty</var> = { .<i>data</i>: [], .<i>head</i>: 0, .<i>tail</i>: 0 }

<b>def</b> <var>put</var>(<i>q</i>, <i>v</i>):
    <b>let</b> <i>i</i> = <i>q</i>-&gt;<i>tail</i>:
        <i>q</i>-&gt;<i>data</i>[<i>i</i>] = <i>v</i>
        <i>q</i>-&gt;<i>tail</i> = <i>i</i> + 1

<b>def</b> <var>get</var>(<i>q</i>) <b>returns</b> <i>next</i>:
    <b>let</b> <i>i</i> = <i>q</i>-&gt;<i>head</i>:
        <b>if</b> <i>i</i> == <i>q</i>-&gt;<i>tail</i>:
            <i>next</i> = <b>None</b>
        <b>else</b>:
            <i>next</i> = <i>q</i>-&gt;<i>data</i>[<i>i</i>]
            <i>q</i>-&gt;<i>head</i> = <i>i</i> + 1
</code></pre>

</center>
<h4>Figure 13.4. [<a href='https://harmony.cs.cornell.edu/code/queue_nonatom_seq.hny'>code/queue_nonatom_seq.hny</a>] Sequential but not a concurrent
queue implementation</h4>


</div>

The next step is to test if the queue implementation
meets the <i>concurrent</i> queue specification or not.
<a href='#sec-79'>Figure 11.1</a>(b) shows the concurrent queue specification.
It is similar to the sequential specification in <a href='#sec-79'>Figure 11.1</a>(a)
but makes all operations (except instantiation itself) atomic.
Testing the implementation of a concurrent queue specification is
trickier than testing the implementation of a sequential one because
there are many more scenarios to check.<p>We would like a way that---similar to the sequential test---systematically
compares behaviors of the
concurrent queue implementation with behaviors of the concurrent
queue specification.  But we cannot do this by composing the specification
and the implementation and simply run the same test operations on both as we
did before---concurrency make the operations non-determistic and thus
the specification and implementation of a single execution might produce
different results, even if both are correct.
Instead, we will create a test program that tries various concurrent
combinations of queue operations, and run it twice: once against the
specification of the concurrent queue and once against the
implementation.  We will then check if the behaviors obtained from
running the implementation are also behaviors obtained
from the specification.<p>We will start with a test program that tries concurrent combinations
of various queue operations.
<a href='#sec-97'>Figure 13.2</a> shows the test program.  It starts
<var>NOPS</var> threads doing either a <var>put</var>
or a <var>get</var> operation.  It selects the fraction of <var>put</var>
over <var>get</var> operations nondetermistically, although avoiding the
uninteresting case in which there are none of one of them.
In case of a <var>put</var> operation,
the thread enqueues its own name (which is provided as an argument
to the thread).  In order to capture the behaviors,
each thread prints what operation it is about to perform,
and afterwards it prints that the operation has
completed (including the return value if any).<p>This is probably much like you would do if you were trying to find a
bug in a program.
<a href='#sec-98'>Figure 13.3</a> shows a Python implementation of the same
test program.  You can run it a bunch of times and manually check
the output.  There are, however, two problems with this approach.
First, it is often difficult to check if the behaviors you find are
correct ones, and it is easy to overlook problems in the output.
Second, the test program many not check all possible behaviors.<p>Using Harmony, these problems can be avoided.
<a href='#sec-97'>Figure 13.2</a> also shows the deterministic finite automaton
that describes the possible outputs when the test
program is run against the specification in the case
<var>NOPS</var> = 2---for <var>NOPS</var> = 4 it would be much
too large to print here.  Since there are no cycles in the DFA, you
can follow some paths through this DFA and see that they are valid
interleavings of the threads.
You can obtain this output yourself by running<p><center>$ harmony -c NOPS=2 -o spec.png code/queue_btest1.hny
</center>

If you run the same test program against the implementation
of <a href='#sec-81'>Figure 11.3</a>, you will get the same output:<p><center>$ harmony -c NOPS=2 -o impl.png -m queue=queue_lock code/queue_btest1.hny
</center>

You can
try this for various <var>NOPS</var>, although it gets increasingly
harder to check by hand that the generated DFAs are the same as
<var>NOPS</var> increases.
Now run the test program against <a href='#sec-99'>Figure 13.4</a>, which is
clearly an incorrect implementation of the concurrent queue specification
because it contains no synchronization code.
However, Harmony does not immediately detect
any problems.  In fact, for  <span 
class="cmtt-10">NOPS</span> = 2  it even generates
the same set of behaviors.
This is because the test program only outputs the behaviors---it does
not check if they are correct.<p>Harmony does have a way to check the behaviors of one program against
the behaviors of another.  In particular, we want to check if the
behaviors of the implementations we have match behaviors of the
specification.  The following shows, for example, how to check the
<code>queueconc.hny</code> implementation on the command line:<p><center><pre><code class="language-none">$ harmony -o queue4.hfa code/queue_btest1.hny
$ harmony -B queue4.hfa -m queue=queue_lock code/queue_btest1.hny
</code></pre>
</center>

The first command runs the <code>code/qtestpar.hny</code> program (with the
default 4 threads)
and writes a representation of the output DFA in the file <code>queue4.hfa</code>.
The second command runs the same test program, but using the queue
implementation in the file <code>code/queueconc.hny</code>.  Moreover, it reads
the DFA in <code>queue4.hfa</code> to check if every behavior of the second
run of the test program is also a behavior of the first run.
You can try the same using the <code>code/queueseq.hny</code> implementation
and find that this implementation has behaviors that are not allowed by
the specification.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-100"><b>[Ex. 13.1]</b>:  <a href='#sec-59'>Figure 8.1</a> shows a specification of a lock.  Write a program
that checks the behaviors of lock implementations such as <a href='#sec-68'>Figure 10.1</a>
and <a href='#sec-69'>Figure 10.2</a>.  That is, it should not rely on assertions such as
in <a href='#sec-38'>Figure 5.2</a>.
<li id="sec-101"><b>[Ex. 13.2]</b>:  Write a Harmony program that checks if
<a href='#sec-91'>Figure 12.3</a> satisfies the specification
of <a href='#sec-89'>Figure 12.1</a> <i>sequentially</i>.
<li id="sec-102"><b>[Ex. 13.3]</b>:  Write a Harmony program that checks if
<a href='#sec-91'>Figure 12.3</a> satisfies the specification
of <a href='#sec-89'>Figure 12.1</a> <i>concurrently</i>.
<li id="sec-103"><b>[Ex. 13.4]</b>:  Rewrite <a href='#sec-96'>Figure 13.1</a> so it only imports <code>queue</code>
and runs <var>NOPS</var> nondeterministically chosen operations against
it (similar in style to <a href='#sec-97'>Figure 13.2</a> but without threads).
Then use behaviors to check that <a href='#sec-81'>Figure 11.3</a> and
<a href='#sec-99'>Figure 13.4</a> are correct sequential implementations of
the queue.  Check your test program by also trying it on one or two
buggy queue implementations.
</ul>
</div>

<div id='sec-104'>
<h1>Chapter 14. Debugging</h1>

<p><div id='sec-105'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>
<b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>, <var>free</var>

<b>def</b> <var>Queue</var>() <b>returns</b> <var>empty</var>:
    <var>empty</var> = { .<i>next</i>: <b>None</b>, .<i>value</i>: <b>None</b>, .<i>lock</i>: <var>Lock</var>() }

<b>def</b> <var>put</var>(<i>q</i>, <i>v</i>):
    <b>let</b> <i>node</i> = <var>malloc</var>({ .<i>next</i>: <b>None</b>, .<i>value</i>: <i>v</i>, .<i>lock</i>: <var>Lock</var>() }):
        <b>var</b> <i>nq</i> = <i>q</i>
        <b>while</b> <i>nq</i> != <b>None</b>:
            <var>acquire</var>(?<i>nq</i>-&gt;<i>lock</i>)
            <b>let</b> <i>n</i> = <i>nq</i>-&gt;<i>next</i>:
                <b>if</b> <i>n</i> == <b>None</b>:
                    <i>nq</i>-&gt;<i>next</i> = <i>node</i>
                <var>release</var>(?<i>nq</i>-&gt;<i>lock</i>)
                <i>nq</i> = <i>n</i>

<b>def</b> <var>get</var>(<i>q</i>) <b>returns</b> <i>next</i>:
    <var>acquire</var>(?<i>q</i>-&gt;<i>lock</i>)
    <b>if</b> <i>q</i>-&gt;<i>next</i> == <b>None</b>:
        <i>next</i> = <b>None</b>
    <b>else</b>:
        <b>let</b> <i>node</i> = <i>q</i>-&gt;<i>next</i>:
            <i>q</i>-&gt;<i>next</i> = <i>node</i>-&gt;<i>next</i>
            <i>next</i> = <i>node</i>-&gt;<i>value</i>
            <var>free</var>(<i>node</i>)
    <var>release</var>(?<i>q</i>-&gt;<i>lock</i>)
</code></pre>

</center>
<h4>Figure 14.1. [<a href='https://harmony.cs.cornell.edu/code/queue_broken.hny'>code/queue_broken.hny</a>] Another buggy queue implementation</h4>


</div>

<div id='sec-106'>
<center>$ harmony -m queue=queue_broken code/queue_btest1.hny
<ul>
<li>Phase 1: compile Harmony program to bytecode</li>
<li>Phase 2: run the model checker (nworkers = 8)
<ul>
<li>21423 states (time 0.01s, mem=0.002GB)</li>
</ul></li>
<li>Phase 3: analysis
<ul>
<li><strong>Safety Violation</strong></li>
</ul></li>
<li>Phase 4: write results to code/queue_btest1.hco</li>
<li>Phase 5: loading code/queue_btest1.hco</li>
</ul>

<hr />

<p><strong>Summary: something went wrong in an execution</strong></p>

<p>Here is a summary of an execution that exhibits the issue:</p>

<ul>
<li>Schedule thread T0: <strong>init</strong>()
<ul>
<li>Line alloc/1: Initialize alloc$pool to {:}</li>
<li>Line alloc/2: Initialize alloc$next to 0</li>
<li>Line 4: Initialize q to { "lock": False, "next": None, "value": None }</li>
<li>Line 16: Choose 2</li>
<li>Line 16: Initialize nputs to 2</li>
<li><strong>Terminated</strong></li>
</ul></li>
<li>Schedule thread T1: put<em>test(1)
<ul>
<li>Current values of global variables:
<ul>
<li>alloc$next: 0</li>
<li>alloc$pool: {:}</li>
<li>nputs: 2</li>
<li>q: { "lock": False, "next": None, "value": None }</li>
</ul></li>
<li>Line 7: Print [ "call put", 1 ]</li>
<li>Line alloc/5: Set alloc$next to 1</li>
<li>Line alloc/5: Initialize alloc$pool[0] to { "lock": False, "next": None, "value": 1 }</li>
<li>Line synch/36: Set q["lock"] to True</li>
<li>Line queue/14: Set q["next"] to ?alloc$pool[0]</li>
<li>Line synch/41: Set q["lock"] to False</li>
<li>Preempted in put</em>test(1)
about to print [ "done put", 1 ] in line 9</li>
</ul></li>
<li>Schedule thread T2: put_test(2)
<ul>
<li>Current values of global variables:
<ul>
<li>alloc$next: 1</li>
<li>alloc$pool: [ { "lock": False, "next": None, "value": 1 } ]</li>
<li>nputs: 2</li>
<li>q: { "lock": False, "next": ?alloc$pool[0], "value": None }</li>
</ul></li>
<li>Line 7: Print [ "call put", 2 ]</li>
<li>Line alloc/5: Set alloc$next to 2
...</li>
</ul></li>
</ul>
</center>
<h4>Figure 14.2. Running <a href='#sec-97'>Figure 13.2</a> against <a href='#sec-105'>Figure 14.1</a></h4>


</div>

<div id='sec-107'>
<center><img src="figures/queuebroken1.png" width="100%"></img>
</center>
<h4>Figure 14.3. 
<a href="https://harmony.cs.cornell.edu/output/queuebug.html">HTML output</a> of
<a href='#sec-106'>Figure 14.2</a> but for <var>NOPS</var>=3</h4>


</div>

So, you wrote a Harmony program and Harmony reports a problem.
Often you may just be able to figure it out by staring at the code and
going through some easy scenarios, but what if you don't?
The output of Harmony can be helpful in that case.<p><a href='#sec-105'>Figure 14.1</a> contains an attempt at a queue implementation
where the queue is implemented by a linked list, with the first node
being a <code>dummy</code> node to prevent data races.  Each node in the
list contains a lock.  The <var>put</var>() method walks the list until
it gets to the last node, each time acquiring the lock to access the
node's fields.  When <var>put</var>() gets to the last node in the list,
it appends a new one.  The <var>get</var>() method locks the first (dummy)
node, removes the second from the list and frees it.  The method returns
the value from the removed node.<p>Let us run the code through the test programs in the last
chapter.  Harmony does not detect any issues with the sequential test
in <a href='#sec-96'>Figure 13.1</a>.
(Run this using the <code>-m</code> flag like this:
<code>harmony -m queue=queue_broken code/qtestseq.hny</code>)
However, when we run
the new queue code through the test in <a href='#sec-97'>Figure 13.2</a>, Harmony
reports a safety violation (even without specifying a behavior).
<a href='#sec-106'>Figure 14.2</a> shows the command line to reproduce this and
the first few lines of markdown output.<p>Before we go look at the details of what went wrong, we want to make
sure that we generate the simplest scenario.  So, first we want to explore
what the smallest <var>NOPS</var> (number of operations or number of
threads) that causes the bug to occur.  With some experimentation,
we find that <var>NOPS</var> = 2 does not find a problem, but
<var>NOPS</var> = 3 does
(<code>harmony -m queue=queue_broken -c NOPS=3 code/queue_btest1.hny</code>)).
<a href='#sec-107'>Figure 14.3</a> shows the HTML output.<p>There is quite a bit of information in the HTML output, and while
it may seem intimidating, we have to learn to navigate through it
step-by-step.
Let's start with looking at the red text.  Harmony found a safety
violation (something bad happened during one of the possible executions),
and in particular <var>thread</var>(2) (thread T2) was trying to dereference
the address ?<var>alloc</var>$<i>pool</i>[0]["lock"].<p>The <var>alloc</var> module maintains a shared array <i>pool</i> that
it uses for dynamic allocation.  Apparently T2 tried to access
<i>pool</i>[0], but it does not exist, meaning that either it was not
yet allocated, or it had been freed since it was allocated.
When we look at the top half of the figure, we see that in fact thread
T1 allocated <i>pool</i>[0] in turn 2, but T3 freed it in turn 4.
Looking back down, we see that T1 executed <var>thread</var>(1) and has
since terminated, while T3 is executing <var>thread</var>(3).<p>Looking further at the stack traces, we can see that
T3 was in the process of executing
<var>release</var>(?<i>q.lock</i>) within <var>get</var>(?<i>q</i>).
T1 is currently executing <var>acquire</var>(?<var>alloc.pool</var>[0].<i>lock</i>)
within <var>put</var>(?<i>q</i>, 2), but 
<var>alloc.pool</var>[0] does not exist.
The corresponding line of Harmony code is
<b>atomically</b> <b>when</b> <b>not</b> !<i>binsema</i>
in line 25 of the <code>sync</code> module.<p>So, how did we get there?  In the top we can see that the order of
events was the following:
<ol><li style="list-style-type:none;">0: initialization completed, with <i>q</i> being
{ .<i>lock</i>: <b>False</b>, .<i>next</i>: <b>None</b>, .<i>value</i>: <b>None</b> };
<li style="list-style-type:none;">1: thread T1 (<var>thread</var>(1)) ran and finished executing
<var>put</var>(1) (see the output column for that clue: the thread printed that).
We can see that <i>q.next</i> now points to <var>alloc.pool</var>[0],
which the thread must have allocated.  The contents is 
{ .<i>lock</i>: <b>False</b>, .<i>next</i>: <b>None</b>, .<i>value</i>: 1 }, as expected;
<li style="list-style-type:none;">2: thread T2 (<var>thread</var>(1)) started running, calling
<var>put</var>(?<i>q</i>, 2).  We can see it got as far as putting 2 on the queue,
but it is not yet done.  It is currently trying to acquire
<var>alloc.pool</var>[0].<i>lock</i>;
<li style="list-style-type:none;">3: thread T3 (<var>thread</var>(1)) started running, calling
<var>get</var>(?<i>q</i>).  We can also see that it freed <i>pool</i>[0],
and is now releasing <i>q.lock</i>;
<li style="list-style-type:none;">4: thread T2 resumes and tries to access <i>pool</i>[0], which
no longer exists (because T3 just freed it).
</ol>

Clearly there was a race in which T2 was trying to lock
<i>pool</i>[0].<i>lock</i> (which contained the node with the value 1)
while T3 was freeing that very same node, and T2 lost the race.
More precisely, T2 was executing <var>put</var>(?<i>q</i>, 2), when T3
preempted it with <var>get</var>(?<i>q</i>) and removed the node that T2
was trying to access.  But why did the locks not prevent this?<p><a id="index:reserve-debugging:1"></a>
It is time to start stepping through the code that has been executed
before this happened.  This is sometimes known as
<i>reverse debugging</i>.  In fact, Harmony allows you to step through
an execution forwards and backwards.
In this case, we first want to see what
T2 is doing.  You can click on its first (top-left) orange box to
time-travel to that part in the execution.
Now by hitting  <span 
class="cmsy-10">&#x27E8;</span><span 
class="cmtt-10">return</span><span 
class="cmsy-10">&#x27E9; </span> repeatedly,
we can quickly skip through the code.
T2 first calls <var>put</var>(?<i>q</i>, 1) and then allocates a new
node initialized with a lock.  Keep stepping until it executes <i>nq</i> = <i>q</i>.
Hit  <span 
class="cmsy-10">&#x27E8;</span><span 
class="cmtt-10">return</span><span 
class="cmsy-10">&#x27E9; </span> once more and inspect the
state of T2 in the lower-right corner.  You can see that variable
<i>nq</i> is initialized to ?<i>q</i>.  T2 then enters into the
<b>while</b> loop and tries to acquire <i>nq</i>-&gt;<i>lock</i>.
This succeeds, and next T2 executes <b>let</b> <i>n</i> = <i>nq</i>-&gt;<i>next</i>.
Now <i>n</i> = ?<var>alloc.pool</var>[0], which is not <b>None</b>.
It then releases <i>nq</i>-&gt;<i>lock</i>
(<i>nq</i> points to <i>q</i>).  It then sets <i>nq</i> to <i>n</i>, which
is still <var>alloc.pool</var>[0].  Finally, it calls <var>acquire</var>(?<i>nq</i>-&gt;<i>lock</i>).
But before it can complete that operation, T3 runs next.<p>T3 chooses "get" and then goes on to invoke <var>get</var>(?<i>q</i>).
This first successfully acquires <i>q</i>}-&gt;<i>lock</i>.
T3 then finds out that <i>q</i>-&gt;<i>next</i> points to <var>alloc.pool</var>[0].
T3 sets <i>node</i> to <var>alloc.pool</var>[0] as well and sets
<i>q</i>-&gt;<i>next</i> to <i>node</i>-&gt;<i>next</i>.
T3 sets the method result <i>next</i> to <i>node</i>-&gt;<i>value</i> (which is 1)
and then frees <i>node</i>.  This is where the problem is---T2 is
about to acquire the lock in that same node.<p>To fix the code without changing the data structure, we can use
hand-over-hand locking (<a href='#sec-88'>Chapter 12</a>).
<a href='#sec-108'>Figure 14.4</a> shows an implementation
that uses hand-over-hand locking
both for <var>put</var>() and for <var>get</var>().  It passes all tests.<p><div id='sec-108'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>
<b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>, <var>free</var>

<b>def</b> <var>Queue</var>() <b>returns</b> <var>empty</var>:
    <var>empty</var> = { .<i>next</i>: <b>None</b>, .<i>value</i>: <b>None</b>, .<i>lock</i>: <var>Lock</var>() }

<b>def</b> <var>put</var>(<i>q</i>, <i>v</i>):
    <b>var</b> <i>nq</i> = <i>q</i>
    <b>let</b> <i>node</i> = <var>malloc</var>({ .<i>next</i>: <b>None</b>, .<i>value</i>: <i>v</i>, .<i>lock</i>: <var>Lock</var>() }):
        <var>acquire</var>(?<i>nq</i>-&gt;<i>lock</i>)
        <b>var</b> <i>n</i> = <i>nq</i>-&gt;<i>next</i>
        <b>while</b> <i>n</i> != <b>None</b>:
            <var>acquire</var>(?<i>n</i>-&gt;<i>lock</i>)
            <var>release</var>(?<i>nq</i>-&gt;<i>lock</i>)
            <i>nq</i> = <i>n</i>
            <i>n</i> = <i>n</i>-&gt;<i>next</i>
        <i>nq</i>-&gt;<i>next</i> = <i>node</i>
        <var>release</var>(?<i>nq</i>-&gt;<i>lock</i>)

<b>def</b> <var>get</var>(<i>q</i>) <b>returns</b> <i>next</i>:
    <var>acquire</var>(?<i>q</i>-&gt;<i>lock</i>)
    <b>if</b> <i>q</i>-&gt;<i>next</i> == <b>None</b>:
        <i>next</i> = <b>None</b>
    <b>else</b>:
        <b>let</b> <i>node</i> = <i>q</i>-&gt;<i>next</i>:
            <var>acquire</var>(?<i>node</i>-&gt;<i>lock</i>)
            <i>q</i>-&gt;<i>next</i> = <i>node</i>-&gt;<i>next</i>
            <i>next</i> = <i>node</i>-&gt;<i>value</i>
            <var>release</var>(?<i>node</i>-&gt;<i>lock</i>)
            <var>free</var>(<i>node</i>)
    <var>release</var>(?<i>q</i>-&gt;<i>lock</i>)
</code></pre>

</center>
<h4>Figure 14.4. [<a href='https://harmony.cs.cornell.edu/code/queue_fix.hny'>code/queue_fix.hny</a>] Queue implementation with hand-over-hand locking</h4>


</div>
</div>

<div id='sec-109'>
<h1>Chapter 15. Conditional Waiting</h1>

<p>





<p>Critical sections enable multiple threads
to easily share data structures whose modification
requires multiple steps.
A critical section only allows one thread to execute the code
of the critical section at a time.
Therefore, when a thread arrives at a critical section,
the thread blocks until there is no other thread in the critical section.<p><a id="gls:busy-waiting:1"></a>
<a id="index:busy-waiting:1"></a>
Sometimes it is useful for a thread to block waiting for additional
conditions.
For example, when dequeuing from an empty shared queue,
it may be useful for the thread to block until the queue is non-empty
instead of returning an error.
The alternative would be <i>busy waiting</i> (aka <i>spin-waiting</i>),
where the thread repeatedly tries to dequeue an item until it is successful.
Doing so wastes CPU cycles and adds contention to queue access.
A thread that is busy waiting until the queue is non-empty cannot
make progress until another thread enqueues an item.
However, the thread is not considered blocked because it is
changing the shared state by repeatedly acquiring and releasing the
lock.
A process that is waiting for a condition without changing the state
(like in a spinlock) is <i>blocked</i>.
A process that is waiting for a condition while changing the state
(such as repeatedly trying to dequeue an item, which requires
acquiring a lock) is <i>actively busy waiting</i>.<p>We would like to find a solution to <i>conditional waiting</i>
so that a thread blocks until the condition holds---or at least most
of the time.
Before we do so, we will give two classic examples of synchronization
problems that involve conditional waiting: <i>reader/writer locks</i>
and <i>bounded buffers</i>.<p><div id='sec-110'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>RWlock</var>() <b>returns</b> <i>lock</i>:
    <i>lock</i> = { .<i>nreaders</i>: 0, .<i>nwriters</i>: 0 }

<b>def</b> <var>read_acquire</var>(<i>rw</i>):
    <b>atomically</b> <b>when</b> <i>rw</i>-&gt;<i>nwriters</i> == 0:
        <i>rw</i>-&gt;<i>nreaders</i> += 1

<b>def</b> <var>read_release</var>(<i>rw</i>):
    <b>atomically</b> <i>rw</i>-&gt;<i>nreaders</i> -= 1

<b>def</b> <var>write_acquire</var>(<i>rw</i>):
    <b>atomically</b> <b>when</b> (<i>rw</i>-&gt;<i>nreaders</i> + <i>rw</i>-&gt;<i>nwriters</i>) == 0:
        <i>rw</i>-&gt;<i>nwriters</i> = 1

<b>def</b> <var>write_release</var>(<i>rw</i>):
    <b>atomically</b> <i>rw</i>-&gt;<i>nwriters</i> = 0
</code></pre>

</center>
<h4>Figure 15.1. [<a href='https://harmony.cs.cornell.edu/code/rwlock.hny'>code/rwlock.hny</a>] Specification of reader/writer locks</h4>


</div>

<div id='sec-111'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <i>rwlock</i>

<i>nreaders</i> = <i>nwriters</i> = 0
<b>invariant</b> ((<i>nreaders</i> &gt;= 0) <b>and</b> (<i>nwriters</i> == 0)) <b>or</b>
            ((<i>nreaders</i> == 0) <b>and</b> (0 &lt;= <i>nwriters</i> &lt;= 1))

<b>const</b> <var>NOPS</var> = 3

<i>rw</i> = <i>rwlock.RWlock</i>()

<b>def</b> <var>thread</var>():
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <b>if</b> <b>choose</b>({ "read", "write" }) == "read":
            <i>rwlock.read_acquire</i>(?<i>rw</i>)
            <b>atomically</b> <i>nreaders</i> += 1
            <b>atomically</b> <i>nreaders</i> -= 1
            <i>rwlock.read_release</i>(?<i>rw</i>)
        <b>else</b>:                       <i># write</i>
            <i>rwlock.write_acquire</i>(?<i>rw</i>)
            <b>atomically</b> <i>nwriters</i> += 1
            <b>atomically</b> <i>nwriters</i> -= 1
            <i>rwlock.write_release</i>(?<i>rw</i>)

<b>for</b> <i>i</i> <b>in</b> {1..NOPS}:
    <b>spawn</b> <var>thread</var>()
</code></pre>

</center>
<h4>Figure 15.2. [<a href='https://harmony.cs.cornell.edu/code/rwlock_test1.hny'>code/rwlock_test1.hny</a>] Test code for reader/writer locks</h4>


</div>

<div id='sec-112'>
<h2>Section 15.1. Reader/Writer Locks</h2>

<a id="index:reader/writer-lock:1"></a>
<a id="gls:reader/writer-lock:1"></a><p>Locks are useful when accessing a shared data structure.  By preventing
more than one thread from accessing the data structure at the same
time, conflicting accesses are avoided.  However, not all concurrent
accesses conflict, and opportunities for concurrency may be lost,
hurting performance.  One important case is when multiple threads
are simply reading the data structure.
In many applications, reads are the majority of all accesses,
and read operations do not conflict with one another.
Allowing reads to proceed concurrently can significantly improve performance.<p>What we want is a special kind of lock that allows either (i) one writer
or (ii) one or more readers to acquire the lock.  This is called
a <i>reader/writer lock</i> [<a href="#cite-CHP71">11</a>].
A reader/writer lock is an object whose abstract (and opaque)
state contains two integer counters (see <a href='#sec-110'>Figure 15.1</a>):
<ol><li> <i>nreaders</i>: the number of readers
<li> <i>nwriters</i>: the number of writers
</ol>
satisfying the following invariant:
<ul><li> 
(<span 
class="cmti-10">nreaders</span> <span 
class="cmsy-10">&#x2265; </span>0 <span 
class="cmsy-10">&#x2227;</span> <span 
class="cmti-10">nwriters</span> = 0) <span 
class="cmsy-10">&#x2228; </span>(<span 
class="cmti-10">nreaders</span> = 0 <span 
class="cmsy-10">&#x2227; </span>0 <span 
class="cmsy-10">&#x2264;</span> <span 
class="cmti-10">nwriters</span> <span 
class="cmsy-10">&#x2264; </span>1) 
</ul>

There are four operations on a reader/writer lock <i>rw</i>:
<ul><li> <var>read_acquire</var>(<i>rw</i>): waits until <i>nwriters</i> = 0
and then increments <i>nreaders</i>;
<li> <var>read_release</var>(<i>rw</i>): decrements <i>nreaders</i>;
<li> <var>write_acquire</var>(<i>rw</i>): waits until <i>nreaders</i> = <i>nwriters</i> = 0
and then sets <i>nwriters</i> to 1;
<li> <var>write_release</var>(<i>rw</i>): sets <i>nwriters</i> to 0.
</ul>

<a href='#sec-111'>Figure 15.2</a> shows how reader/writer locks operations
may be tested.
Similar to ordinary locks, a thread is restricted in how it is allowed to
invoke these operations.
In particular, a thread can only release a reader/writer lock for reading
if it acquired the lock for reading and the same for writing.<p><div id='sec-113'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>synch</var>

<b>def</b> <var>RWlock</var>() <b>returns</b> <i>lock</i>:
    <i>lock</i> = <var>synch.Lock</var>()

<b>def</b> <var>read_acquire</var>(<i>rw</i>):
    <var>synch.acquire</var>(<i>rw</i>)

<b>def</b> <var>read_release</var>(<i>rw</i>):
    <var>synch.release</var>(<i>rw</i>)

<b>def</b> <var>write_acquire</var>(<i>rw</i>):
    <var>synch.acquire</var>(<i>rw</i>)

<b>def</b> <var>write_release</var>(<i>rw</i>):
    <var>synch.release</var>(<i>rw</i>)
</code></pre>

</center>
<h4>Figure 15.3. [<a href='https://harmony.cs.cornell.edu/code/rwlock_cheat.hny'>code/rwlock_cheat.hny</a>] "Cheating" reader/writer lock</h4>


</div>

<div id='sec-114'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <i>rwlock</i>

<b>const</b> <var>NOPS</var> = 3

<i>rw</i> = <i>rwlock.RWlock</i>()

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
        <b>if</b> <b>choose</b>({ "read", "write" }) == "read":
            <b>print</b>(<i>self</i>, "enter ra")
            <i>rwlock.read_acquire</i>(?<i>rw</i>)
            <b>print</b>(<i>self</i>, "exit ra")

            <b>print</b>(<i>self</i>, "enter rr")
            <i>rwlock.read_release</i>(?<i>rw</i>)
            <b>print</b>(<i>self</i>, "exit rr")
        <b>else</b>:                       <i># write</i>
            <b>print</b>(<i>self</i>, "enter wa")
            <i>rwlock.write_acquire</i>(?<i>rw</i>)
            <b>print</b>(<i>self</i>, "exit wa")

            <b>print</b>(<i>self</i>, "enter wr")
            <i>rwlock.write_release</i>(?<i>rw</i>)
            <b>print</b>(<i>self</i>, "enter wr")

<b>for</b> <i>i</i> <b>in</b> {1..NOPS}:
    <b>spawn</b> <var>thread</var>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 15.4. [<a href='https://harmony.cs.cornell.edu/code/rwlock_btest.hny'>code/rwlock_btest.hny</a>] A behavioral test of reader/writer locks</h4>


</div>

<div id='sec-115'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>

<b>def</b> <var>RWlock</var>() <b>returns</b> <i>lock</i>:
    <i>lock</i> = { .<i>lock</i>: <var>Lock</var>(), .<i>nreaders</i>: 0, .<i>nwriters</i>: 0 }

<b>def</b> <var>read_acquire</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>lock</i>)
    <b>while</b> <i>rw</i>-&gt;<i>nwriters</i> &gt; 0:
        <var>release</var>(?<i>rw</i>-&gt;<i>lock</i>)
        <var>acquire</var>(?<i>rw</i>-&gt;<i>lock</i>)
    <i>rw</i>-&gt;<i>nreaders</i> += 1
    <var>release</var>(?<i>rw</i>-&gt;<i>lock</i>)

<b>def</b> <var>read_release</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>lock</i>)
    <i>rw</i>-&gt;<i>nreaders</i> -= 1
    <var>release</var>(?<i>rw</i>-&gt;<i>lock</i>)

<b>def</b> <var>write_acquire</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>lock</i>)
    <b>while</b> (<i>rw</i>-&gt;<i>nreaders</i> + <i>rw</i>-&gt;<i>nwriters</i>) &gt; 0:
        <var>release</var>(?<i>rw</i>-&gt;<i>lock</i>)
        <var>acquire</var>(?<i>rw</i>-&gt;<i>lock</i>)
    <i>rw</i>-&gt;<i>nwriters</i> = 1
    <var>release</var>(?<i>rw</i>-&gt;<i>lock</i>)

<b>def</b> <var>write_release</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>lock</i>)
    <i>rw</i>-&gt;<i>nwriters</i> = 0
    <var>release</var>(?<i>rw</i>-&gt;<i>lock</i>)
</code></pre>

</center>
<h4>Figure 15.5. [<a href='https://harmony.cs.cornell.edu/code/rwlock_busy.hny'>code/rwlock_busy.hny</a>] Busy waiting reader/writer lock</h4>


</div>

A problem with this test is that it does not find a problem
with an implementation like the one in <a href='#sec-113'>Figure 15.3</a>.
This implementation implements a reader/writer lock as an ordinary
lock, and thus lets only one thread in the critical section at a time.
In some sense, the implementation is correct because it satisfies
the requirements, but it is clearly not a desirable implementation.
For a case like this one, it is better to compare behaviors between
the specification and the implementation.<p><a href='#sec-114'>Figure 15.4</a> is the same test as <a href='#sec-111'>Figure 15.2</a> but
prints identifying information before and every lock operation.
Now we can compare behaviors as follows:<p><center><pre><code class="language-none">$ harmony -o rw.hfa -cNOPS=2 code/rwlock_btest.hny
$ harmony -B rw.hfa -cNOPS=2 -m rwlock=rwlock_cheat code/rwlock_btest.hny
</code></pre>
</center>

The second command will print a warning that there are behaviors in the
specification that are not achieved by the implementation.<p><a href='#sec-115'>Figure 15.5</a> illustrates an implementation of a reader/writer lock
that uses active busy waiting.  This is an undesirable solution, as it wastes
CPU cycles.  Harmony complains about this solution.
</div>

<div id='sec-116'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>BoundedBuffer</var>(<var>size</var>) <b>returns</b> <i>buffer</i>:
    <i>buffer</i> = { .<i>buffer</i>: [], .<i>size</i>: <var>size</var> }

<b>def</b> <var>put</var>(<i>bb</i>, <i>v</i>):
    <b>atomically</b> <b>when</b> <b>len</b>(<i>bb</i>-&gt;<i>buffer</i>) &lt; <i>bb</i>-&gt;<i>size</i>:
        <i>bb</i>-&gt;<i>buffer</i> += [<i>v</i>,]

<b>def</b> <var>get</var>(<i>bb</i>) <b>returns</b> <i>next</i>:
    <b>atomically</b> <b>when</b> <i>bb</i>-&gt;<i>buffer</i> != []:
        <i>next</i> = <i>bb</i>-&gt;<i>buffer</i>[0]
        <b>del</b> <i>bb</i>-&gt;<i>buffer</i>[0]
</code></pre>

</center>
<h4>Figure 15.6. [<a href='https://harmony.cs.cornell.edu/code/boundedbuffer.hny'>code/boundedbuffer.hny</a>] Bounded buffer specification</h4>


</div>

<div id='sec-117'>
<h2>Section 15.2. Bounded Buffer</h2>

<a id="index:bounded-buffer:1"></a>
<a id="index:producer/consumer-problem:1"></a>
<a id="gls:producer/consumer-problem:1"></a><p>A <i>bounded buffer</i> is
a queue with the usual <code>put/get</code> interface,
but implemented using a buffer
of a certain maximum length.
If the buffer is full, an enqueuer must wait; if the buffer is empty,
a dequeuer must wait.
<a href='#sec-116'>Figure 15.6</a> specifies a bounded buffer.
It is similar to the implementation in <a href='#sec-79'>Figure 11.1</a>(b) but adds
checking for bounds.
Coming up with a good implementation is known as the
&quot;Producer/Consumer Problem&quot; and was
proposed by Dijkstra [<a href="#cite-EWD329">17</a>].
Multiple producers and multiple consumers may all share
the same bounded buffer.<p>The producer/consumer pattern is common.  Threads may be arranged
in <i>pipelines</i>,
<a id="index:pipeline:1"></a>
where each upstream thread is a producer and each downstream
thread is a consumer.
Or threads may be arranged in a manager/worker pattern, with a manager
producing jobs and workers consuming and executing them in parallel.
Or, in the client/server model,
<a id="index:client/server-model:1"></a>
some thread may act as a <i>server</i> that clients can send requests to
and receive responses from.  In that case, there is a bounded buffer
for each client/server pair. Clients produce requests and
consume responses, while the server consumes requests and produces responses.<p><a id="index:flow-control:1"></a>
Unlike an ordinary queue, where queues can grow arbitrarily, bounded buffers
provide <i>flow control</i>: if the consumer runs faster than the producer
(or producers), it will automatically block until there are new requests.
Similarly, if the producers add requests at a rate that is higher than the
consumers can deal with, the producers are blocked.  While a buffer of size 1
already provides those properties, a larger buffer is able to deal with short
spikes without blocking anybody.
</div>
</div>

<div id='sec-118'>
<h1>Chapter 16. Split Binary Semaphores</h1>


<a id="index:split-binary-semaphore:1"></a><p><p><div id='sec-119'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>BinSema</var>, <var>acquire</var>, <var>release</var>

<b>def</b> <var>RWlock</var>() <b>returns</b> <i>lock</i>:
    <i>lock</i> = {
            .<i>nreaders</i>: 0, .<i>nwriters</i>: 0, .<i>mutex</i>: <var>BinSema</var>(<b>False</b>),
            .<i>r_gate</i>: { .<i>sema</i>: <var>BinSema</var>(<b>True</b>), .<i>count</i>: 0 },
            .<i>w_gate</i>: { .<i>sema</i>: <var>BinSema</var>(<b>True</b>), .<i>count</i>: 0 }
        }

<b>def</b> <var>_release_one</var>(<i>rw</i>):
    <b>if</b> (<i>rw</i>-&gt;<i>nwriters</i> == 0) <b>and</b> (<i>rw</i>-&gt;<i>r_gate</i>.<i>count</i> &gt; 0):
        <var>release</var>(?<i>rw</i>-&gt;<i>r_gate</i>.<i>sema</i>)
    <b>elif</b> ((<i>rw</i>-&gt;<i>nreaders</i> + <i>rw</i>-&gt;<i>nwriters</i>) == 0) <b>and</b> (<i>rw</i>-&gt;<i>w_gate</i>.<i>count</i> &gt; 0):
        <var>release</var>(?<i>rw</i>-&gt;<i>w_gate</i>.<i>sema</i>)
    <b>else</b>:
        <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)

<b>def</b> <var>read_acquire</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <b>if</b> <i>rw</i>-&gt;<i>nwriters</i> &gt; 0:
        <i>rw</i>-&gt;<i>r_gate</i>.<i>count</i> += 1; <var>_release_one</var>(<i>rw</i>)
        <var>acquire</var>(?<i>rw</i>-&gt;<i>r_gate</i>.<i>sema</i>); <i>rw</i>-&gt;<i>r_gate</i>.<i>count</i> -= 1
    <i>rw</i>-&gt;<i>nreaders</i> += 1
    <var>_release_one</var>(<i>rw</i>)

<b>def</b> <var>read_release</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>); <i>rw</i>-&gt;<i>nreaders</i> -= 1; <var>_release_one</var>(<i>rw</i>)

<b>def</b> <var>write_acquire</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <b>if</b> (<i>rw</i>-&gt;<i>nreaders</i> + <i>rw</i>-&gt;<i>nwriters</i>) &gt; 0:
        <i>rw</i>-&gt;<i>w_gate</i>.<i>count</i> += 1; <var>_release_one</var>(<i>rw</i>)
        <var>acquire</var>(?<i>rw</i>-&gt;<i>w_gate</i>.<i>sema</i>); <i>rw</i>-&gt;<i>w_gate</i>.<i>count</i> -= 1
    <i>rw</i>-&gt;<i>nwriters</i> += 1
    <var>_release_one</var>(<i>rw</i>)

<b>def</b> <var>write_release</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>); <i>rw</i>-&gt;<i>nwriters</i> -= 1; <var>_release_one</var>(<i>rw</i>)
</code></pre>

</center>
<h4>Figure 16.1. [<a href='https://harmony.cs.cornell.edu/code/rwlock_sbs.hny'>code/rwlock_sbs.hny</a>] Reader/Writer Lock using Split Binary Semaphores</h4>


</div>

<a id="gls:conditional-critical-section:1"></a>
<a id="gls:semaphore:1"></a><p>The Split Binary Semaphore (SBS) approach is a general technique for
implementing conditional waiting.  It was originally proposed by
Tony Hoare and popularized by Edsger Dijkstra [<a href="#cite-EWD703">18</a>].
A <i>binary semaphore</i> is a generalization of a lock.  While a lock
is always initialized in the released state, a binary semaphore---if so
desired---can be initialized in the acquired state.
SBS is an extension of a critical section that is protected by a lock.
If there are <i>n</i> <i>waiting conditions</i>,
then SBS uses  <span 
class="cmmi-10">n </span>+ 1  binary semaphores to protect the critical section.
An ordinary critical section has no waiting conditions and therefore
uses just one binary semaphore (because  <span 
class="cmmi-10">n </span>= 0 ).
But, for example, a bounded buffer has two waiting conditions:
<ol><li> consumers waiting for the buffer to be non-empty;
<li> producers waiting for an empty slot in the buffer.
</ol>
So, it will require 3 binary semaphores if the SBS technique is applied.<p>Think of each of these binary semaphores as a gate that a thread must go
through in order to enter the critical section.  A gate is either open
or closed.  Initially, exactly one gate, the main gate, is open.
Each of the other gates, the <i>waiting gates</i>, is associated with a
waiting condition.
When a gate is open, one thread can enter the critical section,
closing the gate behind it.<p>When leaving the critical section, the thread must open exactly one
of the gates, but it does not have to be the gate that it used to enter
the critical section.
In particular, when a thread leaves the critical section, it should
check for each waiting gate if its waiting condition holds and if there are
threads trying to get through the gate.  If there is such a gate, then
it must select one and open that gate.  If there is no such gate, then
it must open the main gate.<p>Finally, if a thread is executing in the critical section and needs to
wait for a particular condition, then it leaves the critical section and
waits for the gate associated with that condition to open.<p>The following invariants hold:
<ul><li> At any time, at most one gate is open;
<li> If some gate is open, then no thread is in the critical section.  Equivalently, if some thread is in the critical section, then all gates are closed;
<li> At any time, at most one thread is in the critical section.
</ul>

The main gate is implemented by a binary semaphore, initialized in the
released state (signifying that the gate is open).
The waiting gates each consist of a pair: a counter that counts how many
threads are waiting behind the gate and a binary semaphore initialized
in the acquired state (signifying that the gate is closed).<p>We will illustrate the technique using the reader/writer problem.
<a href='#sec-119'>Figure 16.1</a> shows code.
The first step is to enumerate all waiting conditions.
In the case of the reader/writer
problem, there are two: a thread that wants to read may have to wait for a
writer to leave the critical section, while a thread that wants to write may
have to wait until all readers have left the critical section or until a writer has left.
The state of a reader/writer lock thus consists of the following:
<ul><li> <i>nreaders</i>: the number of readers in the critical section;
<li> <i>nwriters</i>: the number of writers in the critical section (0 or 1);
<li> <i>mutex</i>: the main gate binary semaphore;
<li> <i>r_gate</i>: the waiting gate used by readers, consisting of a binary semaphore and the number of readers waiting to enter;
<li> <i>w_gate</i>: the waiting gate used by writers, similar to the readers' gate.
</ul>

Each of the
<var>read_acquire</var>, <var>read_release</var>,
<var>write_acquire</var>, and <var>write_release</var> methods must maintain
this state.
First they have to acquire the <i>mutex</i>
(i.e., enter the main gate).
After acquiring the <i>mutex</i>,
<var>read_acquire</var> and <var>write_acquire</var> each must check to see
if the thread has to wait.
If so, it increments the count associated with its respective gate,
opens a gate (using method <code>release_one</code>), and then blocks until
its waiting gate opens up.<p><var>_release_one</var>() is the function that a thread uses when leaving
the critical section.  It must check to see if there is a waiting gate
that has threads waiting behind it and whose condition is met.
If so, it selects one and opens that gate.  In the given code,
<var>_release_one</var>() first checks the readers' gate and then the
writers' gate, but the other way around works as well.
If neither waiting gate qualifies, then <var>_release_one</var>() 
has to open the main gate (i.e., release <i>mutex</i>).<p>Let us examine <var>read_acquire</var> more carefully.
First, the method acquires <i>mutex</i>.
Then, in the case that the thread
finds that there is a writer in the critical section
(
<span 
class="cmti-10">nwriters </span><span 
class="cmmi-10">&#x003E; </span><span 
class="cmti-10">0</span> ), it increments the counter associated with
the readers' gate, leaves the critical section (<code>release_one</code>), and
then tries to acquire the binary semaphore associated with the waiting gate.
This causes the thread to block until some other thread opens that gate.<p>Now consider the case where there is a writer in the critical
section and there are two readers waiting.  Let us see what happens when
the writer calls <var>write_release</var>:
<ol><li> After acquiring <i>mutex</i>, the writer decrements
<i>nwriters</i>, which must be 1 at this time, and thus becomes 0.
<li> It then calls <var>_release_one</var>().
<var>_release_one</var>() finds that there are no writers in the critical section
and there are two readers waiting.  It therefore releases not
<i>mutex</i> but the readers' gate's binary semaphore.
<li> One of the waiting readers can now re-enter the critical section.
When it does, the reader decrements the gate's counter (from 2 to 1)
and increments <i>nreaders</i> (from 0 to 1).
The reader finally calls <var>_release_one</var>().
<li> Again, <var>_release_one</var>() finds that there are no writers and
that there are readers waiting, so again it releases the readers' semaphore.
<li> The second reader can now enter the critical section.
It decrements the gate's count from 1 to 0 and increments <i>nreaders</i>
from 1 to 2.
<li> Finally, the second reader  calls <var>_release_one</var>().
This time <var>_release_one</var>() does not find any threads waiting,
and so it releases <i>mutex</i>.
There are now two reader threads that are holding the reader/writer lock.
</ol>








<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-120"><b>[Ex. 16.1]</b>:  Several of the calls to <var>_release_one</var>() in
<a href='#sec-119'>Figure 16.1</a> can be replaced by simply releasing <i>mutex</i>.
Which ones?
<li id="sec-121"><b>[Ex. 16.2]</b>:  Optimize your solutions to <a href='#sec-83'>Exercise 11.1</a> to use reader/writer locks.
<li id="sec-122"><b>[Ex. 16.3]</b>:   Implement a solution to the producer/consumer problem
using split binary semaphores.
<li id="sec-123"><b>[Ex. 16.4]</b>:   Using busy waiting, implement a &quot;bound lock&quot; that allows
up to <var>M</var> threads to acquire it at the same time.[footnote: 
A bound lock is a restricted version of a <i>counting</i> semaphore.]

A bound lock
with <code>M = 1</code> is an ordinary lock.
You should define a constant <var>M</var> and two methods:
<var>acquire_bound_lock</var>() and <var>release_bound_lock</var>().
(Bound locks are useful for situations where too many threads working
at the same time might exhaust some resource such as a cache.)
<li id="sec-124"><b>[Ex. 16.5]</b>:  Write a test program for your bound lock
that checks that no more than <var>M</var> threads can acquire the
bound lock.
<li id="sec-125"><b>[Ex. 16.6]</b>:  Write a test program for bound locks
that checks that up to <var>M</var> threads
can acquire the bound lock at the same time.
<li id="sec-126"><b>[Ex. 16.7]</b>:   Implement a thread-safe <i>GPU allocator</i> by modifying
<a href='#sec-130'>Figure 16.2</a>.
There are <var>N</var> GPUs identified by the numbers
1 through <var>N</var>.  Method <var>gpuAlloc</var>() returns the identifier
of an available GPU, blocking if there is currently no GPU available.
Method <var>gpuRelease</var>(<i>gpu</i>) releases the given GPU.  It never needs
to block.
<li id="sec-127"><b>[Ex. 16.8]</b>:  With reader/writer locks,
concurrency can be improved if a thread <i>downgrades</i> its write lock
to a read lock when its done writing but not done reading.  Add
a <i>downgrade</i> method to the code in <a href='#sec-119'>Figure 16.1</a>.
(Similarly, you may want to try to implement an <i>upgrade</i> of a
read lock to a write lock.  Why is this problematic?)
<li id="sec-128"><b>[Ex. 16.9]</b>:   Cornell's campus features some one-lane bridges.
On a one-lane bridge,
cars can only go in one direction at a time. Consider northbound
and southbound cars wanting to cross a one-lane bridge.
The bridge allows arbitrary many cars, as long as they're going in the
same direction.
Implement a lock that observes this requirement using SBS.
Write methods <code>OLBlock()</code> to create a new &quot;one lane bridge&quot; lock,
<var>nb_enter</var>() that a car must invoke before going northbound on
the bridge and <var>nb_leave</var>() that the car must invoke after leaving
the bridge.  Similarly write <var>sb_enter</var>() and <var>sb_leave</var>()
for southbound cars.
<li id="sec-129"><b>[Ex. 16.10]</b>:  Extend the solution to <a href='#sec-128'>Exercise 16.9</a> by implementing the
requirement that at most <i>n</i> cars are allowed on the bridge.  Add <i>n</i>
as an argument to <code>OLBlock</code>.<p></ul>

<div id='sec-130'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>N</var> = 10

<i>availGPUs</i> = {1..N}

<b>def</b> <var>gpuAlloc</var>() <b>returns</b> <i>gpu</i>:
    <i>gpu</i> = <b>choose</b>(<i>availGPUs</i>)
    <i>availGPUs</i> -= { <i>result</i> }

<b>def</b> <var>gpuRelease</var>(<i>gpu</i>):
    <i>availGPUs</i> |= { <i>gpu</i> }
</code></pre>

</center>
<h4>Figure 16.2. [<a href='https://harmony.cs.cornell.edu/code/gpu.hny'>code/gpu.hny</a>] A thread-unsafe GPU allocator</h4>


</div>
</div>

<div id='sec-131'>
<h1>Chapter 17. Starvation</h1>


<a id="index:starvation:2"></a><p><a id="gls:starvation:1"></a><p><div id='sec-132'>
<center>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>BinSema</var>, <var>acquire</var>, <var>release</var>

<b>def</b> <var>RWlock</var>() <b>returns</b> <i>lock</i>:
    <i>lock</i> = {
            .<i>nreaders</i>: 0, .<i>nwriters</i>: 0, .<i>mutex</i>: <var>BinSema</var>(<b>False</b>),
            .<i>r_gate</i>: { .<i>sema</i>: <var>BinSema</var>(<b>True</b>), .<i>count</i>: 0 },
            .<i>w_gate</i>: { .<i>sema</i>: <var>BinSema</var>(<b>True</b>), .<i>count</i>: 0 }
        }

<b>def</b> <var>read_acquire</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <b>if</b> (<i>rw</i>-&gt;<i>nwriters</i> &gt; 0) <b>or</b> (<i>rw</i>-&gt;<i>w_gate</i>.<i>count</i> &gt; 0):
        <i>rw</i>-&gt;<i>r_gate</i>.<i>count</i> += 1; <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)
        <var>acquire</var>(?<i>rw</i>-&gt;<i>r_gate</i>.<i>sema</i>); <i>rw</i>-&gt;<i>r_gate</i>.<i>count</i> -= 1
    <i>rw</i>-&gt;<i>nreaders</i> += 1
    <b>if</b> <i>rw</i>-&gt;<i>r_gate</i>.<i>count</i> &gt; 0:
        <var>release</var>(?<i>rw</i>-&gt;<i>r_gate</i>.<i>sema</i>)
    <b>else</b>:
        <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)

<b>def</b> <var>read_release</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <i>rw</i>-&gt;<i>nreaders</i> -= 1
    <b>if</b> (<i>rw</i>-&gt;<i>w_gate</i>.<i>count</i> &gt; 0) <b>and</b> (<i>rw</i>-&gt;<i>nreaders</i> == 0):
        <var>release</var>(?<i>rw</i>-&gt;<i>w_gate</i>.<i>sema</i>)
    <b>else</b>:
        <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    
<b>def</b> <var>write_acquire</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <b>if</b> (<i>rw</i>-&gt;<i>nreaders</i> + <i>rw</i>-&gt;<i>nwriters</i>) &gt; 0:
        <i>rw</i>-&gt;<i>w_gate</i>.<i>count</i> += 1; <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)
        <var>acquire</var>(?<i>rw</i>-&gt;<i>w_gate</i>.<i>sema</i>); <i>rw</i>-&gt;<i>w_gate</i>.<i>count</i> -= 1
    <i>rw</i>-&gt;<i>nwriters</i> += 1
    <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)

<b>def</b> <var>write_release</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <i>rw</i>-&gt;<i>nwriters</i> -= 1
    <b>if</b> <i>rw</i>-&gt;<i>r_gate</i>.<i>count</i> &gt; 0:
        <var>release</var>(?<i>rw</i>-&gt;<i>r_gate</i>.<i>sema</i>)
    <b>elif</b> <i>rw</i>-&gt;<i>w_gate</i>.<i>count</i> &gt; 0:
        <var>release</var>(?<i>rw</i>-&gt;<i>w_gate</i>.<i>sema</i>)
    <b>else</b>:
        <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)
</code></pre>


</center>
<h4>Figure 17.1. [<a href='https://harmony.cs.cornell.edu/code/rwlock_fair.hny'>code/rwlock_fair.hny</a>] Reader/Writer Lock SBS implementation addressing fairness</h4>


</div>

<a id="gls:property:1"></a><p>A <i>property</i>
<a id="index:property:1"></a>
is a set of traces.
If a program has a certain property, that means that the traces that that
program allows are a subset of the traces in the property.
So far, we have pursued two properties: <i>mutual exclusion</i>
and <i>progress</i>.  The former is an example of a
<i>safety property</i>---it prevents something &quot;bad&quot; from
happening, like a reader and writer thread both acquiring a
reader/writer lock.
The <i>progress</i> property is an example
of a <i>liveness property</i>---guaranteeing that something good
eventually happens.
Informally (and inexactly), progress states that if no threads
are in the critical section, then some thread that wants to enter
can.<p>Progress is a weak form of liveness.  It says that <i>some</i>
thread can enter, but it does not prevent a scenario such as
the following.  There are three threads repeatedly trying to
enter a critical section using a spinlock.  Two of
the threads successfully keep entering, alternating, but the third
thread never gets a turn.  This is an example of
<i>starvation</i>.  With a spinlock, this scenario could
even happen with two threads.  Initially both threads
try to acquire the spinlock.  One of the threads is
successful and enters.  After the thread leaves, it immediately
tries to re-enter.  This state is identical to the initial
state, and there is nothing that prevents the same thread
from acquiring the lock yet again.<p>Peterson's Algorithm (<a href='#sec-45'>Figure 6.1</a>)
does not suffer from starvation, thanks to the <code>turn</code> variable
that alternates between 0 and 1 when two threads are contending for
the critical section.
Ticket locks (<a href='#sec-69'>Figure 10.2</a>) are also free from starvation.<p>While spinlocks suffer from starvation, it is a uniform random
process and each thread has an equal chance of entering the critical
section.  Thus the probability of starvation is exponentially vanishing.
We shall call such a solution <i>fair</i>
<a id="index:fairness:1"></a>
(although it does not quite
match the usual formal nor vernacular concepts of fairness).<p><a id="gls:fairness:1"></a><p>Unfortunately, such is not the case for the
reader/writer solution that we presented in <a href='#sec-118'>Chapter 16</a>.
Consider this scenario: there are two readers and one writer.  One reader
is in the critical section while the writer is waiting.  Now the
second reader tries to enter and is able to.  The first reader leaves.
We are now in a similar situation as the initial state with one reader
in the critical section and the writer waiting, but it is not the same
reader.  Unfortunately for the writer, this scenario can repeat itself
indefinitely.  So, even if neither reader was in the critical section
all of the time, and the second reader arrived well after the writer,
the writer never had a chance.<p>SBSs allow much control over which type of thread runs next and is therefore
a good starting point for developing fair synchronization algorithms.
<a href='#sec-132'>Figure 17.1</a> is based on <a href='#sec-119'>Figure 16.1</a>, but there
are two important differences:<p><ol><li> When a reader tries to enter the critical section, it yields not only
if there are writers in the critical section, but also if there are writers
waiting to enter the critical section;
<li> Instead of a one-size-fits-all <code>release_one</code> method, each
method has a custom way of selecting which gate to open.  In particular,
<var>read_release</var> prefers the write gate, while <var>write_release</var>
prefers the read gate.
</ol>

The net effect of this is that if there is contention between readers and
writers, then readers and writers end up alternating entering the critical
section.  While readers can still starve other readers and writers can still
starve other writers, readers can no longer starve writers nor vice versa.
Other fairness is based on the fairness of semaphores themselves.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-133"><b>[Ex. 17.1]</b>:  Write a fair solution to the one-lane bridge problem of
<a href='#sec-128'>Exercise 16.9</a>.
</ul>
</div>

<div id='sec-134'>
<h1>Chapter 18. Monitors</h1>

<p>



<p><a id="gls:monitor:1"></a>
<a id="gls:condition-variable:1"></a><p><div id='sec-135'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>synch</var>

<b>def</b> <var>Monitor</var>() <b>returns</b> <i>monitor</i>:
    <i>monitor</i> = <var>synch.Lock</var>()

<b>def</b> <var>enter</var>(<i>mon</i>):
    <var>synch.acquire</var>(<i>mon</i>)

<b>def</b> <var>exit</var>(<i>mon</i>):
    <var>synch.release</var>(<i>mon</i>)

<b>def</b> <var>Condition</var>() <b>returns</b> <i>condition</i>:
    <i>condition</i> = { .<i>sema</i>: <var>synch.BinSema</var>(<b>True</b>), .<i>count</i>: 0 }

<b>def</b> <var>wait</var>(<i>cond</i>, <i>mon</i>):
    <i>cond</i>-&gt;<i>count</i> += 1
    <var>exit</var>(<i>mon</i>)
    <var>synch.acquire</var>(?<i>cond</i>-&gt;<i>sema</i>)
    <i>cond</i>-&gt;<i>count</i> -= 1

<b>def</b> <var>signal</var>(<i>cond</i>, <i>mon</i>):
    <b>if</b> <i>cond</i>-&gt;<i>count</i> &gt; 0:
        <var>synch.release</var>(?<i>cond</i>-&gt;<i>sema</i>)
        <var>enter</var>(<i>mon</i>)
</code></pre>

</center>
<h4>Figure 18.1. [<a href='https://harmony.cs.cornell.edu/modules/hoare.hny'>modules/hoare.hny</a>] Implementation of Hoare monitors</h4>


</div>

<div id='sec-136'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>hoare</var>

<b>def</b> <var>BoundedBuffer</var>(<var>size</var>) <b>returns</b> <i>buffer</i>:
    <i>buffer</i> = {
            .<i>mon</i>: <var>hoare.Monitor</var>(),
            .<i>prod</i>: <var>hoare.Condition</var>(), .<i>cons</i>: <var>hoare.Condition</var>(),
            .<i>buf</i>: { <i>x</i>:() <b>for</b> <i>x</i> <b>in</b> {1..size} },
            .<i>head</i>: 1, .<i>tail</i>: 1,
            .<i>count</i>: 0, .<i>size</i>: <var>size</var>
        }

<b>def</b> <var>Queue</var>() <b>returns</b> <var>empty</var>:
    <var>empty</var> = <var>BoundedBuffer</var>(4)
    
<b>def</b> <var>put</var>(<i>bb</i>, <i>item</i>):
    <var>hoare.enter</var>(?<i>bb</i>-&gt;<i>mon</i>)
    <b>if</b> <i>bb</i>-&gt;<i>count</i> == <i>bb</i>-&gt;<i>size</i>:
        <var>hoare.wait</var>(?<i>bb</i>-&gt;<i>prod</i>, ?<i>bb</i>-&gt;<i>mon</i>)
    <i>bb</i>-&gt;<i>buf</i>[<i>bb</i>-&gt;<i>tail</i>] = <i>item</i>
    <i>bb</i>-&gt;<i>tail</i> = (<i>bb</i>-&gt;<i>tail</i> % <i>bb</i>-&gt;<i>size</i>) + 1
    <i>bb</i>-&gt;<i>count</i> += 1
    <var>hoare.signal</var>(?<i>bb</i>-&gt;<i>cons</i>, ?<i>bb</i>-&gt;<i>mon</i>)
    <var>hoare.exit</var>(?<i>bb</i>-&gt;<i>mon</i>)

<b>def</b> <var>get</var>(<i>bb</i>) <b>returns</b> <i>next</i>:
    <var>hoare.enter</var>(?<i>bb</i>-&gt;<i>mon</i>)
    <b>if</b> <i>bb</i>-&gt;<i>count</i> == 0:
        <var>hoare.wait</var>(?<i>bb</i>-&gt;<i>cons</i>, ?<i>bb</i>-&gt;<i>mon</i>)
    <i>next</i> = <i>bb</i>-&gt;<i>buf</i>[<i>bb</i>-&gt;<i>head</i>]
    <i>bb</i>-&gt;<i>head</i> = (<i>bb</i>-&gt;<i>head</i> % <i>bb</i>-&gt;<i>size</i>) + 1
    <i>bb</i>-&gt;<i>count</i> -= 1
    <var>hoare.signal</var>(?<i>bb</i>-&gt;<i>prod</i>, ?<i>bb</i>-&gt;<i>mon</i>)
    <var>hoare.exit</var>(?<i>bb</i>-&gt;<i>mon</i>)
</code></pre>

</center>
<h4>Figure 18.2. [<a href='https://harmony.cs.cornell.edu/code/boundedbuffer_hoare.hny'>code/boundedbuffer_hoare.hny</a>] Bounded Buffer implemented using
a Hoare monitor</h4>


</div>

Tony Hoare, who came up with the concept of split binary semaphores (SBS),
devised an abstraction of the concept in a programming language paradigm
called <i>monitors</i> [<a href="#cite-Hoare74">25</a>].
<a id="index:monitor:1"></a>
(A similar construct was independently invented by Per Brinch Hansen [<a href="#cite-BH73">6</a>].)
A monitor is a special version of an object-oriented <i>class</i>, comprising
a set of variables and methods that operate on those variables.
A monitor also has special variables called <i>condition variables</i>,
one per waiting condition.
There are two operations on condition variables: <var>wait</var>
<a id="index:wait:1"></a>
and
<var>signal</var>.
<a id="index:signal:1"></a><p>Harmony does not have language support for monitors, but it
has a module called <code>hoare</code>.
<a href='#sec-135'>Figure 18.1</a> shows its implementation.
A Hoare monitor uses a hidden split binary semaphore.
The mutex semaphore is acquired when entering a monitor and released
upon exit.
Each condition variable maintains a binary semaphore and a counter for
the number of threads waiting on the condition.
Method <var>wait</var> increments the condition's counter, releases the monitor mutex,
blocks while trying to acquire the condition's semaphore, and upon resuming
decrements the counter---in much the same way as we have seen for SBS.
Method <var>signal</var> checks to see if the condition's count is non-zero, if so
releases the condition's semaphore,
and then blocks by trying to acquire the mutex again.<p><a href='#sec-136'>Figure 18.2</a> presents a bounded buffer implemented using
Hoare monitors.
It is written in much the same way you would if using
the SBS technique (see <a href='#sec-122'>Exercise 16.3</a>).
However, there is no <code>release_one</code> method.
Instead, one can conclude
that <var>put</var> guarantees that the queue will be non-empty, and
<var>signal</var> will check if there are any threads waiting for
this event.  If so, <var>signal</var> will pass control to one such thread
and, unlike <code>release_one</code>, re-enter the critical
section afterwards by acquiring the <i>mutex</i>.<p>Implementing a reader/writer lock with Hoare monitors is not quite so
straightforward, unfortunately.  When a writer releases the lock, it
has to choose whether to signal a reader or another writer.  For that
it needs to know if there is a reader or writer waiting.  The simplest
solution would be to peek at the counters inside the respective condition
variables, but that breaks the abstraction.  The alternative is for the
reader/writer implementation to keep track of that state explicitly,
which complicates the code.  Also, it requires a deep understanding of
the SBS method to remember to place a call to <var>signal</var> in the
<var>read_acquire</var> method that releases additional readers that
may be waiting to acquire the lock.<p>In the late 70s, researchers at Xerox PARC,
where among others the desktop and Ethernet
were invented, developed a new programming language called
Mesa [<a href="#cite-LR80">32</a>].
<a id="index:Mesa:1"></a>
Mesa introduced various important concepts to programming languages,
including software exceptions and incremental compilation.  Mesa also
incorporated a version of monitors.
However, there are some subtle but important differences with Hoare
monitors that make Mesa monitors quite unlike split binary semaphores
and mostly easier to use in practice.<p>As in Hoare monitors, there is a hidden mutex associated with each Mesa monitor,
and the mutex must be acquired upon entry to a method and released
upon exit.
Mesa monitors also have condition variables that a thread can wait on.
Like in Hoare monitors, the <var>wait</var> operation releases the mutex.
The most important difference is in what <var>signal</var> does.
To make the distinction more clear, we shall call the corresponding Mesa
operation <var>notify</var> rather than <var>signal</var>.
<a id="index:notify:1"></a>
Unlike <var>signal</var>, when a thread <i>p</i> invokes <var>notify</var>
it does not immediately pass 
control to a thread that is waiting on the corresponding condition (if there
is such a thread).  Instead, <i>p</i> continues executing in the critical section
until it leaves the monitor (by calling <var>release</var>) or
releases the monitor (by calling <var>wait</var>).
Either way, any thread that was notified will now have a chance to enter
the critical section, but they compete
with other threads trying to enter the critical section.<p>
Basically, there is just one gate to enter the critical section, instead
of a main gate and a gate per waiting condition.
This is a very important difference.  In Hoare monitors, when a thread
enters through a waiting gate, it can assume that the condition associated
with the waiting gate still holds because no other thread can run in between.
Not so with Mesa monitors: by the time a thread that was notified enters
through the main gate, other threads may have entered first and falsified
the condition.  So, in Mesa, threads always have to check the condition
again after resuming from the <var>wait</var> operation.  This is accomplished
by wrapping each <var>wait</var> operation in a <b>while</b> statement that
loops until the condition of interest becomes valid.
A Mesa monitor therefore is more closely related to busy waiting
than to split binary semaphores.<p>Mesa monitors also allow notifying multiple threads.
For example, a thread can invoke <var>notify</var> twice---if there are
two or more threads waiting on the condition variable, two will be resumed.
Operation <var>notifyAll</var>
<a id="index:notifyAll:1"></a>
(aka <code>broadcast)</code>)
<a id="index:broadcast:1"></a>
notifies <i>all</i> threads that are waiting
on a condition.
Signaling multiple threads is not possible with Hoare monitors because with
Hoare monitors control
must be passed immediately to a thread that has been signaled, and that
can only be done if there is just one such thread.<p>The so-called
&quot;Mesa monitor semantics&quot; or &quot;Mesa condition variable semantics&quot;
have become more popular than Hoare monitor semantics and have been
adopted by all major programming languages.
That said, few programming languages provide full syntactical support
for monitors, instead opting to support monitor semantics through library
calls.
In Java, each object has a hidden lock <i>and</i> a hidden condition variable
associated with it.
Methods declared with the <code>synchronized</code> keyword automatically
obtain the lock.  Java objects also support <var>wait</var>, <var>notify</var>,
and <var>notifyAll</var>.
In addition, Java supports explicit allocations of locks
and condition variables.
In Python, locks and condition variables must be explicitly declared.
The <code>with</code> statement makes it easy to acquire and release a lock
for a section of code.
In C and C++, support for locks and condition variables is entirely
through libraries.<p>
<div id='sec-137'>
<center>



<pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>Condition</var>() <b>returns</b> <i>condition</i>:
    <i>condition</i> = <var>bag.empty</var>()

<b>def</b> <var>wait</var>(<i>c</i>, <i>lk</i>):
    <b>var</b> <i>cnt</i> = 0
    <b>let</b> <var>_</var>, <i>ctx</i> = <b>save</b>():
        <b>atomically</b>:
            <i>cnt</i> = <var>bag.multiplicity</var>(!<i>c</i>, <i>ctx</i>)
            !<i>c</i> = <var>bag.add</var>(!<i>c</i>, <i>ctx</i>)
            !<i>lk</i> = <b>False</b>
        <b>atomically</b> <b>when</b> (<b>not</b> !<i>lk</i>) <b>and</b> (<var>bag.multiplicity</var>(!<i>c</i>, <i>ctx</i>) &lt;= <i>cnt</i>):
            !<i>lk</i> = <b>True</b>

<b>def</b> <var>notify</var>(<i>c</i>):
    <b>atomically</b> <b>if</b> !<i>c</i> != <var>bag.empty</var>():
        !<i>c</i> = <var>bag.remove</var>(!<i>c</i>, <var>bag.bchoose</var>(!<i>c</i>))
        
<b>def</b> <var>notifyAll</var>(<i>c</i>):
    !<i>c</i> = <var>bag.empty</var>()
</code></pre>

</center>
<h4>Figure 18.3. [<a href='https://harmony.cs.cornell.edu/modules/synch.hny'>modules/synch.hny</a>]
Implementation of condition variables in the <var>synch</var> module</h4>


</div>

<div id='sec-138'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> *

<b>def</b> <var>RWlock</var>() <b>returns</b> <i>lock</i>:
    <i>lock</i> = {
            .<i>nreaders</i>: 0, .<i>nwriters</i>: 0, .<i>mutex</i>: <var>Lock</var>(),
            .<i>r_cond</i>: <var>Condition</var>(), .<i>w_cond</i>: <var>Condition</var>()
        }
    
<b>def</b> <var>read_acquire</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <b>while</b> <i>rw</i>-&gt;<i>nwriters</i> &gt; 0:
        <var>wait</var>(?<i>rw</i>-&gt;<i>r_cond</i>, ?<i>rw</i>-&gt;<i>mutex</i>)
    <i>rw</i>-&gt;<i>nreaders</i> += 1
    <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)

<b>def</b> <var>read_release</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <i>rw</i>-&gt;<i>nreaders</i> -= 1
    <b>if</b> <i>rw</i>-&gt;<i>nreaders</i> == 0:
        <var>notify</var>(?<i>rw</i>-&gt;<i>w_cond</i>)
    <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)

<b>def</b> <var>write_acquire</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <b>while</b> (<i>rw</i>-&gt;<i>nreaders</i> + <i>rw</i>-&gt;<i>nwriters</i>) &gt; 0:
        <var>wait</var>(?<i>rw</i>-&gt;<i>w_cond</i>, ?<i>rw</i>-&gt;<i>mutex</i>)
    <i>rw</i>-&gt;<i>nwriters</i> = 1
    <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)

<b>def</b> <var>write_release</var>(<i>rw</i>):
    <var>acquire</var>(?<i>rw</i>-&gt;<i>mutex</i>)
    <i>rw</i>-&gt;<i>nwriters</i> = 0
    <var>notifyAll</var>(?<i>rw</i>-&gt;<i>r_cond</i>)
    <var>notify</var>(?<i>rw</i>-&gt;<i>w_cond</i>)
    <var>release</var>(?<i>rw</i>-&gt;<i>mutex</i>)
</code></pre>

</center>
<h4>Figure 18.4. [<a href='https://harmony.cs.cornell.edu/code/rwlock_cv.hny'>code/rwlock_cv.hny</a>] Reader/Writer Lock using Mesa-style condition variables</h4>


</div>

Harmony provides support for Mesa monitors
through the Harmony <var>synch</var> module.
<a href='#sec-137'>Figure 18.3</a> shows the implementation of
condition variables in the <var>synch</var> module.
<var>Condition</var>() creates a new condition variable.
It is represented by a dictionary containing
a bag of contexts of threads waiting on the condition variable.
(The <var>synchS</var> library instead uses a list of contexts.)<p>In Harmony, a bag is usually represented by a dictionary that maps
the elements of the bag to their multiplicities.
For example, the value { .<i>a</i>: 2, .<i>b</i>: 3 } represents a bag
with two copies of .<i>a</i> and three copies of .<i>b</i>.
The <var>bag</var> module (<a href='#sec-289'>Section B.3</a>) contains a variety of handy
functions on bags.<p>Method <var>wait</var> adds the context of the thread---used as a unique
identifier for the thread---to the bag,
incrementing the number of threads in the bag with the same context.
The Harmony <b>save</b> expression (<a href='#sec-298'>Section C.3</a>) returns a tuple
containing a value (in this case `()') and the context of the thread.
<var>wait</var> then loops until that count is restored to the
value that it had upon entry to <var>wait</var>.
Method <var>notify</var> removes an arbitrary context from
the bag, allowing one of the threads with that context to
resume and re-acquire the lock associated with the monitor.
<var>notifyAll</var> empties out the entire bag, allowing all threads
in the bag to resume.<p>To illustrate how Mesa condition variables are used in practice, we demonstrate using an implementation of reader/writer locks.
<a href='#sec-138'>Figure 18.4</a> shows the code.  <i>mutex</i> is the shared lock
that protects the critical region.
There are two condition variables: readers wait on <i>r_cond</i> and
writers wait on <i>w_cond</i>.
The implementation also keeps track of the number of
readers and writers in the critical section.<p>Note that <var>wait</var> is always invoked within a <b>while</b>
loop that checks for the condition that the thread is waiting for.
It is <i>imperative</i> that there is always a <b>while</b> loop
around any invocation of <var>wait</var> containing the negation of
the condition that the thread is waiting for.  Many implementation
of Mesa condition variables depend on this, and optimized implementations
of condition variables often allow so-called &quot;spurious wakeups,&quot;
where <var>wait</var> may sometimes return even if the conditon
variable has not been notified.
As a rule of thumb, one should always be able to replace <var>wait</var>
by <var>release</var> followed by <var>acquire</var>.
This turns the solution into a busy-waiting one, inefficient but still
correct.<p>In <var>read_release</var>, notice that <var>notify</var>(?<i>w_cond</i>)
is invoked when there are no readers left, <i>without</i> checking
if there are writers waiting to enter.  This is
ok, because calling <var>notify</var> is a no-op if no thread is
waiting.<p><var>write_release</var> executes <var>notifyAll</var>(?<i>r_cond</i>)
as well as <var>notify</var>(?<i>w_cond</i>).  Because we
do not keep track of the number of waiting readers or writers, we
have to conservatively assume that all waiting readers can enter,
or, alternatively, up to one waiting writer can enter.  So
<var>write_release</var> wakes up all potential candidates.  There
are two things to note here.  First, unlike split binary semaphores
or Hoare monitors, where multiple waiting readers would have to be
signaled one at a time in a baton-passing fashion (see
<a href='#sec-119'>Figure 16.1</a>), with Mesa monitors all readers are
awakened in one fell swoop using <var>notifyAll</var>.  Second, both
readers and writers are awakened---this is ok because both execute
<var>wait</var> within a <b>while</b> loop, re-checking the condition
that they are waiting for.  So, if both type of threads are waiting,
either all the readers get to enter next or one of the writers gets
to enter next.  (If you want to prevent waking up both readers and
a writer, then you can keep track of how many threads are waiting
in the code.)<p>When using Mesa condition variables, you have to be careful to invoke
<var>notify</var> or <var>notifyAll</var> in the right places.
Much of the complexity of programming with Mesa condition variables
is in figuring out when to invoke <var>notify</var> and when to invoke
<var>notifyAll</var>.  As a rule of thumb: be conservative---it is
better to wake up too many threads than too few.
In case of doubt, use <var>notifyAll</var>.
Waking up too
many threads may lead to some inefficiency, but waking up too few
may cause the application to get stuck.  Harmony can be particularly
helpful here, as it examines each and every corner case.
You can try to replace each <var>notifyAll</var> with <var>notify</var> and see
if every possible execution of the application still terminates.<p>Andrew Birrell's paper on Programming with Threads gives an excellent
introduction to working with Mesa-style condition variables [<a href="#cite-Birrell89">5</a>].<p>






<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-139"><b>[Ex. 18.1]</b>:   Implement a solution to the bounded buffer problem using Mesa condition
variables.
<li id="sec-140"><b>[Ex. 18.2]</b>:  Implement a &quot;try lock&quot; module using Mesa condition variables
(see also <a href='#sec-74'>Exercise 10.3</a>).  It should
have the following API:
<ol><li> <i>tl</i> = <var>TryLock</var>()      <i># create a try lock</i>
<li> <var>acquire</var>(?<i>tl</i>)        <i># acquire a try lock</i>
<li> <var>tryAcquire</var>(?<i>tl</i>)     <i># attempt to acquire a try lock</i>
<li> <var>release</var>(?<i>tl</i>)        <i># release a try lock</i>
</ol>

<var>tryAcquire</var> should not wait.
Instead it should return <b>True</b> if the lock was successfully
acquired and <b>False</b> if the lock was not available.
<li id="sec-141"><b>[Ex. 18.3]</b>:  Write a new version of the GPU allocator in <a href='#sec-126'>Exercise 16.7</a>
using Mesa condition variables.
In this version,
a thread is allowed to allocate a set of GPUs and release a set of GPUs that it
has allocated.  Method <i>gpuAllocSet</i>(<i>n</i>) should block until <i>n</i> GPUs are
available, but it should grant them as soon as they are available.
It returns a set of <i>n</i> GPU identifiers.
Method <i>gpuReleaseSet</i>(<i>s</i>) takes a set of GPU identifiers as argument.
A thread does not have to return all the GPUs it allocated at once.
(You may want to try implementing this with Split Binary Semaphores.  It is not as easy.)
<li id="sec-142"><b>[Ex. 18.4]</b>:  The specification in the previous question makes the solution unfair.
Explain why this is so.  Then change the specification and the solution so that
it is fair.
<li id="sec-143"><b>[Ex. 18.5]</b>:  
Bonus problem: <a href='#sec-144'>Figure 18.5</a> shows an iterative implementation of the Qsort
algorithm, and <a href='#sec-145'>Figure 18.6</a> an accompanying test program.
The array to be sorted is stored in shared variable <i>testqs.arr</i>.
Another shared variable, <i>testqs.todo</i>, contains the ranges of the
array that need to be sorted (initially the entire array).
Re-using as much of this code as you can, implement a parallel version of
this.  You should not have to change the methods <var>swap</var>, <var>partition</var>,
or <var>sortrange</var> for this.  Create <var>NWORKERS</var> &quot;worker threads&quot;
that should replace the <var>qsort</var> code.
Each worker loops until <i>todo</i>
is empty and sorts the ranges that it finds until then.  The <var>main</var>
thread needs to wait until all workers are done.
</ul>

<div id='sec-144'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>Qsort</var>(<i>arr</i>) <b>returns</b> <i>state</i>:
    <i>state</i> = { .<i>arr</i>: <i>arr</i>, .<i>todo</i>: { (0, <b>len</b>(<i>arr</i>) - 1) } }

<b>def</b> <var>swap</var>(<i>p</i>, <i>q</i>):               <i># swap !p and !q</i>
    !<i>p</i>, !<i>q</i> = !<i>q</i>, !<i>p</i>

<b>def</b> <var>partition</var>(<i>qs</i>, <i>lo</i>, <i>hi</i>) <b>returns</b> <i>pivot</i>:
    <i>pivot</i> = <i>lo</i>
    <b>for</b> <i>i</i> <b>in</b> {<i>lo..hi</i> - 1}:
        <b>if</b> <i>qs</i>-&gt;<i>arr</i>[<i>i</i>] &lt;= <i>qs</i>-&gt;<i>arr</i>[<i>hi</i>]:
            <var>swap</var>(?<i>qs</i>-&gt;<i>arr</i>[<i>pivot</i>], ?<i>qs</i>-&gt;<i>arr</i>[<i>i</i>])
            <i>pivot</i> += 1
    <var>swap</var>(?<i>qs</i>-&gt;<i>arr</i>[<i>pivot</i>], ?<i>qs</i>-&gt;<i>arr</i>[<i>hi</i>])

<b>def</b> <var>sortrange</var>(<i>qs</i>, <i>range</i>):
    <b>let</b> <i>lo</i>, <i>hi</i> = <i>range</i> <b>let</b> <i>pivot</i> = <var>partition</var>(<i>qs</i>, <i>lo</i>, <i>hi</i>):
        <b>if</b> (<i>pivot</i> - 1) &gt; <i>lo</i>:
            <i>qs</i>-&gt;<i>todo</i> |= { (<i>lo</i>, <i>pivot</i> - 1) }
        <b>if</b> (<i>pivot</i> + 1) &lt; <i>hi</i>:
            <i>qs</i>-&gt;<i>todo</i> |= { (<i>pivot</i> + 1, <i>hi</i>) }

<b>def</b> <var>sort</var>(<i>qs</i>) <b>returns</b> <var>sorted</var>:
    <b>while</b> <i>qs</i>-&gt;<i>todo</i> != {}:
        <b>let</b> <i>range</i> = <b>choose</b>(<i>qs</i>-&gt;<i>todo</i>):
            <i>qs</i>-&gt;<i>todo</i> -= { <i>range</i> }
            <var>sortrange</var>(<i>qs</i>, <i>range</i>)
    <var>sorted</var> = <i>qs</i>-&gt;<i>arr</i>
</code></pre>

</center>
<h4>Figure 18.5. [<a href='https://harmony.cs.cornell.edu/code/qsort.hny'>code/qsort.hny</a>] Iterative qsort() implementation</h4>


</div>

<div id='sec-145'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>qsort</var>, <var>bag</var>

<b>const</b> <var>NITEMS</var> = 4

<var>a</var> = [ <b>choose</b>({1..NITEMS}) <b>for</b> <i>i</i> <b>in</b> {1..choose({1..NITEMS})} ]
<i>testqs</i> = <var>qsort.Qsort</var>(<var>a</var>)
<i>sa</i> = <var>qsort.sort</var>(?<i>testqs</i>)
<b>assert</b> <b>all</b>(<i>sa</i>[<i>i</i> - 1] &lt;= <i>sa</i>[<i>i</i>] <b>for</b> <i>i</i> <b>in</b> {1..len(<i>sa</i>)-1}) <i># sorted?</i>
<b>assert</b> <var>bag.fromList</var>(<var>a</var>) == <var>bag.fromList</var>(<i>sa</i>) <i># is it a permutation?</i>
</code></pre>

</center>
<h4>Figure 18.6. [<a href='https://harmony.cs.cornell.edu/code/qsorttest.hny'>code/qsorttest.hny</a>] Test program for <a href='#sec-144'>Figure 18.5</a></h4>


</div>
</div>

<div id='sec-146'>
<h1>Chapter 19. Deadlock</h1>


<a id="index:deadlock:1"></a><p><p><a id="gls:deadlock:1"></a><p><div id='sec-147'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>

<b>const</b> <var>N</var> = 5

<i>forks</i> = [<var>Lock</var>(),] * <var>N</var>

<b>def</b> <var>diner</var>(<i>which</i>):
    <b>let</b> <i>left</i>, <i>right</i> = (<i>which</i>, (<i>which</i> + 1) % <var>N</var>):
        <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
            <var>acquire</var>(?<i>forks</i>[<i>left</i>])
            <var>acquire</var>(?<i>forks</i>[<i>right</i>])
            <i># dine</i>
            <var>release</var>(?<i>forks</i>[<i>left</i>])
            <var>release</var>(?<i>forks</i>[<i>right</i>])
            <i># think</i>

<b>for</b> <i>i</i> <b>in</b> {0..N-1}:
    <b>spawn</b> <var>diner</var>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 19.1. [<a href='https://harmony.cs.cornell.edu/code/Diners.hny'>code/Diners.hny</a>] Dining Philosophers</h4>


</div>

When multiple threads are synchronizing access to shared resources, they
may end up in a <i>deadlock</i> situation where one or more of the threads
end up being blocked indefinitely because each is waiting for another to give
up a resource.
The famous Dutch computer scientist Edsger W. Dijkstra illustrated this using
a scenario he called &quot;Dining Philosophers.&quot;
<a id="index:dining-philosopher:1"></a><p>Imagine five philosopers sitting around a table, each with a plate of food in
front of them and a fork between every two plates.  Each philosopher requires
two forks to eat.  To start eating, a philosopher first picks up the fork on
the left, then the fork on the right.  Each philosopher likes to take breaks
from eating to think for a while.  To do so, the philosopher puts down both
forks.  Each philosopher repeats this procedure.  Dijkstra had them repeating
this for ever, but for the purposes of this book,
philosophers can---if they wish---leave the table when they are
not using any forks.<p><a href='#sec-147'>Figure 19.1</a> implements the dining philosophers in Harmony, using a
thread for each philosopher and a lock for each fork.  If you
run it, Harmony complains that the execution may not be able to terminate,
with all five threads being blocked trying to acquire the lock.<p><blockquote><ul><li> Do you see what the problem is?
<li> Does it depend on <var>N</var>, the number of philosophers?
<li> Does it matter in what order the philosophers lay down their forks?
</ul>
</blockquote>


<div id='sec-148'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>synch</var>

<b>const</b> <var>N</var> = 5

<i>mutex</i> = <var>synch.Lock</var>()
<i>forks</i> = [<b>False</b>,] * <var>N</var>
<i>conds</i> = [<var>synch.Condition</var>(),] * <var>N</var>

<b>def</b> <var>diner</var>(<i>which</i>):
    <b>let</b> <i>left</i>, <i>right</i> = (<i>which</i>, (<i>which</i> + 1) % <var>N</var>):
        <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
            <var>synch.acquire</var>(?<i>mutex</i>)
            <b>while</b> <i>forks</i>[<i>left</i>] <b>or</b> <i>forks</i>[<i>right</i>]:
                <b>if</b> <i>forks</i>[<i>left</i>]:
                    <var>synch.wait</var>(?<i>conds</i>[<i>left</i>], ?<i>mutex</i>)
                <b>if</b> <i>forks</i>[<i>right</i>]:
                    <var>synch.wait</var>(?<i>conds</i>[<i>right</i>], ?<i>mutex</i>)
            <b>assert</b> <b>not</b> (<i>forks</i>[<i>left</i>] <b>or</b> <i>forks</i>[<i>right</i>])
            <i>forks</i>[<i>left</i>] = <i>forks</i>[<i>right</i>] = <b>True</b>
            <var>synch.release</var>(?<i>mutex</i>)
            <i># dine</i>
            <var>synch.acquire</var>(?<i>mutex</i>)
            <i>forks</i>[<i>left</i>] = <i>forks</i>[<i>right</i>] = <b>False</b>
            <var>synch.notify</var>(?<i>conds</i>[<i>left</i>])
            <var>synch.notify</var>(?<i>conds</i>[<i>right</i>])
            <var>synch.release</var>(?<i>mutex</i>)
            <i># think</i>

<b>for</b> <i>i</i> <b>in</b> {0..N-1}:
    <b>spawn</b> <var>diner</var>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 19.2. [<a href='https://harmony.cs.cornell.edu/code/DinersCV.hny'>code/DinersCV.hny</a>] Dining Philosophers that grab both forks at the same time</h4>


</div>


There are four conditions that must hold for deadlock to occur [<a href="#cite-CES71">9</a>]:
<ol><li> <i>Mutual Exclusion</i>: each resource can only be used by one thread at a time:
<li> <i>Hold and Wait</i>: each thread holds resources it already allocated while it
waits for other resources that it needs;
<li> <i>No Preemption</i>: resources cannot be forcibly taken away from threads that
allocated them;
<li> <i>Circular Wait</i>: there exists a directed circular chain of threads, each waiting
to allocate a resource held by the next.
</ol>

Preventing deadlock thus means preventing that one of these conditions occurs.
However, mutual exclusion is not easily prevented in general
(although, for some resources it is
possible, as demonstrated in <a href='#sec-187'>Chapter 24</a>).
Havender proposed the following techniques that avoid the remaining
three conditions [<a href="#cite-Havender68">22</a>]:<p><ul><li> <i>No Hold and Wait</i>: a thread must request all resources it is going to
need at the same time;
<li> <i>Preemption</i>: if a thread is denied a request for a resource, it must
release all resources that it has already acquired and start over;
<li> <i>No Circular Wait</i>: define an ordering on all resources and allocate
resources in a particular order.
</ul>

To implement a <i>No Hold and Wait</i> solution, a philosopher would need a
way to lock both the left and right forks at the same time.  Locks do not
have such an ability, and neither do semaphores. so we re-implement the
Dining Philosophers using condition variables that allow one to wait for
arbitrary application-specific conditions.
<a href='#sec-148'>Figure 19.2</a> demonstrates how this might be done.
We use a single mutex for the diners, and, for each fork, a boolean
and a condition variable.  The boolean indicates if the fork has been
taken.
Each diner waits if either the left or right fork is already taken.
But which condition variable to wait on?
The code demonstrates an important technique to use when waiting for
multiple conditions.
<a id="index:multiple-conditions,-waiting-on:1"></a>
The condition in the <b>while</b> statement is the negation of the
condition that the diner is waiting for and consists of two disjuncts.
Within the <b>while</b> statement,
there is an <b>if</b> statement for each disjunct.
The code waits for either or both forks if necessary.  After that, it goes
back to the top of the <b>while</b> loop.<p>A common mistake is to write the following code instead:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>while</b> <i>forks</i>[<i>left</i>]:
    <var>synch.wait</var>(?<i>conds</i>[<i>left</i>], ?<i>mutex</i>)
<b>while</b> <i>forks</i>[<i>right</i>]:
    <var>synch.wait</var>(?<i>conds</i>[<i>right</i>], ?<i>mutex</i>)
</code></pre>
</center>

<blockquote><ul><li> Can you see why this does not work?  What can go wrong?
<li> Run it through Harmony in case you are not sure!
</ul>
</blockquote>

The <i>Preemption</i> approach suggested by Havender is to allow threads to back out.
While this could be done, this invariably leads to a busy waiting solution
where a thread keeps obtaining locks and releasing them again until it
finally is able to get all of them.<p>The <i>No Circular Waiting</i> approach
is to prevent a cycle from forming, with each
thread waiting for the next thread on the cycle.
We can do this by establishing an ordering among the
resources (in this case the forks) and, when needing more than one
resource, always acquiring them in order.  In the case of the philosopers,
they could prevent deadlock by always picking up the lower numbered fork
before the higher numbered fork, like so:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>if</b> <i>left</i> &lt; <i>right</i>:
    <var>synch.acquire</var>(?<i>forks</i>[<i>left</i>])
    <var>synch.acquire</var>(?<i>forks</i>[<i>right</i>])
<b>else</b>:
    <var>synch.acquire</var>(?<i>forks</i>[<i>right</i>])
    <var>synch.acquire</var>(?<i>forks</i>[<i>left</i>])
</code></pre>
</center>

or like so:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><var>synch.acquire</var>(?<i>forks</i>[<b>min</b>(<i>left</i>, <i>right</i>)])
<var>synch.acquire</var>(?<i>forks</i>[<b>max</b>(<i>left</i>, <i>right</i>)])
</code></pre>
</center>

This completes all the Havender methods.
There is, however, another approach, which is sometimes called deadlock
<i>avoidance</i>
<a id="index:deadlock-avoidance:1"></a>
instead of deadlock <i>prevention</i>.
In the case of the Dining Philosophers, we want to avoid the situation where each
diner picks up a fork.  If we can prevent more than four diners from starting to
eat at the same time, then we can avoid the conditions for deadlock from ever
happening.
<a href='#sec-149'>Figure 19.3</a> demonstrates this concept.  It uses a
<i>counting semaphore</i> to restrict the number of diners at any time to
four.  A counting semaphore is like a binary semaphore, but can be
acquired a given number of times.  It is supported by the <var>synch</var>
module.  The <var>P</var> or &quot;procure&quot; operation acquires a counting
semaphore.  That is, it tries to decrement the semaphore, blocking while
the semaphore has a value of 0.  The <var>V</var> or &quot;vacate&quot; operation
increments the semaphore.<p>This avoidance technique can be generalized using something called the
Banker's Algorithm [<a href="#cite-EWD108">14</a>], but it is outside the scope of this book.
The problem with these kinds of schemes is that one needs to know ahead of time
the set of threads and what the maximum number of resources is that each thread
wants to allocate, making them generally quite impractical.<p><div id='sec-149'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> *

<b>const</b> <var>N</var> = 5

<i>forks</i> = [<var>Lock</var>(),] * <var>N</var>
<i>sema</i> = <var>Semaphore</var>(<var>N</var> - 1)     <i># can be procured up to N-1 times</i>

<b>def</b> <var>diner</var>(<i>which</i>):
    <b>let</b> <i>left</i>, <i>right</i> = (<i>which</i>, (<i>which</i> + 1) % <var>N</var>):
        <b>while</b> <b>choose</b>({ <b>False</b>, <b>True</b> }):
            <var>P</var>(?<i>sema</i>)                <i># procure counting semaphore</i>
            <var>acquire</var>(?<i>forks</i>[<i>left</i>])
            <var>acquire</var>(?<i>forks</i>[<i>right</i>])
            <i># dine</i>
            <var>release</var>(?<i>forks</i>[<i>left</i>])
            <var>release</var>(?<i>forks</i>[<i>right</i>])
            <var>V</var>(?<i>sema</i>)                <i># vacate counting semaphore</i>
            <i># think</i>

<b>for</b> <i>i</i> <b>in</b> {0..N-1}:
    <b>spawn</b> <var>diner</var>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 19.3. [<a href='https://harmony.cs.cornell.edu/code/DinersAvoid.hny'>code/DinersAvoid.hny</a>] Dining Philosophers that carefully avoid getting into a deadlock scenario</h4>


</div>


<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-150"><b>[Ex. 19.1]</b>:  The solution in <a href='#sec-148'>Figure 19.2</a> can be simplified by, instead
of having a condition variable per fork, having a condition variable per
diner.  It uses the same number of condition variables, but you will not
need to have <b>if</b> statements nested inside the <b>while</b> loop
waiting for the forks.  See if you can figure it out.
<li id="sec-151"><b>[Ex. 19.2]</b>:   <a href='#sec-154'>Figure 19.4</a> shows an implementation of a bank with various
accounts and transfers between those accounts.
Unfortunately, running the test reveals that it sometimes leaves unterminated
threads.  Can you fix the problem?
<li id="sec-152"><b>[Ex. 19.3]</b>:  Add a method <var>total</var>() to the solution of the previous question
that computes the total over all balances.
It needs to obtain a lock on all accounts.  Make sure that
it cannot cause deadlock.
<li id="sec-153"><b>[Ex. 19.4]</b>:  Add an invariant that checks that the total of the balances never
changes.  Note that the invariant only holds if none of the locks are
held.
</ul>

<div id='sec-154'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>

<b>const</b> <var>MAX_BALANCE</var> = 2
<b>const</b> <var>N_ACCOUNTS</var> = 2
<b>const</b> <var>N_THREADS</var> = 2

<i>accounts</i> = [ { .<i>lock</i>: <var>Lock</var>(), .<i>balance</i>: <b>choose</b>({0..MAX_BALANCE})}
                            <b>for</b> <i>i</i> <b>in</b> {1..N_ACCOUNTS} ]

<b>def</b> <var>transfer</var>(<i>a1</i>, <i>a2</i>, <i>amount</i>) <b>returns</b> <i>success</i>:
    <var>acquire</var>(?<i>accounts</i>[<i>a1</i>].<i>lock</i>)
    <b>if</b> <i>amount</i> &lt;= <i>accounts</i>[<i>a1</i>].<i>balance</i>:
        <i>accounts</i>[<i>a1</i>].<i>balance</i> -= <i>amount</i> 
        <var>acquire</var>(?<i>accounts</i>[<i>a2</i>].<i>lock</i>)
        <i>accounts</i>[<i>a2</i>].<i>balance</i> += <i>amount</i> 
        <var>release</var>(?<i>accounts</i>[<i>a2</i>].<i>lock</i>)
        <i>success</i> = <b>True</b>
    <b>else</b>:
        <i>success</i> = <b>False</b>
    <var>release</var>(?<i>accounts</i>[<i>a1</i>].<i>lock</i>)

<b>def</b> <var>thread</var>():
    <b>let</b> <i>a1</i> = <b>choose</b>({0..N_ACCOUNTS-1})
    <b>let</b> <i>a2</i> = <b>choose</b>({0..N_ACCOUNTS-1} - { <i>a1</i> }):
        <var>transfer</var>(<i>a1</i>, <i>a2</i>, <b>choose</b>({1..MAX_BALANCE}))

<b>for</b> <i>i</i> <b>in</b> {1..N_THREADS}:
    <b>spawn</b> <var>thread</var>()
</code></pre>

</center>
<h4>Figure 19.4. [<a href='https://harmony.cs.cornell.edu/code/bank.hny'>code/bank.hny</a>] Bank accounts</h4>


</div>
</div>

<div id='sec-155'>
<h1>Chapter 20. Actors and Message Passing</h1>


<a id="index:actor-model:1"></a>
<a id="index:message-passing:1"></a><p>
<p><a id="gls:actor-model:1"></a><p><div id='sec-156'>
<center><img src="figures/actor-crop.png" width="50%"></img>
</center>
<h4>Figure 20.1. Depiction of three actors.  The producer does not receive messages.</h4>


</div>

<div id='sec-157'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>synch</var>

<b>const</b> <var>NCLIENTS</var> = 3

<i>server_queue</i> = <var>synch.Queue</var>()

<b>def</b> <var>server</var>():
    <b>var</b> <i>counter</i> = 0
    <b>while</b> <b>True</b>:
        <b>let</b> <i>q</i> = <var>synch.get</var>(?<i>server_queue</i>):   <i># await request</i>
            <var>synch.put</var>(<i>q</i>, <i>counter</i>)           <i># send response</i>
            <i>counter</i> += 1

<b>spawn</b> <b>eternal</b> <var>server</var>()

<b>sequential</b> <i>done</i>
<i>done</i> = [<b>False</b>,] * <var>NCLIENTS</var>

<b>def</b> <var>client</var>(<i>client_queue</i>):
    <var>synch.put</var>(?<i>server_queue</i>, <i>client_queue</i>)      <i># send request</i>
    <b>let</b> <i>response</i> = <var>synch.get</var>(<i>client_queue</i>):     <i># await response</i>
        <i>done</i>[<i>response</i>] = <b>True</b>
    <b>await</b> <b>all</b>(<i>done</i>)

<i>alice_queue</i> = <var>synch.Queue</var>()
<b>spawn</b> <var>client</var>(?<i>alice_queue</i>)
<i>bob_queue</i> = <var>synch.Queue</var>()
<b>spawn</b> <var>client</var>(?<i>bob_queue</i>)
<i>charlie_queue</i> = <var>synch.Queue</var>()
<b>spawn</b> <var>client</var>(?<i>charlie_queue</i>)
</code></pre>

</center>
<h4>Figure 20.2. [<a href='https://harmony.cs.cornell.edu/code/counter.hny'>code/counter.hny</a>] An illustration of the actor approach</h4>


</div>

Some programming languages favor a different way of implementing
synchronization using so-called <i>actors</i> [<a href="#cite-HBS73">24</a>, <a href="#cite-Agha86">1</a>].  Actors are
threads that have only private memory and communicate through
<i>message passing</i>.
See <a href='#sec-156'>Figure 20.1</a> for an illustration.
Given that there is no shared memory in the actor model (other than the message
queues, which have built-in synchronization), there is no need
for critical sections.  Instead, some sequential thread owns a particular
piece of data and other threads access it by sending request messages
to the thread and optionally waiting for response messages.  Each thread
handles one message at a time, serializing all access to the data it owns.
As message queues are FIFO (First-In-First-Out), starvation is prevented.<p>The actor synchronization model is popular in a variety of programming
languages, including Erlang and Scala.  Actor support is also available
through popular libraries such as Akka, which is available for various
programming languages.  In Python, Java, and C/C++,
actors can be easily emulated using threads and <i>synchronized queues</i>
<a id="index:synchronized-queue:1"></a>
(aka <i>blocking queues</i>)
<a id="index:blocking-queue:1"></a>
for messaging.
Each thread would have one such queue for receiving messages.
Dequeuing from an empty synchronized queue blocks the thread until
another thread enqueues a message on the queue.<p>The <var>synch</var> library supports a synchronized message queue,
similar to the <var>Queue</var> object in Python.
Its interface is as follows:
<ul><li> <var>Queue</var>() returns an empty queue;
<li> <var>put</var>(<i>q</i>, <i>item</i>) adds <i>item</i> to the queue pointed to by <i>q</i>;
<li> <var>get</var>(<i>q</i>) waits for and returns an item on the queue pointed to by <i>q</i>.
</ul>

For those familiar with counting semaphores: note that a <var>Queue</var>
behaves much like a zero-initialized counting semaphore.
<var>put</var> is much like <var>V</var>, except that it is accompanied by data.
<var>get</var> is much like <var>P</var>, except that it also returns data.
Thus, synchronized queues can be considered a generalization of
counting semaphores.<p><a href='#sec-157'>Figure 20.2</a> illustrates the actor approach.
There are three client threads that each want to be assigned
a unique identifier from the set { 0, 1, 2 }.
Normally one would use a shared 0-initialized counter and a lock.
Each client would acquire the lock, get the value of the counter
and increment it, and release the lock.
Instead, in the actor approach the counter is managed by a
separate server thread.
The server never terminates, so it is spawned with the keyword
<b>eternal</b> to suppress non-terminating state warnings.
Each client sends a request to the server, consisting in this case
of simply the queue to which the server must send the response.
The server maintains a local, zero-initialized counter variable.
Upon receiving a request, it returns a response with the value of
the counter and increments the counter.  No lock is required.<p>This illustration is an example of the <i>client/server</i> model.
Here a single actor implements some service, and clients send request
messages and receive response messages.  The model is particularly
popular in distributed systems, where each actor runs on a separate
machine and the queues are message channels.  For example, the server
can be a web server, and its clients are web browsers.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-158"><b>[Ex. 20.1]</b>:  Actors and message queues are good for building pipelines.
Develop a pipeline that computes Mersenne primes (primes that are one less
than a power of two).  Write four actors:
<ol><li> an actor that generates a sequence of integers 1 through <var>N</var>;
<li> an actor that receives integers and forwards only those that are prime;
<li> an actor that receives integers and forwards only those that are one
less than a power of two;
<li> an actor that receives integers but otherwise ignores them.
</ol>
Configure two versions of the pipeline, one that first checks if a number
is prime and then if it is one less than a power of two, the other
in the opposite order.  Which do you think is better?
</ul>
</div>

<div id='sec-159'>
<h1>Chapter 21. Barrier Synchronization</h1>


<a id="index:barrier-synchronization:1"></a><p>
<p><div id='sec-160'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>barrier</var>

<b>const</b> <var>NTHREADS</var> = 3
<b>const</b> <var>NROUNDS</var> = 4

<i>round</i> = [0,] * <var>NTHREADS</var>
<b>invariant</b> (<b>max</b>(<i>round</i>) - <b>min</b>(<i>round</i>)) &lt;= 1

<i>barr</i> = <var>barrier.Barrier</var>(<var>NTHREADS</var>)

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>for</b> <i>r</i> <b>in</b> {0..NROUNDS-1}:
        <var>barrier.bwait</var>(?<i>barr</i>)
        <i>round</i>[<i>self</i>] += 1

<b>for</b> <i>i</i> <b>in</b> {0..NTHREADS-1}:
    <b>spawn</b> <var>thread</var>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 21.1. [<a href='https://harmony.cs.cornell.edu/code/barrier_test1.hny'>code/barrier_test1.hny</a>] Test program for <a href='#sec-161'>Figure 21.2</a></h4>


</div>

<div id='sec-161'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> *

<b>def</b> <var>Barrier</var>(<i>required</i>) <b>returns</b> <var>barrier</var>:
    <var>barrier</var> = {
        .<i>mutex</i>: <var>Lock</var>(), .<i>cond</i>: <var>Condition</var>(),
        .<i>required</i>: <i>required</i>, .<i>left</i>: <i>required</i>, .<i>cycle</i>: 0
    }

<b>def</b> <var>bwait</var>(<i>b</i>):
    <var>acquire</var>(?<i>b</i>-&gt;<i>mutex</i>)
    <i>b</i>-&gt;<i>left</i> -= 1
    <b>if</b> <i>b</i>-&gt;<i>left</i> == 0:
        <i>b</i>-&gt;<i>cycle</i> = (<i>b</i>-&gt;<i>cycle</i> + 1) % 2
        <i>b</i>-&gt;<i>left</i> = <i>b</i>-&gt;<i>required</i>
        <var>notifyAll</var>(?<i>b</i>-&gt;<i>cond</i>)
    <b>else</b>:
        <b>let</b> <i>cycle</i> = <i>b</i>-&gt;<i>cycle</i>:
            <b>while</b> <i>b</i>-&gt;<i>cycle</i> == <i>cycle</i>:
                <var>wait</var>(?<i>b</i>-&gt;<i>cond</i>, ?<i>b</i>-&gt;<i>mutex</i>)
    <var>release</var>(?<i>b</i>-&gt;<i>mutex</i>)
</code></pre>

</center>
<h4>Figure 21.2. [<a href='https://harmony.cs.cornell.edu/code/barrier.hny'>code/barrier.hny</a>] Barrier implementation</h4>


</div>

<div id='sec-162'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>barrier</var>

<b>const</b> <var>NTHREADS</var> = 3
<b>const</b> <var>NROUNDS</var> = 4

<i>round</i> = [0,] * <var>NTHREADS</var>
<b>invariant</b> (<b>max</b>(<i>round</i>) - <b>min</b>(<i>round</i>)) &lt;= 1

<i>phase</i> = 0
<i>barr</i> = <var>barrier.Barrier</var>(<var>NTHREADS</var>)

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>for</b> <i>r</i> <b>in</b> {0..NROUNDS-1}:
        <b>if</b> <i>self</i> == 0:                <i># coordinator prepares</i>
            <i>phase</i> += 1
        <var>barrier.bwait</var>(?<i>barr</i>)         <i># enter parallel work</i>
        <i>round</i>[<i>self</i>] += 1
        <b>assert</b> <i>round</i>[<i>self</i>] == <i>phase</i>
        <var>barrier.bwait</var>(?<i>barr</i>)         <i># exit parallel work</i>

<b>for</b> <i>i</i> <b>in</b> {0..NTHREADS-1}:
    <b>spawn</b> <var>thread</var>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 21.3. [<a href='https://harmony.cs.cornell.edu/code/barrier_test2.hny'>code/barrier_test2.hny</a>] Demonstrating the double-barrier pattern</h4>


</div>



<div id='sec-163'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>barrier</var> <b>import</b> *

<b>const</b> <var>N</var> = 5     <i># size of list to be sorted</i>

<i>list</i> = [ <b>choose</b>({ 1 .. <var>N</var> }) <b>for</b> <i>i</i> <b>in</b> { 1 .. <var>N</var> } ]

<b>finally</b> <b>all</b>(<i>list</i>[<i>i</i>-1] &lt;= <i>list</i>[<i>i</i>] <b>for</b> <i>i</i> <b>in</b> { 1 .. <var>N</var> - 1 })

<b>const</b> <var>NTHREADS</var> = <var>N</var> / 2
<i>bar</i> = <var>Barrier</var>(<var>NTHREADS</var>)
<i>count</i> = 0                   <i># to detect termination</i>

<b>def</b> <var>fetch_and_increment</var>(<i>p</i>): <i># atomic increment</i>
    <b>atomically</b> !<i>p</i> += 1

<b>def</b> <var>sorter</var>(<i>i</i>):
    <b>var</b> <var>sorted</var> = <b>False</b>
    <b>var</b> <i>oldcount</i> = 0
    <b>while</b> <b>not</b> <var>sorted</var>:
        <i># Even phase</i>
        <b>if</b> <i>list</i>[<i>i</i> - 1] &gt; <i>list</i>[<i>i</i>]:
            <i>list</i>[<i>i</i> - 1], <i>list</i>[<i>i</i>] = <i>list</i>[<i>i</i>], <i>list</i>[<i>i</i> - 1]
            <var>fetch_and_increment</var>(?<i>count</i>)

        <var>bwait</var>(?<i>bar</i>)

        <i># Odd phase</i>
        <b>if</b> (<i>i</i> &lt; (<var>N</var> - 1)) <b>and</b> (<i>list</i>[<i>i</i>] &gt; <i>list</i>[<i>i</i> + 1]):
            <i>list</i>[<i>i</i>], <i>list</i>[<i>i</i> + 1] = <i>list</i>[<i>i</i> + 1], <i>list</i>[<i>i</i>]
            <var>fetch_and_increment</var>(?<i>count</i>)

        <var>bwait</var>(?<i>bar</i>)

        <i># Sorted if nobody swapped anything</i>
        <var>sorted</var> = <i>count</i> == <i>oldcount</i>
        <i>oldcount</i> = <i>count</i>

        <var>bwait</var>(?<i>bar</i>)

<b>for</b> <i>k</i> <b>in</b> { 0 .. <var>NTHREADS</var> - 1 }:
    <b>spawn</b> <var>sorter</var>((2*<i>k</i>) + 1)
</code></pre>

</center>
<h4>Figure 21.4. [<a href='https://harmony.cs.cornell.edu/code/bsort.hny'>code/bsort.hny</a>] Parallel bubble sort</h4>


</div>
<p><a id="gls:barrier-synchronization:1"></a><p>Barrier synchronization is a problem that comes up in high-performance
parallel computing.
The Harmony model checker uses it.
A barrier is almost the opposite of a critical section:
the intention is to get a group of threads to run some code at the
same time, instead of having them execute it one at a time.
More precisely, with barrier synchronization, the threads execute in rounds.
Between each round, there is a so-called <i>barrier</i> where threads wait
until all threads have completed the previous round and reached the
barrier---before they start the next round.
For example, in an iterative matrix algorithm, the matrix may be
cut up into fragments.  During a round, the threads run concurrently,
one for each fragment.  The next round is not allowed to start
until all threads have completed processing their fragment.<p>A barrier is used as follows:
<ul><li> <i>b</i> = <var>Barrier</var>(<i>n</i>): initialize a barrier <i>b</i> for a collection of
<i>n</i> threads;
<li> <var>bwait</var>(?<i>b</i>): wait until all threads have reached the barrier
</ul>

<a href='#sec-160'>Figure 21.1</a> is a test program for barriers.
It uses an integer array <i>round</i> with one entry per thread.
Each thread, in a loop, waits for all threads to get to the barrier
before incrementing its round number.  If the barrier works as
advertised, two threads should never be more than one round apart.<p>When implementing a barrier, a complication to worry about is that
a barrier can be used over and over again.  If this were not the
case, then a solution based on a lock, a condition variable,
and a counter initialized to the number of threads could be used.
The threads would decrement the counter and wait on the condition
variable until the counter reaches 0.<p><a href='#sec-161'>Figure 21.2</a> shows how one might implement a reusable barrier.
Besides a counter .<i>left</i> that counts how many threads still have to
reach the barrier, it uses a counter .<i>cycle</i> that is incremented
after each use of the barrier---to deal with the complication above.
The last thread that reaches the barrier restores
.<i>left</i> to the number of threads
(.<i>required</i>) and increments the cycle counter.
The other threads are waiting for the cycle counter to be incremented.
The cycle counter is allowed to wrap around---in fact, a single bit
suffices for the counter.<p>A common design pattern with barriers in parallel programs,
demonstrated in <a href='#sec-162'>Figure 21.3</a>, is to use the barrier
twice in each round.  Before a round starts, one of the threads---let's
call it the coordinator---sets up the work that needs to be done
while the other threads wait.  Then all threads do the work and go
on until they reach a second barrier.  The second barrier is used
so the coordinator can wait for all threads to be done before setting
up the work for the next round.<p><a href='#sec-163'>Figure 21.4</a> shows an implementation of a parallel sorting
algorithm based on bubblesort.  The threads (one for every two elements)
go through three phases.
In the first phase, the threads swap entries 0 and 1, 2 and 3, ...
as needed.  In the second phase, they swap entries 1 and 2, 3 and 4, ...
as needed.  Finally, they check if any elements were swapped.  If so,
they repeat the phases.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-164"><b>[Ex. 21.1]</b>:  Implement barrier synchronization for <var>N</var> threads
with just three binary semaphores.  Busy waiting is not allowed.
Can you implement barrier synchronization with two binary semaphores?
(As always, the Little Book of Semaphores [<a href="#cite-Downey09">19</a>] is a good resource
for solving synchronization problems with semaphores.
Look for the <i>double turnstile</i>
<a id="index:double-turnstile:1"></a>
solution.)
<li id="sec-165"><b>[Ex. 21.2]</b>:  Imagine a pool hall with <var>N</var> tables.  A table is <i>full</i>
from the time there are two players until both players have left.
When someone arrives, they can join a table that is not full, preferably
one that has a player ready to start playing.
Implement a simulation of such a pool hall.
</ul>
</div>

<div id='sec-166'>
<h1>Chapter 22. Example: A Concurrent File Service</h1>

<p>This chapter presents a concurrent file service to illustrate many of the
techniques we have discussed inside a single example.  We will cover the
specification of such a service as well as that of a disk, and show how
the specification can be implemented on top of the disk.  The file service
implementation will use a collection of worker threads synchronizing using
both ordinary locks and reader/writer locks.  Clients of the file service
implementation (threads themselves) use blocking synchronized queues to
communicate with the workers.
The example will also illustrate modular model checking,
as the disk, the locks, and the queues are only specified.<p><div id='sec-167'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>

<b>def</b> <var>File</var>(<i>n_files</i>) <b>returns</b> <i>fs</i>:
    <i>fs</i> = <var>malloc</var>([ [], ] * <i>n_files</i>)

<b>def</b> <var>getsize</var>(<i>fs</i>, <i>ino</i>) <b>returns</b> <var>size</var>:
    <b>atomically</b> <var>size</var> = <b>len</b> (!<i>fs</i>)[<i>ino</i>] 

<b>def</b> <var>read</var>(<i>fs</i>, <i>ino</i>, <i>offset</i>) <b>returns</b> <i>data</i>:
    <b>atomically</b> <i>data</i> = (!<i>fs</i>)[<i>ino</i>][<i>offset</i>] <b>if</b> 0 &lt;= <i>offset</i> &lt; <b>len</b> (!<i>fs</i>)[<i>ino</i>] <b>else</b> <b>None</b>

<b>def</b> <var>write</var>(<i>fs</i>, <i>ino</i>, <i>offset</i>, <i>data</i>):
    <b>atomically</b>:
        <b>let</b> <i>n</i> = <b>len</b> (!<i>fs</i>)[<i>ino</i>]:
            <b>if</b> 0 &lt;= <i>offset</i> &lt;= <i>n</i>:
                (!<i>fs</i>)[<i>ino</i>][<i>offset</i>] = <i>data</i>
            <b>else</b>:
                (!<i>fs</i>)[<i>ino</i>] += ([ <b>None</b>, ] * (<i>offset</i> - <i>n</i>)) + [<i>data</i>,]
</code></pre>

</center>
<h4>Figure 22.1. [<a href='https://harmony.cs.cornell.edu/code/file.hny'>code/file.hny</a>] Specification of the file system</h4>


</div>

In practice, there are many aspects to a file system.  We will focus here
on a low-level notion of a file, where the file abstraction
is identified by a number (the so-called &quot;inode number&quot; or
<i>ino</i>) and consists of a sequence of fixed-sized <i>blocks</i>.
In our abstraction, each block holds an arbitrary
Harmony value.  If you want to remain more truthful to reality, you might
only store lists of numbers of fixed length in a block,
representing a block of bytes.
A more complete file system would keep track of various additional information
about each file, such as its size in bytes, its owner, its access rights,
and when the file was last modified.  Moreover, a system of folders
(aka directories)
built on top of the files would associate user-readable names to the files.<p>


<p><a href='#sec-167'>Figure 22.1</a> shows the file system interface.  Just like in Unix-like
file systems, you have to specify the (maximum) number of files when
you initialize the file system.
<var>File</var>(<i>n</i>) returns a handle that must be passed to file operations, where
<i>n</i> is the maximum number of files.
For our example, we have only included three operations on files.
<var>getsize</var>(<i>fs</i>, <i>ino</i>) returns the size
(in blocks) of the file identified by inode number <i>ino</i>.
<var>read</var>(<i>fs</i>, <i>ino</i>, <i>offset</i>) returns the block of file <i>ino</i> at the
given offset, or <b>None</b> if nothing has been stored at that offset.
<var>write</var>(<i>fs</i>, <i>ino</i>, <i>offset</i>, <i>data</i>) stores <i>data</i> at the given offset
in file <i>ino</i>.  If needed, the file is grown to include the given offset.
&quot;Holes&quot; (unwritten blocks) are plugged with <b>None</b> values.<p><div id='sec-168'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <i>file</i> <b>import</b> *

<b>const</b> <var>N_FILES</var> = 2
<b>const</b> <var>MAX_FILE_SIZE</var> = 2

<b>const</b> <var>N_READ</var> = 1
<b>const</b> <var>N_WRITE</var> = 1
<b>const</b> <var>N_GETSIZE</var> = 1

<i>system</i> = <var>File</var>(<var>N_FILES</var>)

<b>def</b> <i>getsize_test</i>(<i>i</i>):
    <b>let</b> <i>ino</i> = <b>choose</b> { 0 .. <var>N_FILES</var> - 1 }:
        <b>print</b>(<i>i</i>, "getsize", <i>ino</i>)
        <b>let</b> <var>size</var> = <var>getsize</var>(<i>system</i>, <i>ino</i>):
            <b>print</b>(<i>i</i>, "getsize done", <i>ino</i>, <var>size</var>)

<b>def</b> <i>read_test</i>(<i>i</i>):
    <b>let</b> <i>ino</i> = <b>choose</b> { 0 .. <var>N_FILES</var> - 1 }
    <b>let</b> <i>offset</i> = <b>choose</b> { 0 .. <var>MAX_FILE_SIZE</var> - 1 }:
        <b>print</b>(<i>i</i>, "read", <i>ino</i>, <i>offset</i>)
        <b>let</b> <i>data</i> = <var>read</var>(<i>system</i>, <i>ino</i>, <i>offset</i>):
            <b>print</b>(<i>i</i>, "read done", <i>ino</i>, <i>offset</i>, <i>data</i>)

<b>def</b> <i>write_test</i>(<i>i</i>):
    <b>let</b> <i>ino</i> = <b>choose</b> { 0 .. <var>N_FILES</var> - 1 }
    <b>let</b> <i>offset</i> = <b>choose</b> { 0 .. <var>MAX_FILE_SIZE</var> - 1 }:
        <b>print</b>(<i>i</i>, "write", <i>ino</i>, <i>offset</i>)
        <var>write</var>(<i>system</i>, <i>ino</i>, <i>offset</i>, <i>i</i>)
        <b>print</b>(<i>i</i>, "write done", <i>ino</i>, <i>offset</i>)

<b>for</b> <i>i</i> <b>in</b> { 1 .. <var>N_GETSIZE</var> }:
    <b>spawn</b> <i>getsize_test</i>(<i>i</i>)
<b>for</b> <i>i</i> <b>in</b> { 1 .. <var>N_READ</var> }:
    <b>spawn</b> <i>read_test</i>(<i>i</i>)
<b>for</b> <i>i</i> <b>in</b> { 1 .. <var>N_WRITE</var> }:
    <b>spawn</b> <i>write_test</i>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 22.2. [<a href='https://harmony.cs.cornell.edu/code/file_btest.hny'>code/file_btest.hny</a>] Test program for a concurrent file system</h4>


</div>

<a href='#sec-168'>Figure 22.2</a> shows how the file system may be tested and
illustrates how the file system interface is used.  As shown in
<a href='#sec-95'>Chapter 13</a>, we can test a concurrent system by checking
all interleavings of some selection of its operations.  We can do
this for both the specification and implementation of the file
system and check that every behavior of the implementation is also
a behavior of the specification.<p>








<p><div id='sec-169'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>

<b>const</b> <var>BITS_PER_BLOCK</var> = 4

<b>def</b> <var>new</var>(<i>n_blocks</i>) <b>returns</b> <var>disk</var>:
    <var>disk</var> = <var>malloc</var>([ <b>None</b>, ] * <i>n_blocks</i>)

<b>def</b> <var>getsize</var>(<var>disk</var>) <b>returns</b> <i>size</i>:
    <i>size</i> = <b>len</b> !<var>disk</var>

<b>def</b> <var>read</var>(<var>disk</var>, <i>bno</i>) <b>returns</b> <i>block</i>:
    <i>block</i> = (!<var>disk</var>)[<i>bno</i>]

<b>def</b> <var>write</var>(<var>disk</var>, <i>bno</i>, <i>block</i>):
    (!<var>disk</var>)[<i>bno</i>] = <i>block</i>
</code></pre>

</center>
<h4>Figure 22.3. [<a href='https://harmony.cs.cornell.edu/code/disk.hny'>code/disk.hny</a>] Specification of a disk</h4>


</div>

To store the file system, we will use a disk.  Like
a file, a disk is an array of blocks, albeit one of fixed length.
<a href='#sec-169'>Figure 22.3</a> specifies a disk.  The interface is similar to
that of files, except that there are no inode numbers.  Each block
is identified by its offset or <i>block number</i>.
For example,
<i>disk_read</i>(<var>disk</var>, <i>bno</i>) retrieves the value of block <i>bno</i> on the
given disk.  Note that operations are not atomic.  For example,
two threads concurrently writing the same block can result in chaos.
It is up to the file system implementation that this does not happen.
Of course, more than one thread can read the same block at the same
time.
This is only a specification of a disk---an implementation may
want to include a cache of blocks for good performance.
Certain operations may also be re-ordered to further improve performance.<p>For the implementation, we will use a simplified Unix file system.
In a Unix file system, the disk is subdivided into four parts (<a href='#sec-170'>Figure 22.4</a>(a)):
<ol><li> The <i>superblock</i>, at offset 0.
<li> An array of  <span 
class="cmmi-10">b </span> <i>bitmap blocks</i> with one bit per block to keep
track of which blocks are allocated and which are free.
<li> An array of fixed-sized <i>inodes</i>, stored in a range of  <span 
class="cmmi-10">m </span>
disk blocks starting at block  1 + <span 
class="cmmi-10">b </span>.
An inode number indexes into this array.
Each inode maintains some information about a file,
including about where to find the data.
<li> The remaining blocks, starting at offset  1 + <span 
class="cmmi-10">b </span>+ <span 
class="cmmi-10">m </span>,
which will either store data, metadata, or be free.
Metadata blocks contain a list of block numbers.
</ol>
The superblock specifies the number of bitmap blocks and the number
of inode blocks.<p><div id='sec-170'>
<center><img src="figures/filesys.png" width="80%"></img>
</center>
<h4>Figure 22.4. The file system data structure: (a) disk layout
(1 superblock, <i>n</i> blocks,  <span 
class="cmmi-10">b</span>
 bitmap blocks,
 <span 
class="cmmi-10">m </span> inode blocks, 4 inodes per block);
(b) inode for a file with 3 data blocks</h4>


</div>

In this simplified file system, each inode contains just three pieces
of information about the file (<a href='#sec-170'>Figure 22.4</a>(b)):
the size of the file in blocks, the
block number of the first data block, and the block number of an
<i>indirect block</i>---a metadata block that contains block numbers
of additional data blocks.  Any block number may be <b>None</b> to indicate
a hole in the file (unused blocks).  Note that a Unix file is essentially
implemented as a tree of blocks.<p>A bitmap keeps track of the free blocks.  The bitmap may be larger than
what fits in a block and therefore must also be partitioned, just like
the inode table.<p>Note that the entire file system data structure is essentially a tree
of blocks, with the superblock acting as the root of the tree.  The
superblock points to the bitmap blocks and the inode blocks.  The bitmap
blocks point to the free blocks and the inode blocks point to the blocks
that are allocated.  An invariant
of the data structure is that all blocks are in the tree and each block
(except for the superblock) is pointed to exactly once.  The invariant
may not hold while the data structure is being updated.  For example,
temporarily a block may be marked as free in the bitmap but also be
part of an inode.<p>


<p><a href='#sec-171'>Figure 22.5</a> shows the modules that the file system
implementation will use and some constants.  The implementation uses
the actor model (<a href='#sec-155'>Chapter 20</a>)---the <var>synch</var> module
provides blocking multi-reader/multi-writer queues that the actors will
use for messaging.  The file server itself is implemented as a multithreaded
actor.  The threads synchronize using a plain lock for the bitmap
and reader/writer locks for each of the
inode blocks.  <var>N_BLOCKS</var> specifies the size of the disk to be used
in blocks.  <var>INODES_PER_BLOCK</var> specifies how many inodes fit in an
inode block.
<var>INDIR_PER_BLOCK</var> specifies how many block numbers fit in a metadata block.
Note that the maximum file
size is this simplified file system is 1 + <var>INDIR_PER_BLOCK</var> blocks.
In a more realistic Unix file system, indirect blocks can point to other
indirect blocks, allowing for much larger files.
<var>N_WORKERS</var> specifies the number of worker threads or actors.<p>



<p><div id='sec-171'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> *             <i># shared queue for file server and lock for superblock</i>
<b>from</b> <i>rwlock</i> <b>import</b> *            <i># read/write locks for inode blocks</i>
<b>from</b> <var>alloc</var> <b>import</b> *             <i># malloc/free</i>
<b>from</b> <var>list</var> <b>import</b> <var>subseq</var>         <i># list slicing</i>
<b>import</b> <var>disk</var>                     <i># disk interface</i>
<b>import</b> <var>wal</var>                      <i># write-ahead-log</i>

<b>const</b> <var>N_BLOCKS</var> = 10             <i># total number of disk blocks</i>
<b>const</b> <var>INODES_PER_BLOCK</var> = 2      <i># number of inodes that fit in a block</i>
<b>const</b> <var>INDIR_PER_BLOCK</var>  = 4      <i># number of block pointers per block</i>
</code></pre>

</center>
<h4>Figure 22.5. [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File system implementation preamble</h4>


</div>

<div id='sec-172'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>File</var>(<i>n_files</i>) <b>returns</b> <i>req_q</i>:
    <i>req_q</i> = <var>malloc</var>(<var>Queue</var>())
    <b>let</b> <i>n_inode_blocks</i> = (<i>n_files</i> + (<var>INODES_PER_BLOCK</var> - 1)) / <var>INODES_PER_BLOCK</var>
    <b>let</b> <i>n_workers</i> = 2
    <b>let</b> <i>d</i> = <var>disk.new</var>(<var>N_BLOCKS</var>)
    <b>let</b> <i>n_bitmap_blocks</i> = (<var>N_BLOCKS</var> + (<var>disk.BITS_PER_BLOCK</var> - 1)) /
                                                <var>disk.BITS_PER_BLOCK</var>:
        <i># Initialize the file system on disk</i>
        <var>fs_init</var>(<i>d</i>, <i>n_bitmap_blocks</i>, <i>n_inode_blocks</i>)

        <i># Allocate the in-memory shared state of the file server</i>
        <b>let</b> <i>fs_state</i> = <var>malloc</var>({
                .<i>disk</i>: <i>d</i>, .<i>req_q</i>: <i>req_q</i>, .<i>bitmap_lock</i>: <var>Lock</var>(),
                .<i>n_bitmap_blocks</i>: <i>n_bitmap_blocks</i>,
                .<i>n_inode_blocks</i>: <i>n_inode_blocks</i>,
                .<i>bitmap</i>: [ <i>i</i> &lt;= (1 + <i>n_bitmap_blocks</i> + <i>n_inode_blocks</i>)
                                        <b>for</b> <i>i</i> <b>in</b> { 0 .. <var>N_BLOCKS</var> - 1 } ],
                .<i>ib_locks</i>: [ <var>RWlock</var>(), ] * <i>n_inode_blocks</i> }):

            <i># Start worker threads to handle client requests</i>
            <b>for</b> <i>i</i> <b>in</b> { 1 .. <i>n_workers</i> }:
                <b>spawn</b> <b>eternal</b> <var>fs_worker</var>(<i>fs_state</i>)

<b>def</b> <var>getsize</var>(<i>req_q</i>, <i>ino</i>) <b>returns</b> <i>size</i>:
    <b>let</b> <i>res_q</i> = <var>malloc</var>(<var>Queue</var>()):
        <var>put</var>(<i>req_q</i>, { .<i>type</i>: "getsize", .<i>ino</i>: <i>ino</i>, .<i>q</i>: <i>res_q</i> })
        <i>size</i> = <var>get</var>(<i>res_q</i>)
        <var>free</var>(<i>res_q</i>)

<b>def</b> <var>read</var>(<i>req_q</i>, <i>ino</i>, <i>offset</i>) <b>returns</b> <i>data</i>:
    <b>let</b> <i>res_q</i> = <var>malloc</var>(<var>Queue</var>()):
        <var>put</var>(<i>req_q</i>, { .<i>type</i>: "read", .<i>ino</i>: <i>ino</i>, .<i>offset</i>: <i>offset</i>, .<i>q</i>: <i>res_q</i> })
        <i>data</i> = <var>get</var>(<i>res_q</i>)
        <var>free</var>(<i>res_q</i>)

<b>def</b> <var>write</var>(<i>req_q</i>, <i>ino</i>, <i>offset</i>, <i>data</i>):
    <b>let</b> <i>res_q</i> = <var>malloc</var>(<var>Queue</var>()):
        <var>put</var>(<i>req_q</i>, { .<i>type</i>: "write", .<i>ino</i>: <i>ino</i>, .<i>offset</i>: <i>offset</i>, .<i>data</i>: <i>data</i>, .<i>q</i>: <i>res_q</i> })
        <b>let</b> <i>status</i> = <var>get</var>(<i>res_q</i>):
            <b>assert</b> <i>status</i> == "ok"
        <var>free</var>(<i>res_q</i>)
</code></pre>

</center>
<h4>Figure 22.6. [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File system interface implementation</h4>


</div>

<a href='#sec-172'>Figure 22.6</a> shows the implementation of the file system interface,
which is the same interface as the specification (<a href='#sec-167'>Figure 22.1</a>)
but a different implementation.
<var>File</var>), instead of returning an object containing an array of
files, returns an object containing a queue to communicate with the
file system worker threads.
The first argument is the maximum number of files.
The number of inode blocks can be computed
from the number of files by dividing by <var>INODES_PER_BLOCK</var> and rounding
up.
The function also initializes a disk object using <var>fs_init</var> and then
allocates some shared state to be used by the worker threads.
The shared state includes the following information:<p><ul><li> .<i>disk</i>: points to the disk object;
<li> .<i>req_q</i>: the shared queue on which requests from clients arrive;
<li> .<i>bitmap</i>: an in-memory copy of the bitmap;
<li> .<i>bitmap_lock</i>: a lock on the in-memory bitmap;
<li> .<i>ib_locks</i>: an array of reader/writer locks, one for each inode block.
</ul>

Finally, <var>File</var>() spawns the <var>fs_worker</var>() threads
that will handle requests.<p>The remaining interfaces simply put a request on the request queue
and wait for a response on another queue <i>res_q</i> that is allocated
just for this purpose.
Note that the request queue has concurrent producers (the clients) and
concurrent consumers (the worker threads).  The response queues are
single use only and have a single producer (a worker thread) and a
single consumer (the client).<p><div id='sec-173'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i># A worker thread handles client requests</i>
<b>def</b> <var>fs_worker</var>(<i>fs_state</i>):
    <b>while</b> <b>True</b>:
        <b>let</b> <i>req</i> = <var>get</var>(<i>fs_state</i>-&gt;<i>req_q</i>)
        <b>let</b> <i>ib</i> = <i>req.ino</i> / <var>INODES_PER_BLOCK</var>:
            <b>if</b> <i>req.type</i> == "write":
                <var>write_acquire</var>(?<i>fs_state</i>-&gt;<i>ib_locks</i>[<i>ib</i>])
                <var>fs_update_request</var>(<i>fs_state</i>, <i>req</i>, <i>ib</i>)
                <var>write_release</var>(?<i>fs_state</i>-&gt;<i>ib_locks</i>[<i>ib</i>])
                <var>put</var>(<i>req.q</i>, "ok")
            <b>else</b>:
                <var>read_acquire</var>(?<i>fs_state</i>-&gt;<i>ib_locks</i>[<i>ib</i>])
                <b>let</b> <i>response</i> = <var>fs_query_request</var>(<i>fs_state</i>, <i>req</i>, <i>ib</i>):
                    <var>read_release</var>(?<i>fs_state</i>-&gt;<i>ib_locks</i>[<i>ib</i>])
                    <var>put</var>(<i>req.q</i>, <i>response</i>)
</code></pre>

</center>
<h4>Figure 22.7. [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File server and worker threads</h4>


</div>

Each worker thread executes an infinite loop, obtaining client requests
and handling them.  Each request is for a particular inode.  The worker
first determines which inode block needs to be locked.  Depending on
the request, it obtains either a read lock or a write lock on the block.
In practice, files are read much more frequently than written, so
reader/writer locks can significantly improve the potential for
concurrent access compared to regular locks.
The requests themselves are handled in the
<var>fs_query_request</var>() and <var>fs_update_request</var>() methods, which we
will describe below.<p><div id='sec-174'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i># Initialize the file system by writing the superblock, the bitmap blocks, and</i>
<i># the i-node blocks,</i>
<b>def</b> <var>fs_init</var>(<i>d</i>, <i>n_bitmap_blocks</i>, <i>n_inode_blocks</i>):
    <i># Initialize the superblock</i>
    <var>disk.write</var>(<i>d</i>, 0,
        { .<i>n_bitmap_block</i>: <i>n_bitmap_blocks</i>, .<i>n_inode_blocks</i>: <i>n_inode_blocks</i> })

    <i># Initialize the bitmap blocks</i>
    <b>for</b> <i>bno</i> <b>in</b> { 1 .. <i>n_bitmap_blocks</i> }:
        <var>disk.write</var>(<i>d</i>, <i>bno</i>, [ <b>False</b>, ] * <var>disk.BITS_PER_BLOCK</var>)

    <i># Initialize the i-node blocks</i>
    <b>for</b> <i>i</i> <b>in</b> { 1 .. <i>n_inode_blocks</i> }:
        <var>disk.write</var>(<i>d</i>, <i>n_bitmap_blocks</i> + <i>i</i>, [
            { .<i>direct</i>: <b>None</b>, .<i>indir</i>: <b>None</b>, .<i>size</i>: 0 }, ] * <var>INODES_PER_BLOCK</var>)
</code></pre>

</center>
<h4>Figure 22.8. [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File system initialization</h4>


</div>

<a href='#sec-174'>Figure 22.8</a> shows how the disk is initialized with a fresh
file system.
The superblock is first initialized with the number of inode blocks
and a bitmap where all blocks are free.
Next, the inode blocks are initialized, each with an empty file.<p><div id='sec-175'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i># The file system consists of a superblock, an array of bitmap blocks</i>
<i># (to track the free blocks), an array of inode blocks, and the</i>
<i># remaining blocks.  The remaining blocks are dynamic and can be of</i>
<i># the following types:</i>
<i>#   - free: not in use (marked False in the bitmap blocks)</i>
<i>#   - data: a data block</i>
<i>#   - indir: an indirect block, with pointers to other blocks</i>
<i># An inode has a pointer to a direct block and a pointer to an indirect block,</i>
<i># so the maximum file size is 1 + INDIR_PER_BLOCK.</i>

<i># Allocate a disk block.  Currently uses first available strategy,</i>
<i># which is not very efficient but easy.  Note, this does not update the</i>
<i># bitmap on disk, which is done through the WAL.</i>
<b>def</b> <var>fs_alloc</var>(<i>fs_state</i>) <b>returns</b> <i>bno</i>:
    <var>acquire</var>(?<i>fs_state</i>-&gt;<i>bitmap_lock</i>)
    <i>bno</i> = <i>fs_state</i>-&gt;<i>n_bitmap_blocks</i> + <i>fs_state</i>-&gt;<i>n_inode_blocks</i>
    <b>var</b> <i>found</i> = <b>False</b>
    <b>while</b> <b>not</b> <i>found</i>:
        <i>bno</i> += 1
        <b>assert</b> <i>bno</i> &lt; <var>N_BLOCKS</var>
        <i>found</i> = <b>not</b> <i>fs_state</i>-&gt;<i>bitmap</i>[<i>bno</i>]
    <i>fs_state</i>-&gt;<i>bitmap</i>[<i>bno</i>] = <b>True</b>
    <var>release</var>(?<i>fs_state</i>-&gt;<i>bitmap_lock</i>)
</code></pre>

</center>
<h4>Figure 22.9. [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] File system bitmap maintenance</h4>


</div>

<a href='#sec-175'>Figure 22.9</a> contains the code for allocating blocks.
The method first acquires the bitmap lock and then scans the
bitmap for a free blocks.
Block allocation (and release) can be made much more efficient if each
worker thread maintained a small cache of free blocks that it can
allocate from without having to coordinate with the other workers.<p><div id='sec-176'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i># Handle a read-only request.  A read lock on i-node block ib has been acquired.</i>
<b>def</b> <var>fs_query_request</var>(<i>fs_state</i>, <i>req</i>, <i>ib</i>) <b>returns</b> <i>result</i>:
    <i># Read the inode block and extract the inode</i>
    <b>let</b> <i>inode_block</i> = <var>wal.read</var>(<i>fs_state</i>-&gt;<i>disk</i>, 1 + <i>fs_state</i>-&gt;<i>n_bitmap_blocks</i> + <i>ib</i>)
    <b>let</b> <i>inode</i> = <i>inode_block</i>[<i>req.ino</i> % <var>INODES_PER_BLOCK</var>]:
        <b>if</b> <i>req.type</i> == "getsize":
            <i>result</i> = <i>inode.size</i>
        <b>else</b>:
            <b>assert</b> <i>req.type</i> == "read"

            <i># Read the direct block.  Return None if there is no direct block.</i>
            <b>if</b> <i>req.offset</i> == 0:
                <b>if</b> <i>inode.direct</i> == <b>None</b>:
                    <i>result</i> = <b>None</b>
                <b>else</b>:
                    <i>result</i> = <var>wal.read</var>(<i>fs_state</i>-&gt;<i>disk</i>, <i>inode.direct</i>)

            <i># Read indirectly.  If there is no indirect block return None</i>
            <b>elif</b> <i>inode.indir</i> == <b>None</b>:
                <i>result</i> = <b>None</b>

            <i># Read the indirect block and get the pointer to the data block,</i>
            <i># which may be None.</i>
            <b>else</b>:
                <b>let</b> <i>indir</i> = <var>wal.read</var>(<i>fs_state</i>-&gt;<i>disk</i>, <i>inode.indir</i>):
                    <b>if</b> <i>indir</i>[<i>req.offset</i> - 1] == <b>None</b>:
                        <i>result</i> = <b>None</b>
                    <b>else</b>:
                        <i>result</i> = <var>wal.read</var>(<i>fs_state</i>-&gt;<i>disk</i>, <i>indir</i>[<i>req.offset</i> - 1])
</code></pre>

</center>
<h4>Figure 22.10. [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] Handling of read-only file requests</h4>


</div>

<a href='#sec-176'>Figure 22.10</a> shows the code for read-only operations on files,
which are currently only (1) getting the size of a file and (2) reading a block
from a file.  In both cases, you first need to read the block that
contains the inode.  Argument <i>ib</i> contains the inode block number,
which is computed by dividing the inode number by <var>INODES_PER_BLOCK</var>
and adding 1 (because the first inode block is block 1).
To get the index of the inode in the block, you need to compute the
remainder of that division.
The <var>getsize</var> request is then trivial as the size is in the inode.
Handling of a <var>read</var> request depends on the offset.  If the offset is 0,
then the request tries to access the data that is in the direct block.
Otherwise, it is necessary to read the indirect block first.
In any block number is <b>None</b> along the way, the response should be
<b>None</b>.<p><div id='sec-177'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i># Handle a write request.  A write lock on i-node block ib has been acquired.</i>
<b>def</b> <var>fs_update_request</var>(<i>fs_state</i>, <i>req</i>, <i>ib</i>):
    <b>assert</b> <i>req.type</i> == "write"
    <b>var</b> <i>allocated</i> = {}      <i># set of allocated blocks (on disk bitmap not yet updated)</i>
    <b>var</b> <i>write_set</i> = {}      <i># set of (block number, data) pairs to be written</i>
    <b>var</b> <i>inode_block</i> = <var>wal.read</var>(<i>fs_state</i>-&gt;<i>disk</i>, 1 + <i>fs_state</i>-&gt;<i>n_bitmap_blocks</i> + <i>ib</i>)
    <b>var</b> <i>inode</i> = <i>inode_block</i>[<i>req.ino</i> % <var>INODES_PER_BLOCK</var>]

    <b>if</b> <i>req.offset</i> == 0:
        <b>if</b> <i>inode.direct</i> == <b>None</b>:
            <i>inode.direct</i> = <var>fs_alloc</var>(<i>fs_state</i>)
            <i>allocated</i> |= { <i>inode.direct</i> } 
            <i>inode.size</i> = <b>max</b>(<i>inode.size</i>, 1)
            <i>inode_block</i>[<i>req.ino</i> % <var>INODES_PER_BLOCK</var>] = <i>inode</i>
            <i>write_set</i> |= { (1 + <i>fs_state</i>-&gt;<i>n_bitmap_blocks</i> + <i>ib</i>, <i>inode_block</i>) }
        <i>write_set</i> |= { (<i>inode.direct</i>, <i>req.data</i>) }
    <b>else</b>:
        <b>if</b> <i>inode.indir</i> == <b>None</b>:
            <i>inode.indir</i> = <var>fs_alloc</var>(<i>fs_state</i>)
            <i>allocated</i> |= { <i>inode.indir</i> } 
            <i>inode.size</i> = <b>max</b>(<i>inode.size</i>, <i>req.offset</i> + 1)
            <i>inode_block</i>[<i>req.ino</i> % <var>INODES_PER_BLOCK</var>] = <i>inode</i>
            <i>write_set</i> |= { (1 + <i>fs_state</i>-&gt;<i>n_bitmap_blocks</i> + <i>ib</i>, <i>inode_block</i>) }
            <b>let</b> <i>bno</i> = <var>fs_alloc</var>(<i>fs_state</i>)
            <b>let</b> <i>indir</i> = [ <i>bno</i> <b>if</b> <i>i</i> == (<i>req.offset</i> - 1) <b>else</b> <b>None</b>
                            <b>for</b> <i>i</i> <b>in</b> { 0 .. <var>INODES_PER_BLOCK</var> - 1 } ]:
                <i>allocated</i> |= { <i>bno</i> }
                <i>write_set</i> |= { (<i>bno</i>, <i>req.data</i>), (<i>inode.indir</i>, <i>indir</i>) }
        <b>else</b>:
            <b>var</b> <i>indir</i> = <var>wal.read</var>(<i>fs_state</i>-&gt;<i>disk</i>, <i>inode.indir</i>)
            <b>if</b> <i>indir</i>[<i>req.offset</i> - 1] == <b>None</b>:
                <i>indir</i>[<i>req.offset</i> - 1] = <var>fs_alloc</var>(<i>fs_state</i>)
                <i>allocated</i> |= { <i>indir</i>[<i>req.offset</i> - 1] }
                <i>write_set</i> |= { (<i>inode.indir</i>, <i>indir</i>) }
            <i>write_set</i> |= { (<i>indir</i>[<i>req.offset</i> - 1], <i>req.data</i>) }
            <b>if</b> <i>inode.size</i> &lt;= <i>req.offset</i>:
                <i>inode.size</i> = <i>req.offset</i> + 1
                <i>inode_block</i>[<i>req.ino</i> % <var>INODES_PER_BLOCK</var>] = <i>inode</i>
                <i>write_set</i> |= { (1 + <i>fs_state</i>-&gt;<i>n_bitmap_blocks</i> + <i>ib</i>, <i>inode_block</i>) }
    <var>wal.update</var>(<i>fs_state</i>-&gt;<i>disk</i>, <i>allocated</i>, <i>write_set</i>)
</code></pre>

</center>
<h4>Figure 22.11. [<a href='https://harmony.cs.cornell.edu/code/file_inode.hny'>code/file_inode.hny</a>] Handling of write requests</h4>


</div>

<div id='sec-178'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>disk</var>

<i># Read a block from the disk</i>
<b>def</b> <var>read</var>(<i>d</i>, <i>bno</i>) <b>returns</b> <i>block</i>:
    <i>block</i> = <var>disk.read</var>(<i>d</i>, <i>bno</i>)

<i># All-or-nothing update of the disk</i>
<i># allocated is a set of block numbers that were allocated.</i>
<i># write_write is a set of (block number, data) pairs.</i>
<b>def</b> <var>update</var>(<i>d</i>, <i>allocated</i>, <i>write_set</i>):
    <b>for</b> <var>alloc</var> <b>in</b> <i>allocated</i>:
        <b>let</b> <i>bno</i> = <var>alloc</var> / <var>disk.BITS_PER_BLOCK</var>
        <b>let</b> <i>off</i> = <var>alloc</var> % <var>disk.BITS_PER_BLOCK</var>:
            <b>var</b> <i>blk</i> = <var>disk.read</var>(<i>d</i>, 1 + <i>bno</i>)
            <b>assert</b> <b>not</b> <i>blk</i>[<i>off</i>]
            <i>blk</i>[<i>off</i>] = <b>True</b>
            <var>disk.write</var>(<i>d</i>, 1 + <i>bno</i>, <i>blk</i>)
    <b>for</b> <i>bno</i>, <i>data</i> <b>in</b> <i>write_set</i>:
        <var>disk.write</var>(<i>d</i>, <i>bno</i>, <i>data</i>)
</code></pre>

</center>
<h4>Figure 22.12. [<a href='https://harmony.cs.cornell.edu/code/wal.hny'>code/wal.hny</a>] Specification of a Write Ahead Log</h4>


</div>

Finally, <a href='#sec-177'>Figure 22.11</a> contains the code to write to a file.
Again, the operation depends on the offset.  It also depends on whether
an existing block is being overwritten or whether a new one must be
allocated.  In some cases, an indirect block must be allocated as well.
Thus, in general, multiple blocks may need to be updated.  A danger is that
the file system may crash (say, due to a power failure) and only update
some of the blocks, leaving the file system inconsistent.<p><a id="index:idempotent:1"></a><p>To overcome this problem, the file system uses a Write-Ahead Log (WAL)
layered over the disk interface.
<a href='#sec-178'>Figure 22.12</a> shows the specification.  In particular,
<var>wal_update</var> takes as argument a disk, a set of numbers identifying
blocks that have been allocated,
and a set of (block number, new contents) pairs
that describe what blocks must be written.
<var>wal_update</var> ensures that either all of the disk updates succeed,
or none of them.  It does this by first logging <i>idempotent</i>
updates in a separate log using a checksum, and then replaying the
updates in the log after a crash.
An update is idempotent if the effect of executing it multiple times is
the same as executing it once.  For example, writing data to a disk block
is idempotent.  Here we do not show how the WAL may be implemented in
practice.  Note that <var>wal_update</var> is aware of the on-disk bitmap.
Also note that <var>wal_update</var> is <i>not</i> atomic.  Concurrent
<var>wal_update</var> operations on the same blocks could cause chaos.
However, the file system's locks will prevent this.<p>Method <var>fs_update_request</var> deals with update requests.  It saves up
any disk updated operations in the variables <i>allocated</i> and <i>write_set</i>,
which are committed to disk using <var>wal_update</var> only when all disk update
operations are known.
Like <var>fs_query_request</var>, the implementation considers various cases.
First it checks if the direct block is updated or an indirect block.
If it is the direct block, it checks to see if it has already been allocated.
Otherwise it needs to check if the indirect block has already been
allocated as well as the data block.  Data blocks, indirect blocks, and
even the inode block may all have to be updated as part of this operation.<p></div>

<div id='sec-179'>
<h1>Chapter 23. Interrupts</h1>


<a id="index:interrupt:1"></a><p>

<p><div id='sec-180'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>count</i> = 0
<i>done</i> = <b>False</b>

<b>finally</b> <i>count</i> == 1

<b>def</b> <var>handler</var>():
    <i>count</i> += 1
    <i>done</i> = <b>True</b>

<b>def</b> <var>main</var>():
    <b>trap</b> <var>handler</var>()
    <b>await</b> <i>done</i>

<b>spawn</b> <var>main</var>()
</code></pre>

</center>
<h4>Figure 23.1. [<a href='https://harmony.cs.cornell.edu/code/trap.hny'>code/trap.hny</a>] How to use <b>trap</b></h4>


</div>

<div id='sec-181'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>count</i> = 0
<i>done</i> = <b>False</b>

<b>finally</b> <i>count</i> == 2

<b>def</b> <var>handler</var>():
    <i>count</i> += 1
    <i>done</i> = <b>True</b>

<b>def</b> <var>main</var>():
    <b>trap</b> <var>handler</var>()
    <i>count</i> += 1
    <b>await</b> <i>done</i>

<b>spawn</b> <var>main</var>()
</code></pre>

</center>
<h4>Figure 23.2. [<a href='https://harmony.cs.cornell.edu/code/trap2.hny'>code/trap2.hny</a>] A race condition with interrupts</h4>


</div>

<div id='sec-182'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>

<i>countlock</i> = <var>Lock</var>()
<i>count</i> = 0
<i>done</i> = <b>False</b>

<b>finally</b> <i>count</i> == 2

<b>def</b> <var>handler</var>():
    <var>acquire</var>(?<i>countlock</i>)
    <i>count</i> += 1
    <var>release</var>(?<i>countlock</i>)
    <i>done</i> = <b>True</b>

<b>def</b> <var>main</var>():
    <b>trap</b> <var>handler</var>()
    <var>acquire</var>(?<i>countlock</i>)
    <i>count</i> += 1
    <var>release</var>(?<i>countlock</i>)
    <b>await</b> <i>done</i>

<b>spawn</b> <var>main</var>()
</code></pre>

</center>
<h4>Figure 23.3. [<a href='https://harmony.cs.cornell.edu/code/trap3.hny'>code/trap3.hny</a>] Locks do not work with interrupts</h4>


</div>

<div id='sec-183'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>count</i> = 0
<i>done</i> = <b>False</b>

<b>finally</b> <i>count</i> == 2

<b>def</b> <var>handler</var>():
    <i>count</i> += 1
    <i>done</i> = <b>True</b>

<b>def</b> <var>main</var>():
    <b>trap</b> <var>handler</var>()
    <b>setintlevel</b>(<b>True</b>)
    <i>count</i> += 1
    <b>setintlevel</b>(<b>False</b>)
    <b>await</b> <i>done</i>

<b>spawn</b> <var>main</var>()
</code></pre>

</center>
<h4>Figure 23.4. [<a href='https://harmony.cs.cornell.edu/code/trap4.hny'>code/trap4.hny</a>] Disabling and enabling interrupts</h4>


</div>

Threads can be <i>interrupted</i>.  An interrupt is a notification
of some event such as a keystroke, a timer expiring, the reception
of a network packet, the completion of a disk operation, and so on.
We distinguish <i>interrupts</i> and <i>exceptions</i>.  An exception
is caused by the thread executing an invalid machine instruction
such as divide-by-zero.  An interrupt is caused by some peripheral
device and can be handled in Harmony.  In other words: an interrupt
is a notification, while an exception is an error.  <a id="index:exception:1"></a><p>Harmony allows modeling interrupts using the <code>trap</code> statement:
<center><b>trap</b> <var>handler</var> <i>argument</i>
</center>
invokes <var>handler</var> <i>argument</i> at some later, unspecified time.
Thus you can think of <b>trap</b> as setting a timer.
Only one of these asynchronous events can be outstanding at a time;
a new call to <b>trap</b> overwrites any outstanding one.
<a href='#sec-180'>Figure 23.1</a> gives an example of how <b>trap</b> might be used.
Here, the <var>main</var>() thread loops until the interrupt has occurred and
the <i>done</i> flag has been set.  After this, <i>count</i> must equal 1.<p>But now consider <a href='#sec-181'>Figure 23.2</a>.  The difference with <a href='#sec-180'>Figure 23.1</a> is
that both the <var>main</var>() and <var>handler</var>() methods increment <i>count</i>.
This is not unlike the example we gave in <a href='#sec-19'>Figure 3.3</a>, except that only a single
thread is involved now.  And, indeed, it suffers from a similar race condition; run
it through Harmony to see for yourself.
If the interrupt occurs after <var>main</var>()
reads <i>count</i> (and thus still has value 0) but before <var>main</var>() writes the
updated value 1, then the interrupt handler will also read value 0 and write value 1.
We say that the code in <a href='#sec-181'>Figure 23.2</a> is not <i>interrupt-safe</i> (as opposed
to not being <i>thread-safe</i>).
<a id="index:interrupt-safety:1"></a><p>You would be excused if you wanted to solve the problem using locks,
similar to <a href='#sec-61'>Figure 8.3</a>.  <a href='#sec-182'>Figure 23.3</a> shows how
one might go about this.  But locks are intended to solve synchronization
issues between multiple threads.  But an interrupt handler is not
run by another thread---it is run by the same thread that experienced
the interrupt.  If you run the code through Harmony, you will find
that the code may not terminate.  The issue is that a thread can
only acquire a lock once.  If the interrupt happens after <var>main</var>()
acquires the lock but before <var>main</var>() releases it, the <var>handler</var>()
method will block trying to acquire the lock, even though it is
being acquired by the same thread that already holds the lock.<p>Instead, the way one fixes interrupt-safety issues is through disabling interrupts
temporarily.  In Harmony, this can be done by setting the <i>interrupt level</i>
of a thread to <b>True</b> using the <b>setintlevel</b> interface.
<a href='#sec-183'>Figure 23.4</a> illustrates how this is done.
Note that it is not necessary to change the interrupt level during servicing an
interrupt, because it is automatically set to <b>True</b> upon entry to the interrupt
handler and restored to <b>False</b> upon exit.
It is important that the <var>main</var>() code re-enables interrupts after incrementing
<i>count</i>.  What would happen if <var>main</var>() left interrupts disabled?<p><b>setintlevel</b>(<i>il</i>) sets the interrupt level to <i>il</i> and returns
the prior interrupt level.  Returning the old level is handy when writing interrupt-safe
methods that can be called from ordinary code as well as from an interrupt handler.
<a href='#sec-184'>Figure 23.5</a> shows how one might write a interrupt-safe method
to increment the counter.<p><div id='sec-184'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>count</i> = 0
<i>done</i> = <b>False</b>

<b>finally</b> <i>count</i> == 2

<b>def</b> <var>increment</var>():
    <b>let</b> <i>prior</i> = <b>setintlevel</b>(<b>True</b>):
        <i>count</i> += 1
        <b>setintlevel</b>(<i>prior</i>)

<b>def</b> <var>handler</var>():
    <var>increment</var>()
    <i>done</i> = <b>True</b>

<b>def</b> <var>main</var>():
    <b>trap</b> <var>handler</var>()
    <var>increment</var>()
    <b>await</b> <i>done</i>

<b>spawn</b> <var>main</var>()
</code></pre>

</center>
<h4>Figure 23.5. [<a href='https://harmony.cs.cornell.edu/code/trap5.hny'>code/trap5.hny</a>] Example of an interrupt-safe method</h4>


</div>

<div id='sec-185'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>

<i>count</i> = 0
<i>countlock</i> = <var>Lock</var>()
<i>done</i> = [ <b>False</b>, <b>False</b> ]

<b>finally</b> <i>count</i> == 4

<b>def</b> <var>increment</var>():
    <b>let</b> <i>prior</i> = <b>setintlevel</b>(<b>True</b>):
        <var>acquire</var>(?<i>countlock</i>)
        <i>count</i> += 1
        <var>release</var>(?<i>countlock</i>)
        <b>setintlevel</b>(<i>prior</i>)

<b>def</b> <var>handler</var>(<i>self</i>):
    <var>increment</var>()
    <i>done</i>[<i>self</i>] = <b>True</b>

<b>def</b> <var>thread</var>(<i>self</i>):
    <b>trap</b> <var>handler</var>(<i>self</i>)
    <var>increment</var>()
    <b>await</b> <i>done</i>[<i>self</i>]

<b>spawn</b> <var>thread</var>(0)
<b>spawn</b> <var>thread</var>(1)
</code></pre>

</center>
<h4>Figure 23.6. [<a href='https://harmony.cs.cornell.edu/code/trap6.hny'>code/trap6.hny</a>] Code that is both interrupt-safe and thread-safe</h4>


</div>

It will often be necessary to write code that is both interrupt-safe <i>and</i>
thread-safe.  As you might expect, this involves both managing locks and
interrupt levels.
To increment <i>count</i>, the interrupt level must be <b>True</b> and
<i>countlock</i> must be held.
<a href='#sec-185'>Figure 23.6</a> gives an example of how this might be done.
One important rule to remember is that a thread should disable interrupts <i>before</i>
attempting to acquire a lock.
Try moving <var>acquire</var>() to the beginning of the <var>increment</var> method
and <var>release</var>() to the end of <var>increment</var> and see what happens.
This incorrect code can lead to threads getting blocked indefinitely.<p>(Another option is to use synchronization techniques that do not use locks.
See <a href='#sec-187'>Chapter 24</a> for more information.)<p>There is another important rule to keep in mind.  Just like locks should never be held
for long, interrupts should never be disabled for long.  With locks the issue is to
maximize concurrent performance.  For interrupts the issue is fast response to
asynchronous events.  Because interrupts may be disabled only briefly, interrupt
handlers must run quickly and cannot wait for other events.

<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-186"><b>[Ex. 23.1]</b>:  The <var>put</var> method you implemented in <a href='#sec-139'>Exercise 18.1</a> cannot be used
in interrupt handlers for two reasons: (1) it is not interrupt-safe, and (2)
it may block for a long time if the buffer is full.  Yet, it would be useful if,
say, a keyboard interrupt handler could place an event on a shared queue.
Implement a new method <var>i_put</var>(<i>item</i>) that does not
block.  Instead, it should return <b>False</b> if the buffer is full and <b>True</b>
if the item was successfully enqueued.
The method also needs to be interrupt-safe.
</ul>
</div>

<div id='sec-187'>
<h1>Chapter 24. Non-Blocking Synchronization</h1>


<a id="index:non-blocking-synchronization:1"></a><p>


<p><a id="gls:non-blocking-synchronization:1"></a><p><div id='sec-188'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>MAX_ITEMS</var> = 3

<b>sequential</b> <i>back</i>, <var>items</var>
<i>back</i> = 0
<var>items</var> = [<b>None</b>,] * <var>MAX_ITEMS</var>

<b>def</b> <var>inc</var>(<i>pcnt</i>) <b>returns</b> <i>prior</i>:
    <b>atomically</b>:
        <i>prior</i> = !<i>pcnt</i>
        !<i>pcnt</i> += 1

<b>def</b> <var>exch</var>(<i>pv</i>) <b>returns</b> <i>prior</i>:
    <b>atomically</b>:
        <i>prior</i> = !<i>pv</i>
        !<i>pv</i> = <b>None</b>

<b>def</b> <var>produce</var>(<i>item</i>):
    <var>items</var>[<var>inc</var>(?<i>back</i>)] = <i>item</i>

<b>def</b> <var>consume</var>() <b>returns</b> <i>next</i>:
    <i>next</i> = <b>None</b>
    <b>while</b> <i>next</i> == <b>None</b>:
        <b>var</b> <i>i</i> = 0
        <b>while</b> (<i>i</i> &lt; <i>back</i>) <b>and</b> (<i>next</i> == <b>None</b>):
            <i>next</i> = <var>exch</var>(?<var>items</var>[<i>i</i>])
            <i>i</i> += 1

<b>for</b> <i>i</i> <b>in</b> {1..MAX_ITEMS}:
    <b>spawn</b> <var>produce</var>(<i>i</i>)
<b>for</b> <i>i</i> <b>in</b> {1..choose({0..MAX_ITEMS})}:
    <b>spawn</b> <var>consume</var>()
</code></pre>

</center>
<h4>Figure 24.1. [<a href='https://harmony.cs.cornell.edu/code/hw.hny'>code/hw.hny</a>] Non-blocking queue</h4>


</div>

So far, we have concentrated on critical sections to synchronize multiple
threads.  Certainly, preventing multiple threads from accessing
certain code at the same time simplifies how to think about synchronization.
However, it can lead to starvation.  Even in the absence of starvation,
if some thread is slow for some reason while being in the critical section,
the other threads have to wait for it to finish executing the critical section.
Also, using synchronization primitives in interrupt handlers is tricky
to get right (<a href='#sec-179'>Chapter 23</a>) and might be too slow.
In this chapter, we will have a look at how one can develop concurrent
code in which threads do not have to wait for other threads (or interrupt
handlers) to complete their ongoing operations.<p>As an example, we will revisit the producer/consumer problem.
The code in <a href='#sec-188'>Figure 24.1</a> is based on code developed by Herlihy and
Wing [<a href="#cite-HW87">23</a>].
The code is a &quot;proof of existence&quot; for non-blocking synchronization; it
is not necessarily practical.
There are two variables.  <var>items</var> is an unbounded array with each
entry initialized to <b>None</b>.  <i>back</i> is an index into the
array and points to the next slot where a new value is inserted.
The code uses two atomic operations:
<ul><li> <var>inc</var>(<i>p</i>): atomically increments !<i>p</i> and returns
the old value;
<li> <var>exch</var>(<i>p</i>): sets !<i>p</i> to <b>None</b> and returns the old value.
</ul>

Method <var>produce</var>(<i>item</i>) uses <var>inc</var>(?<i>back</i>) to allocate
the next available slot in the <var>items</var> array.
It stores the item as a singleton tuple.
Method <var>consume</var>() repeatedly scans the array, up to the
<i>back</i> index, trying to find an item to return.
To check an entry, it uses <var>exch</var>()
to atomically remove an item from a slot if there is one.
This way, if two or more threads attempt to extract an item from
the same slot, at most one will succeed.<p>There is no critical section.  If one thread is executing instructions
very slowly, this does not negatively impact the other threads, as it
would with solutions based on critical sections.
On the contrary, it helps them because it creates less contention.
Unfortunately, the solution is not practical for the following reasons:
<ul><li> The <var>items</var> array must be of infinite size if an unbounded number
of items may be produced;
<li> Each slot in the array is only used once, which is inefficient;
<li> the <var>inc</var> and <var>exch</var> atomic operations are not
universally available on existing processors.
</ul>
However, in the literature you can find examples of practical
non-blocking (aka <i>wait-free</i>)
<a id="index:wait-free-synchronization:1"></a>
synchronization algorithms.


<h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-189"><b>[Ex. 24.1]</b>:  A <i>seqlock</i>
<a id="index:seqlock:1"></a>
consists of a lock and a version number.
An update operation acquires the lock, increments the version number, makes the
changes to the data structure, and then releases the lock.  A read-only operation
does not use the lock.  Instead, it retrieves the version number,
reads the data structure, and then checks if the
version number has changed.  If so, the read-only operation is retried.
Use a seqlock to implement a bank much like <a href='#sec-151'>Exercise 19.2</a>, with
one seqlock for the entire bank (i.e., no locks on individual accounts).
Method <code>transfer</code> is an update operation; method <code>total</code> is a
read-only operation.  Explain how a seqlock can lead to starvation.
</ul>
</div>

<div id='sec-190'>
<h1>Chapter 25. Alternating Bit Protocol</h1>


<a id="index:alternating-bit-protocol:1"></a>
<a id="index:protocol:1"></a>
<a id="index:distributed-system:1"></a><p>







<p><div id='sec-191'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>net_send</var>(<i>pchan</i>, <i>msg</i>):
    <b>atomically</b>:
        !<i>pchan</i> = <i>msg</i> <b>if</b> <b>choose</b>({ <b>False</b>, <b>True</b> }) <b>else</b> ()

<b>def</b> <var>net_recv</var>(<i>pchan</i>) <b>returns</b> <i>msg</i>:
    <b>atomically</b>:
        <i>msg</i> = !<i>pchan</i>
        !<i>pchan</i> = ()

<b>def</b> <var>app_send</var>(<i>net</i>, <i>seq</i>, <i>payload</i>):
    !<i>seq</i> = 1 - !<i>seq</i>
    <b>let</b> <i>m</i> = { .<i>seq</i>: !<i>seq</i>, .<i>payload</i>: <i>payload</i> }:
        <b>var</b> <i>blocked</i> = <b>True</b>
        <b>while</b> <i>blocked</i>:
            <var>net_send</var>(?<i>net</i>-&gt;<i>s_chan</i>, <i>m</i>)
            <b>let</b> <i>response</i> = <var>net_recv</var>(?<i>net</i>-&gt;<i>r_chan</i>):
                <i>blocked</i> = (<i>response</i> == ()) <b>or</b> (<i>response.ack</i> != !<i>seq</i>)
            
<b>def</b> <var>app_recv</var>(<i>net</i>, <i>seq</i>) <b>returns</b> <i>payload</i>:
    !<i>seq</i> = 1 - !<i>seq</i>
    <b>var</b> <i>blocked</i> = <b>True</b>
    <b>while</b> <i>blocked</i>:
        <b>let</b> <i>m</i> = <var>net_recv</var>(?<i>net</i>-&gt;<i>s_chan</i>):
            <b>if</b> <i>m</i> != ():
                <var>net_send</var>(?<i>net</i>-&gt;<i>r_chan</i>, { .<i>ack</i>: <i>m.seq</i> })
                <b>if</b> <i>m.seq</i> == !<i>seq</i>:
                    <i>payload</i> = <i>m.payload</i>
                    <i>blocked</i> = <b>False</b>
</code></pre>

</center>
<h4>Figure 25.1. [<a href='https://harmony.cs.cornell.edu/code/abp.hny'>code/abp.hny</a>] Alternating Bit Protocol</h4>


</div>

<div id='sec-192'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>abp</var>

<b>const</b> <var>NMSGS</var> = 10

<b>invariant</b> <i>s_seq</i> <b>in</b> { 0, 1 }
<b>invariant</b> <i>r_seq</i> <b>in</b> { 0, 1 }

<i>network</i> = { .<i>s_chan</i>: (), .<i>r_chan</i>: () }
<i>s_seq</i> = <i>r_seq</i> = 0

<b>def</b> <var>sender</var>():
    <b>for</b> <i>i</i> <b>in</b> {1..NMSGS}:
        <var>abp.app_send</var>(?<i>network</i>, ?<i>s_seq</i>, <i>i</i>)
    
<b>def</b> <var>receiver</var>():
    <b>var</b> <i>i</i> = 1
    <b>while</b> <b>True</b>:
        <b>let</b> <i>payload</i> = <var>abp.app_recv</var>(?<i>network</i>, ?<i>r_seq</i>):
            <b>assert</b> <i>payload</i> == <i>i</i>
        <i>i</i> += 1

<b>spawn</b> <var>sender</var>()
<b>spawn</b> <b>eternal</b> <var>receiver</var>()
</code></pre>

</center>
<h4>Figure 25.2. [<a href='https://harmony.cs.cornell.edu/code/abptest.hny'>code/abptest.hny</a>] Test code for alternating bit protocol</h4>


</div>

A
<i>distributed system</i>
<a id="index:distributed-system:2"></a>
is a concurrent system in which a collection
of threads communicate by message passing, much the same as
in the actor model.
The most important difference between distributed and concurrent
systems is that the former takes <i>failures</i>
<a id="index:failure:1"></a>
into account,
including failures of threads and failures of shared memory.
In this chapter, we will consider two actors, Alice and Bob.
Alice wants to send a sequence of application messages to Bob,
but the underlying network may lose messages.
<a id="index:network:1"></a>
The network does not re-order messages: when sending messages
 <span 
class="cmmi-10">m</span><sub><span 
class="cmr-7">1</span></sub>  and  <span 
class="cmmi-10">m</span><sub><span 
class="cmr-7">2</span></sub>
 in that order, then if both messages are received,
 <span 
class="cmmi-10">m</span><sub><span 
class="cmr-7">1</span></sub>  is received before  <span 
class="cmmi-10">m</span><sub><span 
class="cmr-7">2</span></sub> .
Also, the network does not create messages out of nothing: if
message <i>m</i> is received, then message <i>m</i> was sent.<p>It is useful to create an abstract network that reliably sends messages
between threads, much like the FIFO queue in the <var>synch</var> module.
For this, we need a network protocol that Alice and Bob can run.
In particular, it has to be the case that if Alice sends application
messages 
<span 
class="cmmi-10">m</span><sub><span 
class="cmr-7">1</span></sub><span 
class="cmmi-10">,...,m</span><sub><span 
class="cmmi-7">n</span></sub>  in that order, then if Bob receives an
application message
<i>m</i>, then  <span 
class="cmmi-10">m </span>= <span 
class="cmmi-10">m</span><sub><span 
class="cmmi-7">i</span></sub>  for some <i>i</i> and, unless  <span 
class="cmmi-10">m </span> is the very first
message, Bob will already have received
application messages  <span 
class="cmmi-10">m</span><sub><span 
class="cmr-7">1</span></sub><span 
class="cmmi-10">,...,m</span><sub><span 
class="cmmi-7">i</span><span 
class="cmsy-7">-</span><span 
class="cmr-7">1</span></sub>  (safety).
Also, if the network is fair and Alice sends application message
<i>m</i>, then eventually Bob should deliver <i>m</i> (liveness).<p>The <i>Alternating Bit Protocol</i> is suitable for our purposes.
We assume that there are two unreliable network channels: one from Alice
to Bob and one from Bob to Alice.
Alice and Bob each maintain a zero-initialized
<i>sequence number</i>,
<a id="index:sequence-number:1"></a>
<i>s_seq</i> and <i>r_seq</i> resp.
Alice sends a network message to Bob containing an
application message as <i>payload</i> and Alice's sequence number
as <i>header</i>.
When Bob receives such a network message, Bob returns an
<i>acknowledgment</i>
<a id="index:acknowledgment:1"></a>
to Alice, which is a network message
containing the same sequence number as in the message that Bob received.<p>In the protocol, Alice keeps sending the same network message until she
receives an acknowledgment with the same sequence number.
This is called <i>retransmission</i>.
<a id="index:retransmission:1"></a>
When she receives the desired sequence number, Alice increments her sequence number.
She is now ready to send the next message she wants to send to Bob.
Bob, on the other hand, waits until he receives a message matching
Bob's sequence number.  If so, Bob <i>delivers</i> the payload in the
message and increments his sequence number.
Because of the network properties,  a one-bit sequence number suffices.<p>We can model each
channel as a variable that either contains a network message or nothing
(we use () to represent nothing in the model).
Let <i>s_chan</i> be the channel
from Alice to Bob and <i>r_chan</i> the channel from Bob to Alice.
<var>net_send</var>(<i>pchan</i>, <i>m</i>) models sending a message <i>m</i> to
!<i>pchan</i>, where <i>pchan</i> is either ?<i>s_chan</i> or ?<i>r_chan</i>.
The method places either <i>m</i> (to model a successful send)
or () (to model loss) in !<i>pchan</i>.
<var>net_recv</var>}(<i>pchan</i>) models checking !<i>pchan</i> for
the next message.  If there is a message, it sets !<i>pchan</i> to ().<p>Method <var>app_send</var>(<i>net</i>, <i>seq</i>, <i>msg</i>) retransmits { .<i>seq</i>: !<i>seq</i>, .<i>payload</i>: <i>msg</i> } until
an acknowledgment for !<i>seq</i> is received.
Method <var>app_recv</var>(<i>net</i>, <i>seq</i>) returns the next successfully received
message (with the given sequence number bit) if any.
<a href='#sec-192'>Figure 25.2</a> shows how the methods may be used to send and receive
a stream of <code>NMSGS</code> messages reliably.
It has to be bounded, because model checking requires a finite model.
Note that the <var>receiver</var>() is spawned as <b>eternal</b> because it
does not terminate.<p>
<h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-193"><b>[Ex. 25.1]</b>:  <a href='#sec-155'>Chapter 20</a> explored the <i>client/server model</i>.  It is popular
in distributed systems as well.
Develop a protocol for a single client and server using the same network
model as for the ABP protocol.
Hint: the response to a request can contain the same sequence number as the
request.
<li id="sec-194"><b>[Ex. 25.2]</b>:  Generalize the solution in the previous exercise to multiple clients.
Each client is uniquely identified.  You may either use separate channel pairs
for each client, or solve the problem using a single pair of channels.
<li id="sec-195"><b>[Ex. 25.3]</b>:  The alternating bit protocol is a special case of a <i>sliding window</i>
protocol with a window size of 1 and using 2 sequence numbers.  TCP uses a sliding
window protocol.  Using a window
size of  <span 
class="cmmi-10">W </span>, a client is able to send  <span 
class="cmmi-10">W</span>
 messages at the same time before
having to wait for an acknowledgment, but you'll need more than  <span 
class="cmmi-10">W </span> sequence
numbers to make it work.  After receiving an acknowledgment, the window can
be moved up.  Implement a sliding window protocol.
</ul>
</div>

<div id='sec-196'>
<h1>Chapter 26. Leader Election</h1>

<p><div id='sec-197'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>NIDS</var> = 5      <i># number of identifiers</i>

<i>network</i> = {}        <i># the network is a set of messages</i>
<var>leader</var> = 0          <i># used for checking correctness</i>

<b>def</b> <var>send</var>(<i>msg</i>):
    <b>atomically</b> <i>network</i> |= { <i>msg</i> }

<b>def</b> <var>receive</var>(<i>self</i>) <b>returns</b> <i>msg</i>:
    <i>msg</i> = { (<i>id</i>, <i>found</i>) <b>for</b> (<i>dst</i>, <i>id</i>, <i>found</i>) <b>in</b> <i>network</i> <b>where</b> <i>dst</i> == <i>self</i> }

<b>def</b> <var>processor</var>(<i>self</i>, <i>succ</i>):
    <var>send</var>(<i>succ</i>, <i>self</i>, <b>False</b>)
    <b>var</b> <i>working</i> = <b>True</b>
    <b>while</b> <i>working</i>:
        <b>atomically</b> <b>when</b> <b>exists</b> (<i>id</i>, <i>found</i>) <b>in</b> <var>receive</var>(<i>self</i>):
            <b>if</b> <i>id</i> == <i>self</i>:
                <b>assert</b> <i>self</i> == <var>leader</var>
                <var>send</var>(<i>succ</i>, <i>id</i>, <b>True</b>)
            <b>elif</b> <i>id</i> &gt; <i>self</i>:
                <b>assert</b> <i>self</i> != <var>leader</var>
                <var>send</var>(<i>succ</i>, <i>id</i>, <i>found</i>)
            <b>if</b> <i>found</i>:
                <i>working</i> = <b>False</b>

<b>var</b> <i>ids</i>, <i>nprocs</i>, <i>procs</i> = { 1 .. <var>NIDS</var> }, <b>choose</b>({ 1 .. <var>NIDS</var> }), []
<b>for</b> <i>i</i> <b>in</b> { 0 .. <i>nprocs</i> - 1 }:
    <b>let</b> <i>next</i> = <b>choose</b>(<i>ids</i>):
        <i>ids</i> -= { <i>next</i> }
        <i>procs</i> += [ <i>next</i>, ]
        <b>if</b> <i>next</i> &gt; <var>leader</var>:
            <var>leader</var> = <i>next</i>
<b>for</b> <i>i</i> <b>in</b> { 0 .. <i>nprocs</i> - 1 }:
    <b>spawn</b> <var>processor</var>(<i>procs</i>[<i>i</i>], <i>procs</i>[(<i>i</i> + 1) % <i>nprocs</i>])
</code></pre>

</center>
<h4>Figure 26.1. [<a href='https://harmony.cs.cornell.edu/code/leader.hny'>code/leader.hny</a>] A leader election protocol on a ring</h4>


</div>

Leader election is the problem of electing a unique leader in a
network of processors.  Typically this is challenging because the
processors have only limited information.  In the version that we
present, each processor has a unique identifier.  The processors
are organized in a ring, but each processor only knows its own
identifier and the identifier of its successor on the ring.  Having
already looked into the problem of how to make the network reliable,
we assume here that each processor can reliably send messages to
its successor.<p>The protocol that we present elects as leader the processor with
the highest identifier [<a href="#cite-CR79">7</a>] and works in two phases: in the
first phase, each processor sends its identifier to its successor.
When a processor receives an identifier that is larger than its own
identifier, it forwards that identifier to its successor as well.
If a processor receives its own identifier, it discovers that it
is the leader.  That processor then starts the second phase by
sending a message around the ring notifying the other processors
of the leader's identifier.<p><a href='#sec-197'>Figure 26.1</a> describes the protocol and its test cases in
Harmony.  In Harmony, processors can be modeled by threads and there
are a variety of ways in which one can model a network using shared
variables.  Here, we model the network as a set of messages.  The
<code>send</code> method atomically adds a message to this set.  Messages
are tuples with three fields: (<i>dst</i>, <i>id</i>, <i>found</i>).  <i>dst</i>
is the identifier of the destination processor; <i>id</i> is the
identifier that is being forwarded; and <i>found</i> is a boolean
indicating the second phase of the protocol.  The <var>receive</var>(<i>self</i>)
method looks for all messages destined for the processor with
identifier <i>self</i>.<p>To test the protocol, the code first chooses the number of processors
and generates an identifier for each
processor, chosen non-deterministically from a set of <code>NIDS</code>
identifiers.  It also keeps track in the variable <var>leader</var> of
what the highest identifier is, so it can later be checked.<p>Method <var>processor</var>(<i>self</i>, <i>succ</i>) is the code for a processor with
identifier <i>self</i> and successor <i>succ</i>.
It starts simply by sending its own identifier to its successor.
The processor then loops until it discovers the identifier of the
leader in the second phase of the protocol.
A processor waits for a message using the Harmony
<b>atomically</b> <b>when</b> <b>exists</b> statement.
This statement takes the form
<center><b>atomically</b> <b>when</b> <b>exists</b> <i>v</i> <b>in</b> <i>s</i>: <i>statement block</i>
</center>
where <i>s</i> is a set and <i>v</i> is variable that is bound to an element of <i>s</i>.
The properties of the statement are as follows:
<ul><li> it waits until <i>s</i> is non-empty;
<li> it is executed atomically;
<li> <i>v</i> is selected non-deterministically, like in the <b>choose</b> operator.
</ul>

If a processor receives its own identifier, it knows its the leader.
The Harmony code checks this using an assertion.
In real code the processor could not do this as it does not know
the identifier of the leader, but assertions are only there to check
correctness.
The processor then sends a message to its successor that the leader
has been found.
If the processor receives an identifier higher than its own, the
processor knows that it cannot be the leader.
In that case, it simply forwards the message.
A processor stops when it receives a message that indicates that
the leader has been identified.<p>Note that there is a lot of non-determinism in the specification, leading
to a lot of executions that must be checked.
First, every possible permutation of identifiers for the processors
is tried.  When there are multiple messages to receive by a processor,
every possible order is tried (including receiving the same message
multiple times).  Fortunately, the <code>atomically when exists</code> statement
is executed
atomically, otherwise the body of the statement could lead to additional
thread interleavings.  Because in practice the different processors do
not share memory, it is not necessary to check those interleavings.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-198"><b>[Ex. 26.1]</b>:  Check if the code finds a unique leader if identifiers are not unique.
<li id="sec-199"><b>[Ex. 26.2]</b>:  Messages are added atomically to the network.  Is this necessary?
What happens if you remove the <b>atomically</b> keyword?  Explain what happens.
</ul>
</div>

<div id='sec-200'>
<h1>Chapter 27. Transactions and Two Phase Commit</h1>

<p><p><div id='sec-201'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>NBANKS</var> = 3
<b>const</b> <var>NCOORDS</var> = 2
<b>const</b> <var>MAX_BALANCE</var> = 1

<i>network</i> = {}

<b>def</b> <var>send</var>(<i>msg</i>):
    <b>atomically</b> <i>network</i> |= { <i>msg</i> }

<b>def</b> <var>bank</var>(<i>self</i>, <i>_balance</i>):
    <b>var</b> <i>balance</i> = <i>_balance</i>
    <b>var</b> <i>status</i>, <i>received</i> = (), {}
    <b>while</b> <b>True</b>:
        <b>atomically</b> <b>when</b> <b>exists</b> <i>req</i> <b>in</b> <i>network</i> - <i>received</i> <b>when</b> <i>req.dst</i> == <i>self</i>:
            <i>received</i> |= { <i>req</i> }
            <b>if</b> <i>req.request</i> == "withdraw":
                <b>if</b> (<i>status</i> != ()) <b>or</b> (<i>req.amount</i> &gt; <i>balance</i>):
                    <var>send</var>({ .<i>dst</i>: <i>req.src</i>, .<i>src</i>: <i>self</i>, .<i>response</i>: "no" })
                <b>else</b>:
                    <i>status</i> = <i>balance</i>
                    <i>balance</i> -= <i>req.amount</i>
                    <var>send</var>({ .<i>dst</i>: <i>req.src</i>, .<i>src</i>: <i>self</i>, .<i>response</i>: "yes", .<i>funds</i>: <i>balance</i> })
            <b>elif</b> <i>req.request</i> == "deposit":
                <b>if</b> <i>status</i> != ():
                    <var>send</var>({ .<i>dst</i>: <i>req.src</i>, .<i>src</i>: <i>self</i>, .<i>response</i>: "no" })
                <b>else</b>:
                    <i>status</i> = <i>balance</i>
                    <i>balance</i> += <i>req.amount</i>
                    <var>send</var>({ .<i>dst</i>: <i>req.src</i>, .<i>src</i>: <i>self</i>, .<i>response</i>: "yes", .<i>funds</i>: <i>balance</i> })
            <b>elif</b> <i>req.request</i> == "commit":
                <b>assert</b> <i>status</i> != ()
                <i>status</i> = ()
            <b>else</b>:
                <b>assert</b> (<i>status</i> != ()) <b>and</b> (<i>req.request</i> == "abort")
                <i>balance</i>, <i>status</i> = <i>status</i>, ()
</code></pre>

</center>
<h4>Figure 27.1. [<a href='https://harmony.cs.cornell.edu/code/2pc.hny'>code/2pc.hny</a>] Two Phase Commit protocol: code for banks</h4>


</div>

<div id='sec-202'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>list</var>

<b>def</b> <var>transfer</var>(<i>self</i>, <i>b1</i>, <i>b2</i>, <i>amt</i>):
    <var>send</var>({ .<i>dst</i>: <i>b1</i>, .<i>src</i>: <i>self</i>, .<i>request</i>: "withdraw", .<i>amount</i>: <i>amt</i> })
    <var>send</var>({ .<i>dst</i>: <i>b2</i>, .<i>src</i>: <i>self</i>, .<i>request</i>: "deposit", .<i>amount</i>: <i>amt</i> })
    <b>atomically</b> <b>let</b> <i>msgs</i> = { <i>m</i> <b>for</b> <i>m</i> <b>in</b> <i>network</i> <b>where</b> <i>m.dst</i> == <i>self</i> }
    <b>when</b> { <i>m.src</i> <b>for</b> <i>m</i> <b>in</b> <i>msgs</i> } == { <i>b1</i>, <i>b2</i> }:
        <b>if</b> <b>all</b>(<i>m.response</i> == "yes" <b>for</b> <i>m</i> <b>in</b> <i>msgs</i>):
            <b>for</b> <i>m</i> <b>in</b> <i>msgs</i> <b>where</b> <i>m.response</i> == "yes":
                <var>send</var>({ .<i>dst</i>: <i>m.src</i>, .<i>src</i>: <i>self</i>, .<i>request</i>: "commit" })
        <b>else</b>:
            <b>for</b> <i>m</i> <b>in</b> <i>msgs</i> <b>where</b> <i>m.response</i> == "yes":
                <var>send</var>({ .<i>dst</i>: <i>m.src</i>, .<i>src</i>: <i>self</i>, .<i>request</i>: "abort" })

<b>def</b> <var>check</var>(<i>self</i>, <var>total</var>):
    <b>let</b> <i>allbanks</i> = { (.<i>bank</i>, <i>i</i>) <b>for</b> <i>i</i> <b>in</b> { 0 .. <var>NBANKS</var> - 1} }:
        <b>for</b> <i>b</i> <b>in</b> <i>allbanks</i>:
            <var>send</var>({ .<i>dst</i>: <i>b</i>, .<i>src</i>: <i>self</i>, .<i>request</i>: "withdraw", .<i>amount</i>: 0 })
        <b>atomically</b> <b>let</b> <i>msgs</i> = { <i>m</i> <b>for</b> <i>m</i> <b>in</b> <i>network</i> <b>where</b> <i>m.dst</i> == <i>self</i> }
        <b>when</b> { <i>m.src</i> <b>for</b> <i>m</i> <b>in</b> <i>msgs</i> } == <i>allbanks</i>:
            <b>assert</b> <b>all</b>(<i>m.response</i> == "yes" <b>for</b> <i>m</i> <b>in</b> <i>msgs</i>) =&gt;
                        (<var>list.sum</var>(<i>m.funds</i> <b>for</b> <i>m</i> <b>in</b> <i>msgs</i>) == <var>total</var>)
            <b>for</b> <i>m</i> <b>in</b> <i>msgs</i> <b>where</b> <i>m.response</i> == "yes":
                <var>send</var>({ .<i>dst</i>: <i>m.src</i>, .<i>src</i>: <i>self</i>, .<i>request</i>: "abort" })

<b>let</b> <i>balances</i> = [ <b>choose</b>({ 0 .. <var>MAX_BALANCE</var> }) <b>for</b> <var>_</var> <b>in</b> { 0 .. <var>NBANKS</var> - 1} ]:
    <b>for</b> <i>i</i> <b>in</b> { 0 .. <var>NBANKS</var> - 1 }:
        <b>spawn</b> <b>eternal</b> <var>bank</var>((.<i>bank</i>, <i>i</i>), <i>balances</i>[<i>i</i>])
    <b>for</b> <i>i</i> <b>in</b> { 1 .. <var>NCOORDS</var> }:
        <b>if</b> <b>choose</b>({ "transfer", "check" }) == .<i>transfer</i>:
            <b>let</b> <i>b1</i> = <b>choose</b>({ (.<i>bank</i>, <i>j</i>) <b>for</b> <i>j</i> <b>in</b> { 0 .. <var>NBANKS</var> - 1}})
            <b>let</b> <i>b2</i> = <b>choose</b>({ (.<i>bank</i>, <i>j</i>) <b>for</b> <i>j</i> <b>in</b> { 0 .. <var>NBANKS</var> - 1}} - { <i>b1</i> }):
                <b>spawn</b> <var>transfer</var>((.<i>coord</i>, <i>i</i>), <i>b1</i>, <i>b2</i>, 1)
        <b>else</b>:
            <b>spawn</b> <var>check</var>((.<i>coord</i>, <i>i</i>), <var>list.sum</var>(<i>balances</i>))
</code></pre>

</center>
<h4>Figure 27.2. [<a href='https://harmony.cs.cornell.edu/code/2pc.hny'>code/2pc.hny</a>] Two Phase Commit protocol: code for transaction coordinators</h4>


</div>

Modern databases support multiple clients concurrently accessing the data.
They store data on disk, but we will ignore that in this book.
(If you want to model a disk, this is probably best done as a separate
thread that maintains the contents of the disk.)
The complication we address here is that databases may be <i>sharded</i>,
where different parts of the data are stored on different servers.
The different servers may even be under different
authoritive domains, such as multiple banks maintaining the accounts of their
clients.<p>In database terminology, a <i>transaction</i> is an operation on a database.
The operation can be quite complex, and the execution of a transaction
should have the following two properties:
<ul><li> <i>all-or-nothing</i>: a transaction should either complete, or it should
be a no-op.  It should never partially execute and then give up because of
some kind of error or something.  Database
people call this <i>atomicity</i>, but it is not the same kind of atomicity that
we have been discussing in this book.
<li> <i>serialized</i>: any two concurrent transactions should appear to
execute in some order.  Database people call this <i>isolation</i>: one transaction
should not be able to witness the intermediate state of another transaction
in execution.
</ul>

We will use as an example a distributed database that maintains bank accounts.
For simplicity, we will model this as a collection of banks,
each maintaining a single account.
There are two kinds of transactions: <i>transfer</i>
(similar to <a href='#sec-151'>Exercise 19.2</a>) and <i>check</i>.  In this example, a transfer
is a transaction that moves some funds between two accounts.
A check is a transaction over all accounts and checks that the sum of the
balances across the accounts remains the same.<p>Executing such transactions must be done with care.  Consider what
would happen if transactions are not all-or-nothing or are not
serialized.  A transfer consists of two operations: withdrawing
funds from one account and depositing the same amount of funds in
the other.  These two operations can be done concurrently, but if
the withdrawal fails (for example, because there are not sufficient
funds in the source account) then the whole transaction should fail
and become a no-op.  Even if this is not the case, a concurrent
check transaction may accidentally witness a state in which either
the withdrawal or the deposit happened, but not both.  And matters
get more complicated with multiple concurrent transfers.<p>The Two-Phase Commit protocol [<a href="#cite-Gray78">21</a>] is a protocol that can be
used to implement transactions across multiple database servers---banks
in this case.
Each transaction has a <i>coordinator</i> that sends a <var>PREPARE</var>
message to each of the servers involved in the transaction, asking them
to prepare to commit to their part in a particular transaction.
A server can either respond with
<var>YES</var> if it is ready to commit and will avoid doing anything
that might jeopardize this (like committing a conflicting transaction),
or with <var>NO</var> if it does not want to participate in the transaction.
If all servers respond with <var>YES</var>, then the coordinator can
decide to <i>commit</i> the transaction.  Otherwise the coordinator
must decide to <i>abort</i> the transaction.  In the second phase, the
servers that responded with <var>YES</var> (if any) must be notified
to inform them of the coordinator's decision.<p>Different transactions can have different coordinators.  In our
implementation, each bank and each coordinator is a thread.
<a href='#sec-201'>Figure 27.1</a> shows the code for a bank.
The state of a bank consists of the following local variables:
<ul><li> <i>self</i>: the bank's identifier;
<li> <i>balance</i>: the current balance in the account;
<li> <i>status</i>: either contains () if the bank is not involved in an
ongoing transaction or contains the balance
just before the transaction started;
<li> <i>received</i>: the set of messages received and handled so far.
</ul>


Messages sent to a bank are dictionaries with the following fields:
<ul><li> .<i>dst</i>: identifier of the bank;
<li> .<i>src</i>: identifier of the coordinator that sent the message;
<li> .<i>request</i>: request type, which is either
.<i>withdraw</i>, .<i>deposit</i>, .<i>commit</i>, or .<i>abort</i>;
<li> .<i>amount</i>: amount to withdraw or deposit.
</ul>


A bank waits for a message destined to itself that it has not yet received.
In case of a withdrawal when the bank is idle and there are sufficient
funds, the bank saves the current balance in <i>status</i> to indicate
an ongoing transaction and what its original balance was.
The bank then responds with a .<i>yes</i> message to the coordinator,
including the new balance.
Otherwise, the bank responds with a .<i>no</i> message.
Deposits are similar, except that it is not necessary to check for
sufficient funds.
In case of a .<i>commit</i> message, the bank changes its status
to (), indicating that there is no ongoing transaction.  In case of
a .<i>abort</i> message, the bank restores <i>balance</i> first.<p><a href='#sec-202'>Figure 27.2</a> contains the code for transfers and inquiries, as well
as tests.
The <var>receive</var>() method is used by coordinators in an
<b>atomically</b> <b>when</b> <b>exists</b>
statement to wait for a response from each bank involved in a transaction.
Argument <code>self</code> is the
identifier of the coordinator and <code>sources</code> is the set of banks.
It returns the empty set if there not yet responses from all banks.
Otherwise it returns a singleton set containing the set of responses,
one for each source.<p>The <code>transfer</code>() method contains the code for the transfer
transaction.  Argument <i>self</i> is the identifier of the coordinator,
<i>b1</i> is the source bank, <i>b2</i> is the destination bank,
and <i>amt</i> is the amount to transfer.
The coordinator sends a <var>PREPARE</var> message containing a
.<i>withdraw</i> request to <i>b1</i> and a <var>PREPARE</var>
message containing a .<i>deposit</i> request to <i>b2</i>.
It then waits for responses from each.  If both responses are
.<i>yes</i>, then it commits the transaction, otherwise it aborts
the transaction.<p>The <code>check</code>() method checks if the sum of the balances equals
<var>total</var>, the sum of the initial balances.
The code is similar to <var>transfer</var>, except that it always
aborts the transaction---there is no need to ever commit it.
As a code-saving hack: the balance inquiry is done by withdrawing $0.<p>As for testing, the initial balances are picked arbitrarily between
0 and <code>MAX_BALANCE</code> (and Harmony as always will try every
possible set of choices).
Each coordinator chooses whether to do a transfer or a check.  In
case of a transfer, it also chooses the source bank and the destination
bank.<p>While the protocol perhaps seems simple enough, there are a lot of
<b>if</b> statements in the code, making it hard to reason about
correctness.
Model checking is useful to see if there are corner
cases where the code does not work.
While confidence increases by
increasing the number of banks or the number of coordinators, doing so
quickly increases the number of possible states so that model checking
may become infeasible.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-203"><b>[Ex. 27.1]</b>:  In <a href='#sec-151'>Exercise 19.2</a> the code ran into a deadlock.  Can the code
in this chapter run into a deadlock?  Explain.
<li id="sec-204"><b>[Ex. 27.2]</b>:  Transactions can fail for two reasons: a transfer transaction can
fail because of insufficient funds, but in general transaction can fail
if there is a conflict with another transaction.  The latter can be
fixed by retrying the transaction until it commits.  Implement this.
<li id="sec-205"><b>[Ex. 27.3]</b>:  One way to reduce the number of conflicts between transactions
is to distinguish read and write operations.  Two read operations
(in our case, operations that withdraw $0 do not conflict,
so a bank could have multiple ongoing read operations
for different transactions.  Implement this.
<li id="sec-206"><b>[Ex. 27.4]</b>:  Two-phase commit can tolerate servers failing.  If a server does not
respond within some reasonable amount of time, the coordinator can abort
the transaction.  Implement this.
</ul>
</div>

<div id='sec-207'>
<h1>Chapter 28. Chain Replication</h1>

<p>
<p><div id='sec-208'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>NREPLICAS</var> = 3     <i># number of replicas</i>
<b>const</b> <var>NOPS</var> = 2          <i># number of operations</i>

<i>network</i> = []            <i># the network is a queue of messages</i>

<b>def</b> <var>crash</var>():
    <b>stop</b>()

<b>def</b> <var>send</var>(<i>msg</i>):
    <b>atomically</b> <i>network</i> += [<i>msg</i>,]

<b>def</b> <var>replica</var>(<i>self</i>, <i>immortal</i>):
    <b>if</b> <b>not</b> <i>immortal</i>:
        <b>trap</b> <var>crash</var>()
    <b>var</b> <i>delivered</i> = 0
    <b>while</b> <b>True</b>:
        <b>atomically</b> <b>when</b> <b>len</b>(<i>network</i>) &gt; <i>delivered</i>:
            <b>let</b> <i>msg</i> = <i>network</i>[<i>delivered</i>]:
                <b>print</b>(<i>self</i>, <i>msg</i>)
                <i>delivered</i> += 1

<b>def</b> <var>client</var>(<i>self</i>):
    <b>print</b>(<i>self</i>)
    <var>send</var>(<i>self</i>)

<b>let</b> <i>immortal</i> = <b>choose</b> {1..NREPLICAS}:
    <b>for</b> <i>i</i> <b>in</b> {1..NREPLICAS}:
        <b>spawn</b> <b>eternal</b> <var>replica</var>(<i>i</i>, <i>i</i> == <i>immortal</i>)
<b>for</b> <i>i</i> <b>in</b> {1..NOPS}:
    <b>spawn</b> <var>client</var>(<i>i</i>)
</code></pre>

</center>
<h4>Figure 28.1. [<a href='https://harmony.cs.cornell.edu/code/rsm.hny'>code/rsm.hny</a>] Replicated State Machine</h4>


</div>

<div id='sec-209'>
<center><img src="figures/rsmspec.png" width="100%"></img>
</center>
<h4>Figure 28.2. The DFA generated by <a href='#sec-208'>Figure 28.1</a> when <var>NOPS</var>=2
and <var>NREPLICAS</var>=2</h4>


</div>


<p><div id='sec-210'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>NREPLICAS</var> = 3     <i># number of replicas</i>
<b>const</b> <var>NOPS</var> = 2          <i># number of operations (or clients)</i>

<i>network</i> = {}            <i># the network is a set of messages</i>

<b>def</b> <var>send</var>(<i>self</i>, <i>dst</i>, <i>msg</i>):           <i># send msg to replica dst</i>
    <b>atomically</b> <i>network</i> |= { (<i>dst</i>, (<i>self</i>, <i>msg</i>)) }

<b>def</b> <var>broadcast</var>(<i>self</i>, <i>msg</i>):           <i># broadcast msg to all</i>
    <b>atomically</b> <b>for</b> <i>dst</i> <b>in</b> {1..NREPLICAS}:
        <i>network</i> |= { (<i>dst</i>, (<i>self</i>, <i>msg</i>)) }

<b>def</b> <var>receive</var>(<i>self</i>) <b>returns</b> <i>msgs</i>:     <i># return messages for me</i>
    <i>msgs</i> = { <i>payload</i> <b>for</b> (<i>dst</i>, <i>payload</i>) <b>in</b> <i>network</i> <b>where</b> (<i>dst</i> == <i>self</i>) }

<b>def</b> <var>crash</var>(<i>self</i>):                    <i># server 'self' is crashing</i>
    <var>broadcast</var>(<i>self</i>, "crash")        <i># notify all other replicas</i>
    <b>stop</b>()

<b>def</b> <var>is_prefix</var>(<i>hist1</i>, <i>hist2</i>) <b>returns</b> <i>result</i>: <i># hist1 is a strict prefix of hist2</i>
    <i>result</i> = (<b>len</b>(<i>hist1</i>) &lt; <b>len</b>(<i>hist2</i>)) <b>and</b>
                <b>all</b>(<i>hist1</i>[<i>i</i>] == <i>hist2</i>[<i>i</i>] <b>for</b> <i>i</i> <b>in</b> {0..len(<i>hist1</i>)-1})
</code></pre>

</center>
<h4>Figure 28.3. [<a href='https://harmony.cs.cornell.edu/code/chain.hny'>code/chain.hny</a>] Chain Replication (part 1)</h4>


</div>

<div id='sec-211'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>NREPLICAS</var> = 3     <i># number of replicas</i>
<b>const</b> <var>NOPS</var> = 2          <i># number of operations (or clients)</i>

<i>network</i> = {}            <i># the network is a set of messages</i>

<b>def</b> <var>send</var>(<i>self</i>, <i>dst</i>, <i>msg</i>):           <i># send msg to replica dst</i>
    <b>atomically</b> <i>network</i> |= { (<i>dst</i>, (<i>self</i>, <i>msg</i>)) }

<b>def</b> <var>broadcast</var>(<i>self</i>, <i>msg</i>):           <i># broadcast msg to all</i>
    <b>atomically</b> <b>for</b> <i>dst</i> <b>in</b> {1..NREPLICAS}:
        <i>network</i> |= { (<i>dst</i>, (<i>self</i>, <i>msg</i>)) }

<b>def</b> <var>receive</var>(<i>self</i>) <b>returns</b> <i>msgs</i>:     <i># return messages for me</i>
    <i>msgs</i> = { <i>payload</i> <b>for</b> (<i>dst</i>, <i>payload</i>) <b>in</b> <i>network</i> <b>where</b> (<i>dst</i> == <i>self</i>) }

<b>def</b> <var>crash</var>(<i>self</i>):                    <i># server 'self' is crashing</i>
    <var>broadcast</var>(<i>self</i>, "crash")        <i># notify all other replicas</i>
    <b>stop</b>()

<b>def</b> <var>is_prefix</var>(<i>hist1</i>, <i>hist2</i>) <b>returns</b> <i>result</i>: <i># hist1 is a strict prefix of hist2</i>
    <i>result</i> = (<b>len</b>(<i>hist1</i>) &lt; <b>len</b>(<i>hist2</i>)) <b>and</b>
                <b>all</b>(<i>hist1</i>[<i>i</i>] == <i>hist2</i>[<i>i</i>] <b>for</b> <i>i</i> <b>in</b> {0..len(<i>hist1</i>)-1})
</code></pre>

</center>
<h4>Figure 28.4. [<a href='https://harmony.cs.cornell.edu/code/chain.hny'>code/chain.hny</a>] Chain Replication (part 2)</h4>


</div>

<a id="gls:replication:1"></a>
<a id="index:replication:1"></a>
As you have probably experienced, computers can crash.
If you are running a web service, you may not be able to afford
a long outage.  If you are running software that flies a plane,
then an outage for any length of time could lead to a disaster.
To deal with service outages caused by computers crashing, you may want
to <i>replicate</i> the service onto multiple computers.  As long as
one of the computers survives, the service remains available.<p><a id="gls:state-machine-replication:1"></a>
<a id="index:state-machine-replication:1"></a>
<a id="index:determinism:2"></a>
Besides availability, it is usually important that the replicated
service acts as if it were a single one.  This requires that the
replicas of the service coordinate their actions.
The <i>Replicated State Machine Approach</i> [<a href="#cite-Lam78">28</a>, <a href="#cite-S90">40</a>] is a
general approach to do just this.
First, you model your service as a deterministic state
machine.  The replicas each run a copy of the state machine, started
in the same state.  As long as the replicas handle the same inputs
in the same order, determinism guarantees that they produce the same
outputs in the same order.<p><a href='#sec-208'>Figure 28.1</a> presents a Harmony specification of state machine
replication.
We model the state machine as a <i>history</i>: a sequence of operations.
In a replicated state machine, the abstract network maintains this
history as an ordered queue of messages.
<var>NOPS</var> clients each place an operation on the network.
The replicas process messages from the ordered network.<p>All but one of the replicas is allowed to crash.
Crashes are modeled as interrupts, so we use Harmony's <b>trap</b> clause
to schedule one.  When crashing, a replica simply stops.
The model chooses one of the replicas that is not allowed to crash.
Of course, a replica does not know whether it is immortal
or not in practice---it should just assume that it is.
The immortality of one of the replicas is only used for modeling
the assumptions we make about the system.<p>The behavior is captured as before.  Before an operation is added to
the network, a client prints the operation (in this case, its own
identifier).  After a replica processes an operation, it prints a
pair consisting of its own identifier and the operation.  All replicas
print the same operations in the same order until they crash.
<a href='#sec-209'>Figure 28.2</a> shows the allowed behaviors in case there are just
two clients and two replicas.  Because one of the replicas is immortal and
clients do not crash, at least one of the replicas will print both
operations (liveness).  If both do, they do so in the same order (safety).<p>But in reality the network is not an ordered queue and better modeled
as a set of messages.
The trick now is to ensure that all replicas handle the
same requests in the same order and to do so in a way that continues
to work even if some strict subset of replicas crash.
<i>Chain Replication</i> [<a href="#cite-vRS04">42</a>] is such a replication protocol.
In Chain Replication, the replicas are organized in a linear chain
which may change as replicas crash.
Importantly, at any point in time there is only one <i>head</i> and
one <i>tail</i> replica.<p>Only the head is allowed to accept new operations from clients.
When it does so, it adds the operation to the end of its history
and sends the history to its successor on the chain.
When the direct successor receives such a history, it makes sure
that the history is an extension of its own and, if so, replaces its own
history with the one received.
It then sends the history on to its successor, if any.
When an operation reaches the tail, the operation is what is known as
<i>stable</i>---it has been reliably ordered and persisted.<p>In order for this to work, each replica needs to know who is its
predecessor and who is its successor.
So, when a replica fails, its neighbors should find out about it.
In practice, one server can detect the failure of another server by
pinging it.  If a server does not receive a response to its ping within
some maximum amount of time, then the server considers its peer crashed.
Note that this, in general, is not a safe thing to do---the network or
the peer may be temporarily slow but the peer is not necessarily crashed
when the timer expires.<p>Nonetheless, we will assume here that failure detection does not make
mistakes and that eventually every failure is detected.
This is called the <i>Fail-Stop</i> failure model [<a href="#cite-SS83">39</a>],
which is distinct from the often more realistic <i>Crash Failure</i> model
where processes can crash but accurate detection is not available.
We will consider that more realistic failure model in the upcoming chapters.
For chain replication, when a replica crashes, it will reliably notify
the other replicas by broadcasting a message over the reliable network.
Because failure detection is accurate, at most one replica can think
it is the head at any time (and, if so, it is in fact the head).
Moreover, when it has
detected all its predecessors having failed, eventually some replica
thinks it is the head.
The same is true for the tail.<p><a href='#sec-210'>Figure 28.3</a> and <a href='#sec-211'>Figure 28.4</a> show an implemenation of
chain replication.
The network is modeled as a append-only set of messages of the form
(<i>destination</i>, (<i>source</i>, <i>payload</i>)).  When sending, a message is
atomically added to this set.
A client broadcasts its operation to all replicas.<p>Each replica maintains its own history <i>hist</i> and a chain
configuration <i>config</i>.  The replica executes a loop in which it
receives and atomically handles messages until it crashes.  As before,
one of the replicas cannot crash.
Because replicas do not want to handle the same message
twice, each replica maintains a set <i>received</i> of messages it has
already handled.  Each replica then waits for a message on the network
it has not already handled before.<p>When a replica receives a client request, it adds the request to a
set <i>requests</i> that it maintains.  A replica can only handle such a
request if it is the head, but each replica can eventually become the
head so it should carefully save all requests.  (In theory, it can
remove them as soon as they are on its history.)
When a replica receives a failure notification, it updates its configuration
accordingly.
When a non-head replica receives a history that extends its own history,
then the replica adopts the received history.<p>Next, if a replica is the head, it adds any requests it has received
to its history unless they are already on there.
If a replica is the tail, it &quot;delivers&quot; operations on its history
(by printing the operation) that it has not already delivered.
For this, it maintains a counter <i>delivered</i> that counts the number
of delivered requests.
Any replica that is not the tail sends its history to its successor
in the chain.<p>The question is whether chain replication has the same behavior as
the replicated state machine specification of <a href='#sec-208'>Figure 28.1</a>.
This can be checked using the following two Harmony commands:<p><center><pre><code class="language-none">$ harmony -o rsm.hfa code/rsm.hny
$ harmony -B rsm.hfa code/chain.hny
</code></pre>
</center>

The first command outputs the behavior DFA of <code>code/rsm.hny</code>
in the file <code>rsm.hfa</code>.
The second command checks that the behavior of <code>code/chain.hny</code>
satisfies the DFA in <code>rsm.hfa</code>.
Note that chain replication does not produce all the possible behaviors
of a replicated state machine, but all its behaviors are valid.<p>The model has each replica send its entire history each time it extends
its history.  This is fine for modeling, but in practice that would not
scale.  In practice, a predecessor would set up a TCP connection to
its successor and only send updates to its history along the TCP
connection.  Because TCP connections guarantee FIFO order, this would
be identical to the predecessor sending a series of histories, but
much more efficient.
</div>

<div id='sec-212'>
<h1>Chapter 29. Working with Actions</h1>

<p>


















<p><div id='sec-213'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>list</var>, <var>action</var>

<b>const</b> <var>NREPLICAS</var> = 3
<b>const</b> <var>NOPS</var> = 2

<i># Global state</i>
<b>let</b> <i>immortal</i> = <b>choose</b> {1..NREPLICAS}:
    <i>replicas</i> = { <i>p</i>: { .<i>immortal</i>: <i>immortal</i> == <i>p</i>, .<i>crashed</i>: <b>False</b>,
                .<i>requests</i>: {}, .<i>hist</i>: [], .<i>config</i>: {1..NREPLICAS},
                .<i>received</i>: {}, .<i>delivered</i>: 0 } <b>for</b> <i>p</i> <b>in</b> {1..NREPLICAS} }
<i>clients</i> = { <i>c</i>: { .<i>sent_request</i>: <b>False</b> } <b>for</b> <i>c</i> <b>in</b> {1..NOPS} }

<b>const</b> <var>is_head</var> = <b>lambda</b>(<i>p</i>): <i>p</i> == <b>min</b>(<i>replicas</i>[<i>p</i>].<i>config</i>) <b>end</b>
<b>const</b> <var>is_tail</var> = <b>lambda</b>(<i>p</i>): <i>p</i> == <b>max</b>(<i>replicas</i>[<i>p</i>].<i>config</i>) <b>end</b>

<b>def</b> <var>is_successor</var>(<i>self</i>, <i>p</i>) <b>returns</b> <i>result</i>:
    <b>let</b> <i>succ</i> = { <i>q</i> <b>for</b> <i>q</i> <b>in</b> <i>replicas</i>[<i>self</i>].<i>config</i> <b>where</b> <i>q</i> &gt; <i>self</i> }:
        <i>result</i> = <b>False</b> <b>if</b> <i>succ</i> == {} <b>else</b> (<i>p</i> == <b>min</b>(<i>succ</i>))

<b>def</b> <var>do_sendOperation</var>(<i>c</i>):
    <b>print</b>(<i>c</i>)
    <i>clients</i>[<i>c</i>].<i>sent_request</i> = <b>True</b>
    <b>for</b> <i>p</i> <b>in</b> {1..NREPLICAS}:
        <i>replicas</i>[<i>p</i>].<i>requests</i> |= { <i>c</i> }

<b>const</b> <var>sendOperation</var> = <b>lambda</b>(): { ?<var>do_sendOperation</var>(<i>c</i>)
    <b>for</b> <i>c</i> <b>in</b> {1..NOPS} <b>where</b> <b>not</b> <i>clients</i>[<i>c</i>].<i>sent_request</i> } <b>end</b>

<b>def</b> <var>do_gotOperation</var>(<i>self</i>, <i>op</i>):
    <i>replicas</i>[<i>self</i>].<i>hist</i> += [<i>op</i>,]

<b>const</b> <var>gotOperation</var> = <b>lambda</b>(): { ?<var>do_gotOperation</var>(<i>p</i>, <i>op</i>)
    <b>for</b> <i>p</i> <b>in</b> {1..NREPLICAS}
      <b>where</b> <b>not</b> <i>replicas</i>[<i>p</i>].<i>crashed</i> <b>and</b> <var>is_head</var>(<i>p</i>)
    <b>for</b> <i>op</i> <b>in</b> <i>replicas</i>[<i>p</i>].<i>requests</i>
      <b>where</b> <i>op</i> <b>not</b> <b>in</b> <i>replicas</i>[<i>p</i>].<i>hist</i> } <b>end</b>

<b>def</b> <var>do_sendHist</var>(<i>self</i>, <i>p</i>):
    <i>replicas</i>[<i>p</i>].<i>received</i> |= { <i>replicas</i>[<i>self</i>].<i>hist</i> }
</code></pre>

</center>
<h4>Figure 29.1. [<a href='https://harmony.cs.cornell.edu/code/chainaction.hny'>code/chainaction.hny</a>] Chain Replication specification using actions (part 1)</h4>


</div>

<div id='sec-214'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>sendHist</var> = <b>lambda</b>(): { ?<var>do_sendHist</var>(<i>p</i>, <i>q</i>)
    <b>for</b> <i>p</i> <b>in</b> {1..NREPLICAS}
      <b>where</b> <b>not</b> <i>replicas</i>[<i>p</i>].<i>crashed</i>
    <b>for</b> <i>q</i> <b>in</b> {1..NREPLICAS}
      <b>where</b> <var>is_successor</var>(<i>p</i>, <i>q</i>) <b>and</b> (<i>replicas</i>[<i>p</i>].<i>hist</i> <b>not</b> <b>in</b> <i>replicas</i>[<i>q</i>].<i>received</i>)
  } <b>end</b>

<b>def</b> <var>do_gotHist</var>(<i>self</i>, <i>hist</i>):
    <i>replicas</i>[<i>self</i>].<i>hist</i> = <i>hist</i>

<b>const</b> <var>gotHist</var> = <b>lambda</b>(): { ?<var>do_gotHist</var>(<i>p</i>, <i>hist</i>)
    <b>for</b> <i>p</i> <b>in</b> {1..NREPLICAS} <b>where</b> <b>not</b> <i>replicas</i>[<i>p</i>].<i>crashed</i>
    <b>for</b> <i>hist</i> <b>in</b> <i>replicas</i>[<i>p</i>].<i>received</i> <b>where</b> (<b>len</b>(<i>replicas</i>[<i>p</i>].<i>hist</i>) &lt; <b>len</b>(<i>hist</i>))
                        <b>and</b> <var>list.startswith</var>(<i>hist</i>, <i>replicas</i>[<i>p</i>].<i>hist</i>) } <b>end</b>

<b>def</b> <var>do_deliver</var>(<i>self</i>):
    <b>print</b>(<i>self</i>, <i>replicas</i>[<i>self</i>].<i>hist</i>[<i>replicas</i>[<i>self</i>].<i>delivered</i>])
    <i>replicas</i>[<i>self</i>].<i>delivered</i> += 1

<b>const</b> <var>deliver</var> = <b>lambda</b>(): { ?<var>do_deliver</var>(<i>p</i>)
    <b>for</b> <i>p</i> <b>in</b> {1..NREPLICAS} <b>where</b> <b>not</b> <i>replicas</i>[<i>p</i>].<i>crashed</i> <b>and</b>
        <var>is_tail</var>(<i>p</i>) <b>and</b> (<b>len</b>(<i>replicas</i>[<i>p</i>].<i>hist</i>) &gt; <i>replicas</i>[<i>p</i>].<i>delivered</i>) } <b>end</b>

<b>def</b> <var>do_crash</var>(<i>self</i>):
    <i>replicas</i>[<i>self</i>].<i>crashed</i> = <b>True</b>

<b>const</b> <var>crash</var> = <b>lambda</b>(): { ?<var>do_crash</var>(<i>p</i>)
    <b>for</b> <i>p</i> <b>in</b> {1..NREPLICAS}
        <b>where</b> <b>not</b> <i>replicas</i>[<i>p</i>].<i>crashed</i> <b>and</b> <b>not</b> <i>replicas</i>[<i>p</i>].<i>immortal</i> } <b>end</b>

<b>def</b> <var>do_detect</var>(<i>self</i>, <i>p</i>):
    <i>replicas</i>[<i>self</i>].<i>config</i> -= { <i>p</i> }

<b>const</b> <var>detect</var> = <b>lambda</b>(): { ?<var>do_detect</var>(<i>p</i>, <i>q</i>)
    <b>for</b> <i>p</i> <b>in</b> {1..NREPLICAS} <b>where</b> <b>not</b> <i>replicas</i>[<i>p</i>].<i>crashed</i>
    <b>for</b> <i>q</i> <b>in</b> {1..NREPLICAS} <b>where</b> <i>replicas</i>[<i>q</i>].<i>crashed</i> <b>and</b>
                (<i>q</i> <b>in</b> <i>replicas</i>[<i>p</i>].<i>config</i>) } <b>end</b>

<var>action.explore</var>({<var>sendOperation</var>, <var>gotOperation</var>, <var>sendHist</var>,
                    <var>gotHist</var>, <var>deliver</var>, <var>crash</var>, <var>detect</var>})
</code></pre>

</center>
<h4>Figure 29.2. [<a href='https://harmony.cs.cornell.edu/code/chainaction.hny'>code/chainaction.hny</a>] Chain Replication specification using actions (part 2)</h4>


</div>

So far we have mostly modeled concurrent activities using threads.
Another way of modeling is by enumerating all the possible state
transitions from any given state.  For example, this is how things
are commonly specified in TLA+.  As in TLA+, we call such state transitions 
<i>actions</i>.
In this chapter we will revisit modeling chain replication, but this time
using actions.<p><a id="index:action:1"></a><p><a href='#sec-213'>Figure 29.1</a> and <a href='#sec-214'>Figure 29.2</a> contain
the new specification.  The state of the replicas and the clients
are stored in the variables <i>replicas</i> and <i>clients</i> respectively.
Each type of action is captured using a lambda and a method.  The method
updates the state, while the lambda enumerates the possible actions of
this type.<p><a id="index:thunk:1"></a><p>For example, consider the <i>crash</i> action.  All replicas, except
the replica that is immortal and the replicas that have already crashed,
can crash.  There is a lambda <var>crash</var> that generates a set of all
possible crashes.  Each element in the set is a <i>thunk</i>, that is,
a delayed call of a method and an argument  [<a href="#cite-Ingerman61">27</a>].
For example, ?<var>do_crash</var>(1) is the
action representing replica 1 failing.  If we look at the <var>do_crash</var>(<i>p</i>)
method, all it does is set the <i>crashed</i> field of the replica.
The specification does this for every type of action:<p><ul><li> <var>sendOperation</var>: a client broadcasts an operation to all replicas.
<li> <var>gotOperation</var>: the head replica adds the operation to its history.
<li> <var>sendHist</var>: a replica sends its history to its successor.
<li> <var>gotHist</var>: a replica accepts a history it has received.
<li> <var>deliver</var>: the tail delivers (prints) an operation. 
<li> <var>crash</var>: a replica crashes.
<li> <var>detect</var>: a replica detects the crash of a peer.
</ul>


The Harmony <var>action</var> module explores all possible behaviors of
such a specification.  It has a single method <var>explore</var> that takes
a set of lambdas, each of which returning a set of possible actions.<p>So, which of the two types of specification do you prefer?
One metric is readability, but that is subjective and depends on
what you have experience with.
Another object is the size of the state space, and in general control
over the state space that is being explored.
Threads have hidden state such as their stacks, program counters,
and local variables, adding to the state space in sometimes unexpected
ways.
With an action-based specification all state is explicit, and all
state changes are explicit.  This can be advantageous.
On the other hand, the thread-based specification is easier to turn
into an actual running implementation.
</div>

<div id='sec-215'>
<h1>Chapter 30. Replicated Atomic Read/Write Register</h1>

<p>





<p><div id='sec-216'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>reg</i> = <b>None</b>

<b>def</b> <var>init</var>():
    <b>pass</b>

<b>def</b> <var>read</var>(<i>uid</i>) <b>returns</b> <i>contents</i>:
    <b>atomically</b> <i>contents</i> = <i>reg</i>

<b>def</b> <var>write</var>(<i>uid</i>, <i>v</i>):
    <b>atomically</b> <i>reg</i> = <i>v</i>
</code></pre>

</center>
<h4>Figure 30.1. [<a href='https://harmony.cs.cornell.edu/code/register.hny'>code/register.hny</a>] An atomic read/write register</h4>


</div>

<div id='sec-217'>
<center><img src="figures/abdtest.png" width="100%"></img>
</center>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>register</var>

<b>const</b> <var>NREADERS</var> = 2
<b>const</b> <var>NWRITERS</var> = 1

<b>def</b> <var>reader</var>(<i>i</i>):
    <b>print</b>(<i>i</i>, "reads")
    <b>let</b> <i>v</i> = <var>register.read</var>(<i>i</i>):
        <b>print</b>(<i>i</i>, "read", <i>v</i>)
 
<b>def</b> <var>writer</var>(<i>i</i>):
    <b>print</b>(<i>i</i>, "writes")
    <var>register.write</var>(<i>i</i>, <i>i</i>)
    <b>print</b>(<i>i</i>, "wrote")
        
<var>register.init</var>()
<b>for</b> <i>i</i> <b>in</b> { 1 .. <var>NREADERS</var> }:
    <b>spawn</b> <var>reader</var>(<i>i</i>)
<b>for</b> <i>i</i> <b>in</b> { 1 .. <var>NWRITERS</var> }:
    <b>spawn</b> <var>writer</var>(-<i>i</i>)
</code></pre>

</center>
<h4>Figure 30.2. [<a href='https://harmony.cs.cornell.edu/code/abdtest.hny'>code/abdtest.hny</a>] Behavioral test for atomic read/write registers and the output for the case that <var>NREADERS</var> = <var>NWRITERS</var> = 1</h4>


</div>

<div id='sec-218'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>bag</var>

<b>const</b> <var>F</var> = 1
<b>const</b> <var>N</var> = (2 * <var>F</var>) + 1

<i>network</i> = <var>bag.empty</var>()

<b>def</b> <var>send</var>(<i>m</i>): <b>atomically</b> <i>network</i> = <var>bag.add</var>(<i>network</i>, <i>m</i>)

<b>def</b> <var>server</var>():
    <b>var</b> <i>t</i>, <i>v</i>, <i>received</i> = (0, <b>None</b>), <b>None</b>, {}
    <b>while</b> <b>True</b>:
        <b>atomically</b> <b>when</b> <b>exists</b> <i>m</i> <b>in</b> { <i>k</i> <b>for</b> <i>k</i> <b>in</b> <b>keys</b> <i>network</i> - <i>received</i>
                            <b>where</b> <i>k.type</i> <b>in</b> {"read", "write"} }:
            <i>received</i> |= { <i>m</i> }
            <b>if</b> (<i>m.type</i> == "write") <b>and</b> (<i>m.value</i>[0] &gt; <i>t</i>):
                <i>t</i>, <i>v</i> = <i>m.value</i>
            <var>send</var>({ .<i>type</i>: .<i>response</i>, .<i>dst</i>: <i>m.src</i>, .<i>value</i>: (<i>t</i>, <i>v</i>) })

<b>def</b> <var>init</var>():
    <b>for</b> <i>i</i> <b>in</b> { 1 .. <var>N</var> }: <b>spawn</b> <b>eternal</b> <var>server</var>()

<b>def</b> <var>receive</var>(<i>uid</i>, <i>phase</i>) <b>returns</b> <i>quorums</i>:
    <b>let</b> <i>msgs</i> = { <i>m</i>:<i>c</i> <b>for</b> <i>m</i>:<i>c</i> <b>in</b> <i>network</i>
                <b>where</b> (<i>m.type</i> == .<i>response</i>) <b>and</b> (<i>m.dst</i> == (<i>uid</i>, <i>phase</i>)) }:
        <i>quorums</i> = <var>bag.combinations</var>(<i>msgs</i>, <var>N</var> - <var>F</var>)

<b>def</b> <var>read</var>(<i>uid</i>) <b>returns</b> <i>contents</i>:
    <var>send</var>({ .<i>type</i>: "read", .<i>src</i>: (<i>uid</i>, 1) })
    <b>atomically</b> <b>when</b> <b>exists</b> <i>msgs</i> <b>in</b> <var>receive</var>(<i>uid</i>, 1):
        <b>let</b> (<i>t</i>, <i>v</i>) = <b>max</b>(<i>m.value</i> <b>for</b> <i>m</i> <b>in</b> <b>keys</b> <i>msgs</i>):
            <var>send</var>({ .<i>type</i>: "write", .<i>src</i>: (<i>uid</i>, 2), .<i>value</i>: (<i>t</i>, <i>v</i>) })
            <i>contents</i> = <i>v</i>
    <b>atomically</b> <b>when</b> <b>exists</b> <i>msgs</i> <b>in</b> <var>receive</var>(<i>uid</i>, 2):
        <b>pass</b>

<b>def</b> <var>write</var>(<i>uid</i>, <i>v</i>):
    <var>send</var>({ .<i>type</i>: "read", .<i>src</i>: (<i>uid</i>, 1) })
    <b>atomically</b> <b>when</b> <b>exists</b> <i>msgs</i> <b>in</b> <var>receive</var>(<i>uid</i>, 1):
        <b>let</b> (<i>t</i>, <var>_</var>) = <b>max</b>(<i>m.value</i> <b>for</b> <i>m</i> <b>in</b> <b>keys</b> <i>msgs</i>)
        <b>let</b> <i>nt</i> = (<i>t</i>[0] + 1, <i>uid</i>):
            <var>send</var>({ .<i>type</i>: "write", .<i>src</i>: (<i>uid</i>, 2), .<i>value</i>: (<i>nt</i>, <i>v</i>) })
    <b>atomically</b> <b>when</b> <b>exists</b> <i>msgs</i> <b>in</b> <var>receive</var>(<i>uid</i>, 2):
        <b>pass</b>
</code></pre>

</center>
<h4>Figure 30.3. [<a href='https://harmony.cs.cornell.edu/code/abd.hny'>code/abd.hny</a>] An implementation of a replicated atomic read/write register</h4>


</div>

A <i>register</i> is an object that you can read or write.
In a distributed system, examples include a shared file system
(each file is a register) or a key/value store (each key corresponds
to a register).
A simple shared register implementation
would have its value maintained by a server, and clients can read or write the
shared register by exchanging messages with the server.
We call two operations such that one does not finish before the other starts
<i>concurrent</i>.
Since messages are delivered one at a time to the server,
concurrent operations on the shared register appear atomic.
In particular, we have the following three desirable properties:
<ol><li> All write operations are ordered;
<li> A read operation returns either the last value written or the value of
a concurrent write operation.
<li> If read operation  <span 
class="cmmi-10">r</span><sub><span 
class="cmr-7">1</span></sub>  finishes before read operation  <span 
class="cmmi-10">r</span><sub><span 
class="cmr-7">2</span></sub>
 starts,
then  <span 
class="cmmi-10">r</span><sub><span 
class="cmr-7">2</span></sub>  cannot return a value that is older than the value returned
by  <span 
class="cmmi-10">r</span><sub><span 
class="cmr-7">1</span></sub> .
</ol>

It is instructive to look at the test program and its output in
<a href='#sec-217'>Figure 30.2</a>.  This is for the case when there is only
a single reader thread (identified as &quot;1&quot;) and a single writer
thread (identified as &quot; <span 
class="cmsy-10">-</span>1
&quot;), but already
there are many cases to consider.  Each thread prints information
just before and just after doing their single operation.  The output
shows all possible interleavings in the form of a DFA.  Note
that if the read operation starts after the write operation
has completed, then the read operaion must return the new value.
However, if the two operations interleave in some way, then the
read operation can return either the old or the new value.<p><a id="index:single-point-of-failure:1"></a>
Unfortunately, a server is a <i>single point of failure</i>:
if it fails, all its clients suffer.
We would therefore like to find a solution that can survive the crash
of a server.
While we could use Chain Replication to replicate the register, in
this chapter we will use a solution that does not assume that
crashes can be accurately detected.<p>We will again replicate the register object: maintain multiple copies,
but we will not use the replicated state machine approach.
One could, for example, imagine that clients write to all copies and read
from any single one.
While this solves the single-point-of-failure problem, we lose all the
nice properties above.  For one, it is not guaranteed that all servers
receive and process all write operations in the same order.<p><a id="index:logical-timestamp:1"></a>
We present a protocol preserving these properties that is based on the
work by Hagit Attiya, Amotz Bar-Noy, and Danny Dolev [<a href="#cite-ABD95">2</a>].
In order to tolerate <var>F</var> failures,
it uses <var>N</var> = 2<var>F</var> + 1 servers.
In other words, the register survives as long as a strict majority of
its copies survive.
All write operation will be ordered by a unique <i>logical timestamp</i>
(see also <a href='#sec-95'>Chapter 13</a>).
Each server maintains not only the value of the object, but also the
timestamp of its corresponding write operation.<p>Each read and write operation consists of two <i>phases</i>.  In a phase,
a client broadcasts a request to all servers and waits for responses
from a majority (<var>N</var> - <var>F</var> or equivalently
<var>F</var> + 1 servers).  Note that because we are assuming that no
more than <var>F</var> servers can fail, doing so is safe, in that a client
cannot indefinitely block as long as that assumption holds.<p>In the first phase, a client asks each server for its current
timestamp and value.  After receiving <var>N</var> - <var>F</var> responses,
the client determines the response with the highest timestamp.
In case of a write operation, the client then computes a new unique
timestamp that is strictly higher than the highest it has seen.
To make this work, timestamps are actually lexicographically ordered
tuples consisting of an integer and the unique identifier of the
client that writes the value.  So, if  (<span 
class="cmmi-10">t,c</span>)  is the highest timestamp
observed by client  <span 
class="cmmi-10">c</span><span 
class="cmsy-10">&#x2032; </span>, and  <span 
class="cmmi-10">c</span><span 
class="cmsy-10">&#x2032;</span>
  needs to create a new timestamp,
it can select  (<span 
class="cmmi-10">t </span>+ 1<span 
class="cmmi-10">,c</span><span 
class="cmsy-10">&#x2032;</span>) .
After all  (<span 
class="cmmi-10">t </span>+ 1<span 
class="cmmi-10">,c</span><span 
class="cmsy-10">&#x2032;</span>) <span 
class="cmmi-10">&#x003E; </span>(<span 
class="cmmi-10">t,u</span>)
 and no other client
will create the same timestamp.<p>Suppose client  <span 
class="cmmi-10">c</span><span 
class="cmsy-10">&#x2032; </span> is trying to write a value <i>v</i>.
In phase 2, client  <span 
class="cmmi-10">c</span><span 
class="cmsy-10">&#x2032; </span> broadcasts a request containing timestamp 
(<span 
class="cmmi-10">t </span>+ 1<span 
class="cmmi-10">,c</span><span 
class="cmsy-10">&#x2032;</span>) 
and <i>v</i>.  Each server that receives the request compares  (<span 
class="cmmi-10">t </span>+ 1<span 
class="cmmi-10">,c</span><span 
class="cmsy-10">&#x2032;</span>)  against
its current timestamp.  If  (<span 
class="cmmi-10">t </span>+ 1<span 
class="cmmi-10">,c</span><span 
class="cmsy-10">&#x2032;</span>)
 is larger than its current timestamp,
it adopts the new timestamp and its corresponding value <i>v</i>.  In either case,
the server responds to the client.
Upon  <span 
class="cmmi-10">c</span><span 
class="cmsy-10">&#x2032; </span> receiving a response from <var>N</var> - <var>F</var> servers,
the write operation completes.
In case of a read operation, client  <span 
class="cmmi-10">c</span><span 
class="cmsy-10">&#x2032; </span> simply <i>writes back</i> the
highest timestamp it saw in the first phase along with its corresponding value.<p><a href='#sec-218'>Figure 30.3</a> contains the code for a server, as well as the code
for read and write operations.
For efficiency of model checking, the servers are anonymous---otherwise
we would have to consider every permutation of states of those servers.
Because the servers are anonymous, they may end up sending the same
exact message, but clients are waiting for a particular number of
messages.
Because of this, we will model the network as a bag of messages.<p>A server initializes its timestamp <i>t</i> to

(0<span 
class="cmmi-10">,</span><span 
class="cmtt-10">None</span>)  and its value to <b>None</b>.
Each server also keeps track of all the requests its already received
so it doesn't handle the same request twice.
The rest of the code is fairly straightforward.<p>Read and write operations are both invoked with a unique identifier
<i>uid</i>.  Both start by broadcasting a .<i>read</i>
request to all servers and then waiting for a response from
<var>N</var> - <var>F</var> servers.
The <var>receive</var>() function uses the <var>bag.combinations</var> method
to find all combinations of subsets of responses of size <var>N</var> - <var>F</var>.
The second phase of each operation is similar.<p><a href='#sec-217'>Figure 30.2</a> can be used to test this protocol, although
you will notice that the model checker cannot deal with cases involving
more than three client threads.
Three is just enough to check the third property listed above
(using one writer and two readers).
Doing so illustrates the importance of the second phase of the <code>read</code>
operation.  You can comment out Lines 34, 36, and 37 in <a href='#sec-218'>Figure 30.3</a>
and to elide the second phase and see what goes wrong.<p>One may wonder how failures can occur in this model.  They are not
explicitly modeled, but Harmony tries every possible execution.
This includes executions in which the clients terminate before
<var>F</var> of the servers start executing.  To the clients, this
is indistinguishable from executions in which those
servers have failed.
</div>

<div id='sec-219'>
<h1>Chapter 31. Distributed Consensus</h1>

<p>



<p><div id='sec-220'>
<center><img src="figures/consensus.png" width="90%"></img>
</center>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>const</b> <var>N</var> = 4

<i>proposals</i> = [ <b>choose</b>({0, 1}) <b>for</b> <i>i</i> <b>in</b> {0..N-1} ]
<i>decision</i> = <b>choose</b> { <i>x</i> <b>for</b> <i>x</i> <b>in</b> <i>proposals</i> }

<b>def</b> <var>processor</var>(<i>proposal</i>):
    <b>if</b> <b>choose</b> { <b>False</b>, <b>True</b> }:
        <b>print</b> <i>decision</i>

<b>print</b> <i>proposals</i>
<b>for</b> <i>i</i> <b>in</b> {0..N-1}:
    <b>spawn</b> <var>processor</var>(<i>proposals</i>[<i>i</i>])
</code></pre>

</center>
<h4>Figure 31.1. [<a href='https://harmony.cs.cornell.edu/code/consensus.hny'>code/consensus.hny</a>] Distributed consensus code and behavior DFA</h4>


</div>

Distributed consensus is the problem of having a collection of processors agree
on a single value over a network.
For example, in state machine replication, the state machines have to agree
on which operation to apply next.
Without failures, this can be solved using leader election: first elect a leader, then have that leader decide a value.
But consensus often has to be done in adverse circumstances,
for example in the face of processor failures.<p>Each processor <i>proposes</i> a value, which we assume here to be from the
set { 0, 1 }.
By the usual definition of consensus, we want the following three properties:
<ol><li> <i>Validity</i>: a processor can only decide a value that has been proposed;
<li> <i>Agreement</i>: if two processors decide, then they decide the same value.
<li> <i>Termination</i>: each processor eventually decides.
</ol>
The consensus problem is impossible to solve in the face of processor
failures and without making assumptions about how long it takes to send
and receive a message [<a href="#cite-FLP85">20</a>].
Here we will not worry about <i>Termination</i>.<p><a href='#sec-220'>Figure 31.1</a> presents a specification for binary
consensus---the proposals are from the set {0, 2}
In this case there are four processors.  The proposal of processor <i>i</i>
is in <i>proposals</i>[<i>i</i>].
The <i>decision</i> is chosen from the set of proposals.
Each processor may or may not print the decision---capturing the
absence of the <i>Termination</i> property.
It may be that no decisions are made, but that does not
violate either Validity or Agreement.
Thus the behavior of the program is to first print the array of
proposals, followed by some subset of processors printing their decision.
Notice the following properties:
<ul><li> there are  16 = 2<sup><span 
class="cmr-7">4</span></sup>  possible proposal configurations;
<li> all processors that decide decide the same value;
<li> if all processors propose 0, then all processors that decide decide 0;
<li> if all processors propose 1, then all processors that decide decide 1.
</ul>

This is just the specification---in practice we do not have a shared
variable in which we can store the decision a priori.
We will present a simple consensus algorithm that can tolerate
fewer than  1<span 
class="cmmi-10">&#x2215;</span>3<sup><span 
class="cmmi-7">rd</span></sup>  of processors failing by crashing.
More precisely,
constant <var>F</var> contains the maximum number of failures, and
we will assume there are <var>N</var> = 3<var>F</var> + 1 processors.<p><div id='sec-221'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>bag</var>

<b>const</b> <var>F</var> = 1
<b>const</b> <var>N</var> = (3 * <var>F</var>) + 1
<b>const</b> <var>NROUNDS</var> = 3

<i>proposals</i> = [ <b>choose</b>({0, 1}) <b>for</b> <i>i</i> <b>in</b> {0..N-1} ]
<i>network</i> = <var>bag.empty</var>()

<b>def</b> <var>broadcast</var>(<i>msg</i>):
    <b>atomically</b> <i>network</i> = <var>bag.add</var>(<i>network</i>, <i>msg</i>)

<b>def</b> <var>receive</var>(<i>round</i>, <i>k</i>) <b>returns</b> <i>quorum</i>:
    <b>let</b> <i>msgs</i> = { <i>e</i>:<i>c</i> <b>for</b> (<i>r</i>,<i>e</i>):<i>c</i> <b>in</b> <i>network</i> <b>where</b> <i>r</i> == <i>round</i> }:
        <i>quorum</i> = <var>bag.combinations</var>(<i>msgs</i>, <i>k</i>)

<b>def</b> <var>processor</var>(<i>proposal</i>):
    <b>var</b> <i>estimate</i>, <i>decided</i> = <i>proposal</i>, <b>False</b>
    <var>broadcast</var>(0, <i>estimate</i>)
    <b>for</b> <i>round</i> <b>in</b> {0..NROUNDS-1}:
        <b>atomically</b> <b>when</b> <b>exists</b> <i>quorum</i> <b>in</b> <var>receive</var>(<i>round</i>, <var>N</var> - <var>F</var>):
            <b>let</b> <i>count</i> = [ <var>bag.multiplicity</var>(<i>quorum</i>, <i>i</i>) <b>for</b> <i>i</i> <b>in</b> { 0..1 } ]:
                <b>assert</b> <i>count</i>[0] != <i>count</i>[1]
                <i>estimate</i> = 0 <b>if</b> <i>count</i>[0] &gt; <i>count</i>[1] <b>else</b> 1
                <b>if</b> <i>count</i>[<i>estimate</i>] == (<var>N</var> - <var>F</var>):
                    <b>if</b> <b>not</b> <i>decided</i>:
                        <b>print</b> <i>estimate</i>
                        <i>decided</i> = <b>True</b>
                    <b>assert</b> <i>estimate</i> <b>in</b> <i>proposals</i>   <i># check validity</i>
                <var>broadcast</var>(<i>round</i> + 1, <i>estimate</i>)

<b>print</b> <i>proposals</i>
<b>for</b> <i>i</i> <b>in</b> {0..N-1}:
    <b>spawn</b> <var>processor</var>(<i>proposals</i>[<i>i</i>])
</code></pre>

</center>
<h4>Figure 31.2. [<a href='https://harmony.cs.cornell.edu/code/bosco.hny'>code/bosco.hny</a>] A crash-tolerant consensus protocol</h4>


</div>

<div id='sec-222'>
<center><img src="figures/bosco.png" width="95%"></img>
</center>
<h4>Figure 31.3. The behavior DFA for <a href='#sec-221'>Figure 31.2</a></h4>


</div>

<a href='#sec-221'>Figure 31.2</a> presents our algorithm.  Besides the <i>network</i>
variable,
it uses a shared list of proposals and a shared set of decisions.
In this particular algorithm, all messages are broadcast to all processors, so they do
not require a destination address.
The <var>N</var> processors go through a sequence of <i>rounds</i> in which they wait for
<var>N</var> - <var>F</var> messages, update their state based on the messages, and
broadcast messages containing their new state.
The reason that a processor waits for <var>N</var> - <var>F</var> rather than <var>N</var>
messages is because of failures: up to <var>F</var> processors may never send a message
and so it would be unwise to wait for all <var>N</var>.  You might be tempted to use
a timer and time out on waiting for a particular processor.  But how would you initialize
that timer?  While we will assume that the network is reliable, there is no guarantee
that messages arrive within a particular time.
We call a set of <var>N</var> - <var>F</var> processors a <i>quorum</i>.
A quorum must suffice for the algorithm to make progress.<p>The state of a processor consists of its current round number (initially 0)
and an estimate (initially the proposal).  Therefore, messages contain
a round number and an estimate. To start things, each processor first
broadcasts its initial round number and initial estimate.
The number of rounds that are necessary to achieve consensus is not bounded.  But
Harmony can only check finite models, so there is a constant <code>NROUNDS</code> that
limits the number of rounds.<p>In Line 21, a processor waits for <var>N</var> - <var>F</var> messages using
the Harmony <b>atomically</b> <b>when</b> <b>exists</b> statement.
Since Harmony has to check all possible executions of the protocol, the
<var>receive</var>(<i>round</i>, <i>k</i>) method returns all <i>subbags</i> of messages
for the given round that have size <i>k</i> = <var>N</var> - <var>F</var>.  The method uses a
dictionary comprehension to filter out all messages for the given <i>round</i>
and then uses the <var>bag.combinations</var> method to find all combinations of size <i>k</i>.
The <b>atomically</b> <b>when</b> <b>exists</b> statement waits until there is at least one such combination and
then chooses an element, which is bound to the <i>quorum</i> variable.
The body of the statement is then executed atomically.
This is usually how distributed algorithms are modeled, because they can only interact
through the network.  There is no need to interleave the different processes other
than when messages are delivered.  By executing the body atomically, a lot of
unnecessary interleavings are avoided and this reduces the state space that must
be explored by the model checker significantly.<p>The body of the <b>atomically</b> <b>when</b> <b>exists</b> statement contains the core of the algorithm.
Note that <var>N</var> - <var>F</var> = 2<var>F</var> + 1, so that the number of
messages is guaranteed to be odd.  Also, because there are only 0 and 1 values, there
must exist a majority of zeroes or ones.  Variable <i>count</i>[0] stores the number
of zeroes and <i>count</i>[1] stores the number of ones received in the round.
The rules of the algorithm are simple:
<ul><li> update <i>estimate</i> to be the majority value;
<li> if the quorum is unanimous, decide the value.
</ul>
After that, proceed with the next round.<p>To check for correct behavior, run the following two commands:<p><center><pre><code class="language-none">$ harmony -o consensus.hfa code/consensus.hny
$ harmony -B consensus.hfa code/bosco.hny
</code></pre>
</center>

Note that the second command prints a warning:
&quot;<code>behavior warning: strict subset of specified behavior</code>.&quot;
Thus, the set of behaviors that our algorithm generates is a subset
of the behavior that the specification allows.
<a href='#sec-222'>Figure 31.3</a> shows the behavior, and indeed it is not the
same as the behavior of <a href='#sec-220'>Figure 31.1</a>.
This is because in our algorithm the outcome is decided a priori if more than
twothirds of the processors have the same proposal, whereas in the
consensus specification the outcome is only decided a priori if the
processors are initially unanimous.  Another difference is that if the
outcome is decided a priori, all processors are guaranteed to decide.<p><div id='sec-223'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>bag</var>

<b>const</b> <var>F</var> = 1
<b>const</b> <var>N</var> = (3 * <var>F</var>) + 1
<b>const</b> <var>NROUNDS</var> = 3

<b>let</b> <i>n_zeroes</i> = <b>choose</b> { 0 .. <var>N</var> / 2 }:
    <i>proposals</i> = ([0,] * <i>n_zeroes</i>) + ([1,] * (<var>N</var> - <i>n_zeroes</i>))
<i>network</i> = <var>bag.empty</var>()

<b>def</b> <var>broadcast</var>(<i>msg</i>):
    <b>atomically</b> <i>network</i> = <var>bag.add</var>(<i>network</i>, <i>msg</i>)

<b>def</b> <var>receive</var>(<i>round</i>) <b>returns</b> <i>quorum</i>:
    <b>let</b> <i>msgs</i> = { <i>e</i>:<i>c</i> <b>for</b> (<i>r</i>,<i>e</i>):<i>c</i> <b>in</b> <i>network</i> <b>where</b> <i>r</i> == <i>round</i> }:
        <i>quorum</i> = {} <b>if</b> <var>bag.size</var>(<i>msgs</i>) &lt; <var>N</var> <b>else</b> { <i>msgs</i> }

<b>def</b> <var>processor</var>(<i>proposal</i>):
    <b>var</b> <i>estimate</i>, <i>decided</i> = <i>proposal</i>, <b>False</b>
    <var>broadcast</var>(0, <i>estimate</i>)
    <b>for</b> <i>round</i> <b>in</b> {0..NROUNDS-1}:
        <b>atomically</b> <b>when</b> <b>exists</b> <i>msgs</i> <b>in</b> <var>receive</var>(<i>round</i>):
            <b>let</b> <i>choices</i> = <var>bag.combinations</var>(<i>msgs</i>, <var>N</var> - <var>F</var>)
            <b>let</b> <i>quorum</i> = <b>choose</b>(<i>choices</i>)
            <b>let</b> <i>count</i> = [ <var>bag.multiplicity</var>(<i>quorum</i>, <i>i</i>) <b>for</b> <i>i</i> <b>in</b> { 0..1 } ]:
                <b>assert</b> <i>count</i>[0] != <i>count</i>[1]
                <i>estimate</i> = 0 <b>if</b> <i>count</i>[0] &gt; <i>count</i>[1] <b>else</b> 1
                <b>if</b> <i>count</i>[<i>estimate</i>] == (<var>N</var> - <var>F</var>):
                    <b>if</b> <b>not</b> <i>decided</i>:
                        <b>print</b> <i>estimate</i>
                        <i>decided</i> = <b>True</b>
                    <b>assert</b> <i>estimate</i> <b>in</b> <i>proposals</i>           <i># validity</i>
                <var>broadcast</var>(<i>round</i> + 1, <i>estimate</i>)

<b>print</b> <i>proposals</i>
<b>for</b> <i>i</i> <b>in</b> {0..N-1}:
    <b>spawn</b> <var>processor</var>(<i>proposals</i>[<i>i</i>])
</code></pre>

</center>
<h4>Figure 31.4. [<a href='https://harmony.cs.cornell.edu/code/bosco2.hny'>code/bosco2.hny</a>] Reducing the state space</h4>


</div>

While one can run this code within little time for <var>F</var> = 1, for
<var>F</var> = 2 the state space to explore is already quite large.
One way to reduce the state space to explore is the following realization:
each processor only considers messages for the round that it is in.
If a message is for an old round, the processor will ignore it;
if a message is for a future round, the processor will buffer it.
So, one can simplify the model and have each processor wait
for <i>all</i> <var>N</var> messages in a round
instead of <var>N</var> - <var>F</var>.
It would still have to choose to consider just <var>N</var> - <var>F</var>
out of those <var>N</var> messages, but executions in which some processors
are left behind in all rounds are no longer considered.
It still includes executions where some subset of <var>N</var> - <var>F</var>
processors only choose each other messages and essentially ignore the
messages of the remaining <var>F</var> processors, so the resulting model
is just as good.<p>Another way to reduce the state space to explore is to leverage
symmetry.  First of all, it does not matter who proposes a particular
value.  Also, the values 0 and 1 are not important to how the
protocol operates.  So, with 5 processors (<var>F</var> = 2), say, we only
need to explore the cases where no processors propose 1, where
exactly one processors proposes 1, and where 2 processors proposes 1.<p><a href='#sec-223'>Figure 31.4</a> shows the code for this optimized model.
Running this with <var>F</var> = 2 does not take very long and this approach
is a good blueprint for testing other round-based protocols (of
which there are many).<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-224"><b>[Ex. 31.1]</b>:  The algorithm as given works in the face of crash failures.
A more challenging class to tolerate are <i>arbitrary failures</i> in
which up to <var>F</var> processors may send arbitrary messages, including
conflicting messages to different peers (equivocation).
The algorithm can tolerate those failures if you use <var>N</var> = 5F - 1 processors instead of <var>N</var> = 3F - 1.  Check that.
<li id="sec-225"><b>[Ex. 31.2]</b>:  In 1983, Michael Ben-Or presented a randomized algorithm that can
tolerate crash failures with
just <var>N</var> = 2F - 1 processors [<a href="#cite-BenOr83">4</a>].
Implement this algorithm.
</ul>
</div>

<div id='sec-226'>
<h1>Chapter 32. Paxos</h1>

<p>
<p>
<div id='sec-227'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>bag</var>

<b>const</b> <var>F</var> = 1
<b>const</b> <var>NACCEPTORS</var> = (2 * <var>F</var>) + 1
<b>const</b> <var>NLEADERS</var> = <var>F</var> + 1
<b>const</b> <var>NBALLOTS</var> = 2

<i>network</i> = <var>bag.empty</var>()

<i>proposals</i> = [ <b>choose</b>({0, 1}) <b>for</b> <i>i</i> <b>in</b> {0..NLEADERS-1} ]

<b>def</b> <var>send</var>(<i>msg</i>):
    <b>atomically</b> <i>network</i> = <var>bag.add</var>(<i>network</i>, <i>msg</i>)

<b>def</b> <var>receive</var>(<i>ballot</i>, <i>phase</i>) <b>returns</b> <i>quorum</i>:
    <b>let</b> <i>msgs</i> = { <i>e</i>:<i>c</i> <b>for</b> (<i>b</i>,<i>p</i>,<i>t</i>,<i>e</i>):<i>c</i> <b>in</b> <i>network</i>
                        <b>where</b> (<i>b</i>,<i>p</i>,<i>t</i>) == (<i>ballot</i>, <i>phase</i>, "B") }:
        <i>quorum</i> = <var>bag.combinations</var>(<i>msgs</i>, <var>NACCEPTORS</var> - <var>F</var>)

<b>print</b> <i>proposals</i>
<b>for</b> <i>i</i> <b>in</b> {0..NLEADERS - 1}:
    <b>spawn</b> <var>leader</var>(<i>i</i> + 1, <i>proposals</i>[<i>i</i>])
<b>for</b> <i>i</i> <b>in</b> {1..NACCEPTORS}:
    <b>spawn</b> <b>eternal</b> <var>acceptor</var>()

<b>def</b> <var>leader</var>(<i>self</i>, <i>proposal</i>):
    <b>var</b> <i>ballot</i>, <i>estimate</i>, <i>decided</i> = <i>self</i>, <i>proposal</i>, <b>False</b>
    <var>send</var>(<i>ballot</i>, 1, "A", <b>None</b>)
    <b>while</b> <i>ballot</i> &lt;= <var>NBALLOTS</var>:
        <b>atomically</b> <b>when</b> <b>exists</b> <i>quorum</i> <b>in</b> <var>receive</var>(<i>ballot</i>, 1):
            <b>let</b> <i>accepted</i> = { <i>e</i> <b>for</b> <i>e</i>:<var>_</var> <b>in</b> <i>quorum</i> <b>where</b> <i>e</i> != <b>None</b> }:
                <b>if</b> <i>accepted</i> != {}:
                    <var>_</var>, <i>estimate</i> = <b>max</b>(<i>accepted</i>)
            <var>send</var>(<i>ballot</i>, 2, "A", <i>estimate</i>)
        <b>atomically</b> <b>when</b> <b>exists</b> <i>quorum</i> <b>in</b> <var>receive</var>(<i>ballot</i>, 2):
            <b>if</b> <var>bag.multiplicity</var>(<i>quorum</i>, (<i>ballot</i>, <i>estimate</i>)) == (<var>NACCEPTORS</var> - <var>F</var>):
                <b>assert</b> <i>estimate</i> <b>in</b> <i>proposals</i>    <i># validity</i>
                <b>if</b> <b>not</b> <i>decided</i>:
                    <b>print</b> <i>estimate</i>
                    <i>decided</i> = <b>True</b>
            <i>ballot</i> += <var>NLEADERS</var>
            <b>if</b> <i>ballot</i> &lt;= <var>NBALLOTS</var>:
                <var>send</var>(<i>ballot</i>, 1, "A", <b>None</b>)

<b>def</b> <var>acceptor</var>():
    <b>var</b> <i>ballot</i>, <i>last_accepted</i>, <i>received</i> = 0, <b>None</b>, {}
    <b>while</b> <b>True</b>:
        <b>atomically</b> <b>when</b> <b>exists</b> <i>b</i>,<i>p</i>,<i>e</i> <b>in</b> { (<i>bb</i>,<i>pp</i>,<i>ee</i>) <b>for</b> <i>bb</i>,<i>pp</i>,<i>tt</i>,<i>ee</i>:<var>_</var> <b>in</b> <i>network</i>
                    <b>where</b> ((<i>bb</i>,<i>pp</i>) <b>not</b> <b>in</b> <i>received</i>) <b>and</b> (<i>tt</i> == "A") }:
            <i>received</i> |= { (<i>b</i>, <i>p</i>) }
            <b>if</b> <i>b</i> &gt;= <i>ballot</i>:
                <i>ballot</i> = <i>b</i>
                <b>if</b> <i>p</i> == 2:
                    <i>last_accepted</i> = (<i>ballot</i>, <i>e</i>)
            <var>send</var>(<i>b</i>, <i>p</i>, "B", <i>last_accepted</i>)
</code></pre>

</center>
<h4>Figure 32.1. [<a href='https://harmony.cs.cornell.edu/code/paxos.hny'>code/paxos.hny</a>] A version of the Paxos protocol</h4>


</div>

Paxos [<a href="#cite-Paxos">29</a>] is the most well-known family of consensus protocols for
environments in which few or no assumptions are made about timing.
In this chapter, we present a basic version of a Paxos protocol, one that is
<i>single-decree</i> (only tries to make a single decision).
It uses two kinds of processors: <i>leaders</i> and <i>acceptors</i>.
In order to tolerate <var>F</var> crash failures, you need at least <var>F</var> + 1 leaders
and 2F + 1 acceptors, but leaders and acceptors can be colocated, so
in total only 2F + 1 independently failing processors are needed.
Here we provide only a rudimentary introduction to Paxos; for more detailed
information refer to [<a href="#cite-Paxos">29</a>].<p>As in the consensus protocol of <a href='#sec-219'>Chapter 31</a>, Paxos uses rounds of messaging.
The communication pattern, however, is different.
Similar to the atomic read/write register protocol in <a href='#sec-215'>Chapter 30</a>,
Paxos uses two kinds of rounds: &quot;Phase 1&quot; and &quot;Phase 2&quot; rounds.
Rounds are identified by a so-called
<i>ballot number</i> combined with the phase number.
Different leaders are in charge of different ballot numbers.
Leaders broadcast &quot;Type A&quot;
messages to the acceptors, which respond point-to-point with &quot;Type B&quot;
messages.<p><a href='#sec-227'>Figure 32.1</a> contains
the code for
this Paxos protocol.  Paxos is perhaps best understood starting
with the second phase.  At the end of the first phase, the leader
broadcasts a <code>2.A</code> message (Phase 2, Type A) to the acceptors
containing the ballot number and a proposal and then waits for
<var>N</var> - <var>F</var> matching <code>2.B</code> responses from the
acceptors.  If each response contains the ballot number and the
proposal, then the proposal is deemed decided.  But one or more of
the responses can contain a higher ballot number, in which case the
leader has to try again with an even higher ballot number.  This is
where the first phase comes in.<p>It is not possible that an acceptor responds with a smaller ballot
number.  This is because acceptors maintain two state variables.
One is <i>ballot</i>, the highest ballot number they have seen.
Second is a variable called <i>last_accepted</i> that, if not
<b>None</b>, contains the last proposal the acceptor has
<i>accepted</i> and the corresponding ballot number.  The acceptor
also contains a set <i>received</i> that contains (ballot, phase)
tuples identifiying all rounds that the ballot has already participated
in.  An acceptor waits for a message for a round that is not in
<i>received</i>.  If its ballot number is higher than what it has
seen before, the acceptor moves into that ballot.  If the phase is 2,
then the acceptor accepts the proposal and remembers when it did
so by saving the (ballot, proposal) tuple in <i>last_accepted</i>.
In all cases, the acceptor responds with the current values of
<i>ballot</i> and <i>last_accepted</i>.<p>In its first phase, a leader of a ballot must come up with a proposal that
cannot conflict with a proposal of an earlier ballot that may already
have been decided.  To this end, the leader broadcasts a <code>2.A</code>
message to the acceptors and awaits <var>N</var> - <var>F</var> of their <i>last_accepted</i>
values.  If all those acceptors responded with <b>None</b>, then the leader
is free to choose its own proposal.  Otherwise the leader updates
its proposal with the one corresponding to the highest ballot number.
The leader then moves on to the second round.<p>To run and check the Paxos code, do the following (leveraging the
consensus specification of <a href='#sec-220'>Figure 31.1</a>):<p><center><pre><code class="language-none">$ harmony -o consensus.hfa -cN=2 code/consensus.hny
$ harmony -B consensus.hfa code/paxos.hny
</code></pre>
</center>

You should get a warning that our implementation of Paxos does not
generate all possible behaviors.
This is because we only run the protocol for a finite number of ballots,
and therefore at least one of the ballots will be successful.
With an unlimited number of ballots, Paxos may never decide unless you
make some liveness assumptions.<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-228"><b>[Ex. 32.1]</b>:  Perhaps the trickiest detail of the algorithm is that, in
Line 33 of <a href='#sec-227'>Figure 32.1</a>,
the leader selects the proposal with the highest
ballot number it receives.  Replace the <code>max</code> operator in that statement
with <b>choose</b> and see if it finds a problem.  First try with
<var>NBALLOTS</var> = 2 and then with <var>NBALLOTS</var> = 3.
(Warning, the latter may take a long time.)  If it finds a problem,
analyze the output and see what went wrong.
<li id="sec-229"><b>[Ex. 32.2]</b>:  [<a href="#cite-MWA19">36</a>] discusses a buggy version of Paxos.  In this version,
the responses to the second phase are matched not by ballot number but
by the value of the proposal.  Implement this version and, using Harmony,
find the problem this causes.
</ul>
</div>

<div id='sec-230'>
<h1>Chapter 33. Needham-Schroeder Authentication Protocol</h1>

<p>

<p><div id='sec-231'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>network</i> = {}

<i>dest</i> = <b>choose</b>({ <b>None</b>, "Bob", "Corey" })

<b>def</b> <var>send</var>(<i>msg</i>):
    <b>atomically</b> <i>network</i> |= { <i>msg</i> }

<b>def</b> <var>alice</var>():
    <b>if</b> <i>dest</i> != <b>None</b>:
        <var>send</var>({ .<i>dst</i>: <i>dest</i>,
            .<i>contents</i>: { .<i>type</i>: 1, .<i>nonce</i>: "nonceA", .<i>initiator</i>: "Alice" } })
        <b>atomically</b> <b>when</b> <b>exists</b> <i>m</i> <b>in</b> <i>network</i> <b>when</b> (<i>m.dst</i> == "Alice")
                    <b>and</b> (<i>m.contents.type</i> == 2) <b>and</b> (<i>m.contents.nonce</i> == "nonceA"):
            <var>send</var>({ .<i>dst</i>: <i>dest</i>, .<i>contents</i>: { .<i>type</i>: 3, .<i>nonce</i>: <i>m.contents.nonce2</i> } })

<b>def</b> <var>bob</var>():
    <b>atomically</b> <b>when</b> <b>exists</b> <i>m</i> <b>in</b> <i>network</i> <b>when</b> (<i>m.dst</i> == "Bob")
                    <b>and</b> (<i>m.contents.type</i> == 1) <b>and</b> (<i>m.contents.initiator</i> == "Alice"):
        <var>send</var>({ .<i>dst</i>: "Alice",
            .<i>contents</i>: { .<i>type</i>: 2, .<i>nonce</i>: <i>m.contents.nonce</i>, .<i>nonce2</i>: "nonceB" } })
    <b>atomically</b> <b>when</b> <b>exists</b> <i>m</i> <b>in</b> <i>network</i> <b>when</b> (<i>m.dst</i> == "Bob")
                    <b>and</b> (<i>m.contents.type</i> == 3) <b>and</b> (<i>m.contents.nonce</i> == "nonceB"):
        <b>assert</b> <i>dest</i> == "Bob"

<b>def</b> <var>corey</var>():
    <b>var</b> <i>received</i>, <i>nonces</i>, <i>msgs</i> = {}, { "nonceC" }, {}
    <b>while</b> <b>True</b>:
        <b>atomically</b> <b>when</b> <b>exists</b> <i>m</i> <b>in</b> <i>network</i> - <i>received</i> <b>when</b> <i>m.dst</i> == "Corey":
            <i>received</i> |= { <i>m</i> }
            <i>nonces</i> |= { <i>m.contents.nonce</i> }
            <b>if</b> <i>m.contents.type</i> == 2:
                <i>nonces</i> |= { <i>m.contents.nonce2</i> }
            <b>for</b> <i>dst</i> <b>in</b> { "Alice", "Bob" } <b>for</b> <i>n</i> <b>in</b> <i>nonces</i>:
                <i>msgs</i> |= {{ .<i>dst</i>: <i>dst</i>, .<i>contents</i>: { .<i>type</i>: 1, .<i>nonce</i>: <i>n</i>, .<i>initiator</i>: <i>ini</i> }}
                                    <b>for</b> <i>ini</i> <b>in</b> { "Alice", "Bob" }}
                <i>msgs</i> |= {{ .<i>dst</i>: <i>dst</i>, .<i>contents</i>: { .<i>type</i>: 2, .<i>nonce</i>: <i>n</i>, .<i>nonce2</i>: <i>n2</i> }}
                                    <b>for</b> <i>n2</i> <b>in</b> <i>nonces</i> }
                <i>msgs</i> |= {{ .<i>dst</i>: <i>dst</i>, .<i>contents</i>: { .<i>type</i>: 3, .<i>nonce</i>: <i>n</i> }}}
            <var>send</var>(<b>choose</b>(<i>msgs</i> - <i>network</i>))

<b>spawn</b> <var>alice</var>(); <b>spawn</b> <var>bob</var>()
<b>spawn</b> <b>eternal</b> <var>corey</var>()
</code></pre>

</center>
<h4>Figure 33.1. [<a href='https://harmony.cs.cornell.edu/code/needhamschroeder.hny'>code/needhamschroeder.hny</a>] Needham-Schroeder protocol and an attack</h4>


</div>

The Needham-Schroeder protocol [<a href="#cite-NS78">37</a>] is a security protocol in which two parties
authenticate one another by exchanging large and recently created random numbers
called <i>nonces</i> that nobody else should be able to read.
The nonces should only be used once for an instantiation of the protocol between
honest participants (i.e., participants that follow the protocol).
The version we describe here uses <i>public key cryptography</i> [<a href="#cite-DH76">12</a>]: with public key
cryptography it is possible to create a message for a particular destination that
only that destination can read.  We denote with  <span 
class="cmsy-10">&#x27E8;</span><span 
class="cmmi-10">m</span><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmmi-7">p</span></sub>  a message
<i>m</i> encrypted for <i>p</i> so that only <i>p</i> can decrypt the message and see that it contains <i>m</i>.<p>Suppose Alice wants to communicate with Bob.  The three critical steps in the
Needham-Schroeder protocol are as follows:<p><ol><li> Alice creates a new nonce  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">A</span></sub>  and sends  <span 
class="cmsy-10">&#x27E8;</span>1<span 
class="cmmi-10">,A,N</span><sub><span 
class="cmmi-7">A</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Bob</span></sub>

to Bob;
<li> Upon receipt, Bob creates a new nonce  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">B</span></sub>  and sends
 <span 
class="cmsy-10">&#x27E8;</span>2<span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">A</span></sub><span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">B</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Alice</span></sub>  to Alice;
<li> Alice sends  <span 
class="cmsy-10">&#x27E8;</span>3<span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">B</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Bob</span></sub>  to Bob.
</ol>

When Bob receives  <span 
class="cmsy-10">&#x27E8;</span>1<span 
class="cmmi-10">,A,N</span><sub><span 
class="cmmi-7">A</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Bob</span></sub> , Bob does not know for sure
that the message came from Alice, and even if it came from Alice, it does not know if
Alice sent the message recently or if it was replayed by some adversary.
When Alice receives  <span 
class="cmsy-10">&#x27E8;</span>2<span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">A</span></sub><span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">B</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Alice</span></sub> , Alice <i>does</i>
know that, if Bob is honest, (1) Bob and only Bob could have created this message, and
(2) Bob must have done so recently (since Alice created  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">A</span></sub> ).
When Bob receives 
<span 
class="cmsy-10">&#x27E8;</span>3<span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">B</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Bob</span></sub> , Bob decides that it is Alice
that is trying to communicate at this time.  Since Bob created  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">B</span></sub>  recently and sent it
encrypted to Alice, Bob does not have to worry that the type 3 message was an old message
that was replayed by some adversary.
Also, if Alice is honest, it seems only Alice can have seen the message containing  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">B</span></sub> .<p>Thus, the intended security properties of this protocol are symmetric.
Assuming Alice and Bob are both honest:
<ul><li> if Alice finishes the protocol with Bob and received  <span 
class="cmmi-10">B</span><sub><span 
class="cmmi-7">N</span></sub>  from Bob, then
nobody but Alice and Bob can learn  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">B</span></sub> .
<li> if Bob finishes the protocol with Alice and received  <span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">N</span></sub>  from Alice, then
nobody but Bob and Alice can learn  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">A</span></sub> .
</ul>

After the protocol, Alice can include  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">A</span></sub>  in messages to Bob and Bob can
include  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">B</span></sub>  in messages to Alice to authenticate the sources of those messages
to one another.<p><a href='#sec-231'>Figure 33.1</a> shows the protocol implemented in Harmony.
A message  <span 
class="cmsy-10">&#x27E8;</span><span 
class="cmmi-10">m</span><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmmi-7">p</span></sub>  is encoded in Harmony as a dictionary
 <span 
class="cmsy-10">{</span><span 
class="cmmi-10">.</span><span 
class="cmtt-10">dst</span> : <span 
class="cmmi-10">p,</span><span 
class="cmmi-10">.</span><span 
class="cmtt-10">contents</span> : <span 
class="cmmi-10">m</span><span 
class="cmsy-10">} </span>.  The code for Alice and Bob
simply follows the steps listed above.<p>Unfortunately, the protocol turns out to be incorrect, but it took 17 years before
somebody noticed [<a href="#cite-Lowe95">33</a>].  Model checking can be used to find the bug [<a href="#cite-Lowe96">34</a>].
To demonstate the bug, we need to model the environment.
In particular, we introduce a third party, which we will call Corey.
We want to make sure that Corey cannot impersonate Alice or Bob.
However, it is possible that Alice tries to set up an authenticated connection to Corey
using the Needham-Schroeder protocol.  That in itself should not be a problem if the
protocol were correct.<p>The code in <a href='#sec-231'>Figure 33.1</a> has Alice either not do anything, or has Alice try to set
up a connection to either Bob
or Corey.  Bob only accepts connections with Alice.  Corey, when receiving a message
that it can decrypt, will try to find an attack by sending every possible message to
every possible destination.  In particular, it keeps track of every nonce that it has
seen and will try to construct messages with them to send to Alice and Bob.
If Bob finishes the protocol, it checks to see if Alice actually tried to connect
to Bob.  If not, the assertion fails and an attack is found.<p>Running the code in <a href='#sec-231'>Figure 33.1</a> quickly finds a viable attack.  The attack goes
like this:<p><ol><li> Alice creates a new nonce  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">A</span></sub>  and sends  <span 
class="cmsy-10">&#x27E8;</span>1<span 
class="cmmi-10">,A,N</span><sub><span 
class="cmmi-7">A</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Corey</span></sub> 
to Corey;
<li> Upon receipt, Corey sends 
<span 
class="cmsy-10">&#x27E8;</span>1<span 
class="cmmi-10">,A,N</span><sub><span 
class="cmmi-7">A</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Bob</span></sub>  to Bob;
<li> Upon receipt, Bob, believing it is engaging in the protocol with Alice,
creates a new nonce  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">B</span></sub>  and sends
 <span 
class="cmsy-10">&#x27E8;</span>2<span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">A</span></sub><span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">B</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Alice</span></sub>
 to Alice;
<li> Alice thinks the message came from Corey (because it contains  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">A</span></sub> , which
Alice created for Corey and sent to Corey) and
sends  <span 
class="cmsy-10">&#x27E8;</span>3<span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">B</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Corey</span></sub>  to Corey.
<li> Corey learns  <span 
class="cmmi-10">N</span><sub><span 
class="cmmi-7">B</span></sub>  and sends  <span 
class="cmsy-10">&#x27E8;</span>3<span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">B</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Bob</span></sub>  to Bob.
<li> Bob receiving 
<span 
class="cmsy-10">&#x27E8;</span>3<span 
class="cmmi-10">,N</span><sub><span 
class="cmmi-7">B</span></sub><span 
class="cmsy-10">&#x27E9;</span><sub><span 
class="cmtt-8x-x-87">Bob</span></sub>  is identical to the
situation in which Alice tried to set up a connection to Bob,
so Bob now thinks it is talking to Alice, even though Alice never tried to
communicate with Bob.
</ol>
The security property is violated.  In particular, Bob, duped by Corey, finished
the protocol with Alice and received  <span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">N</span></sub> , and even though Bob and Alice
are both honest, Corey has a copy of  <span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">N</span></sub> .  So, Corey is now able to impersonate
Alice to Bob (but not vice versa because Alice did not try to authenticate Bob).<p><h2>Exercises</h2>
<ul style="list-style-type:none;"><li id="sec-232"><b>[Ex. 33.1]</b>:  Figure out how to fix the protocol.
<li id="sec-233"><b>[Ex. 33.2]</b>:  There were two versions of the Needham-Schroeder protocol: the
Symmetric Key protocol and the Public Key protocol.  In this chapter
we only discussed the latter, but the former also had a problem.  See
if you can find it using Harmony.
</ul>
</div>


<h1 id="sec-234">References</h1>
<ol>
<li id="cite-Agha86">Gul Agha, "Actors: A Model of Concurrent Computation in Distributed Systems (doctoral dissertation)", 1986.</li>
<li id="cite-ABD95">Hagit Attiya, Amotz Bar-Noy, and Danny Dolev, <a href="https://doi.org/10.1145/200836.200869">"Sharing Memory Robustly in Message-Passing Systems"</a>, 1995.</li>
<li id="cite-Belady69">L&aacute;szl&oacute; A. B&eacute;l&aacute;dy, R. A. Nelson, and G. S. Shedler, "An Anomaly in Space-Time Characteristics of Certain Programs Running in a Paging Machine", 1969.</li>
<li id="cite-BenOr83">Michael Ben-Or, <a href="http://doi.acm.org/10.1145/800221.806707">"Another Advantage of Free Choice (Extended Abstract): Completely Asynchronous Agreement Protocols"</a>, in Proceedings of the 2nd Annual ACM Symposium on Principles of Distributed Computing, 1983.</li>
<li id="cite-Birrell89">Andrew D. Birrell, "An introduction to programming with threads", 1989.</li>
<li id="cite-BH73">Per Brinch Hansen, "Operating System Principles", 1973.</li>
<li id="cite-CR79">Ernest Chang and Rosemary Roberts, <a href="https://doi.org/10.1145/359104.359108">"An Improved Algorithm for Decentralized Extrema-Finding in Circular Configurations of Processes"</a>, 1979.</li>
<li id="cite-CES86">Edmund M. Clarke, E. Allen Emerson, and A. Prasad Sistla, <a href="https://doi.org/10.1145/5397.5399">"Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications"</a>, 1986.</li>
<li id="cite-CES71">Edward G. Coffman, Melanie Elphick, and Arie Shoshani, <a href="https://doi.org/10.1145/356586.356588">"System Deadlocks"</a>, 1971.</li>
<li id="cite-clock">Fernando J. Corbat&oacute;, "A Paging Experiment with the Multics System", in In Honor of Philip M. Morse, 1969.</li>
<li id="cite-CHP71">Pierre-Jacques Courtois, Frans Heymans, and David L. Parnas, <a href="https://doi.org/10.1145/362759.362813">"Concurrent Control with "Readers" and "Writers""</a>, 1971.</li>
<li id="cite-DH76">Whitfield. Diffie and Martin E. Hellman, "New directions in cryptography", 1976.</li>
<li id="cite-EWD35">Edsger W. Dijkstra, <a href="http://www.cs.utexas.edu/users/EWD/ewd00xx/EWD35.PDF">"EWD-35: Over de sequentialiteit van procesbeschrijvingen"</a>, 1962.</li>
<li id="cite-EWD108">Edsger W. Dijkstra, <a href="http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD108.PDF">"EWD-108: Een algorithme ter voorkoming van de dodelijke omarming"</a>, 1964.</li>
<li id="cite-Dijkstra65">Edsger W. Dijkstra, "Solution of a Problem in Concurrent Programming Control", 1965.</li>
<li id="cite-EWD123">Edsger W. Dijkstra, "EWD-123: Cooperating Sequential Processes", 1965.</li>
<li id="cite-EWD329">Edsger W. Dijkstra, <a href="http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD329.PDF">"EWD-329: Information streams sharing a finite buffer"</a>, 1972.</li>
<li id="cite-EWD703">Edsger W. Dijkstra, <a href="http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD703.PDF">"EWD-703: A tutorial on the split binary semaphore"</a>, 1979.</li>
<li id="cite-Downey09">Allen B. Downey, <a href="http://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf">"The Little Book Of Semaphores"</a>, 2009.</li>
<li id="cite-FLP85">Michael J. Fischer, Nancy A. Lynch, and Mike Paterson, <a href="https://doi.org/10.1145/3149.214121">"Impossibility of Distributed Consensus with One Faulty Process"</a>, 1985.</li>
<li id="cite-Gray78">Jim N. Gray, <a href="https://doi.org/10.1007/3-540-08755-9_9">"Notes on data base operating systems"</a>, in Operating Systems: An Advanced Course, 1978.</li>
<li id="cite-Havender68">James W. Havender, <a href="https://doi.org/10.1147/sj.72.0074">"Avoiding Deadlock in Multitasking Systems"</a>, 1968.</li>
<li id="cite-HW87">Maurice P. Herlihy and Jeannette M. Wing, <a href="https://doi.org/10.1145/41625.41627">"Axioms for Concurrent Objects"</a>, in Proceedings of the 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, 1987.</li>
<li id="cite-HBS73">Carl Hewitt, Peter Bishop, and Richard Steiger, "A Universal Modular ACTOR Formalism for Artificial Intelligence", in Proceedings of the 3rd International Joint Conference on Artificial Intelligence, 1973.</li>
<li id="cite-Hoare74">C. A. R. Hoare, <a href="https://doi.org/10.1145/355620.361161">"Monitors: An Operating System Structuring Concept"</a>, 1974.</li>
<li id="cite-SPIN">Gerard Holzmann, "The SPIN Model Checker: Primer and Reference Manual", 2011.</li>
<li id="cite-Ingerman61">Peter Z. Ingerman, "Thunks: A Way of Compiling Procedure Statements with Some Comments on Procedure Declarations", 1961.</li>
<li id="cite-Lam78">Leslie Lamport, "Time, Clocks, and the Ordering of Events in a Distributed System", 1978.</li>
<li id="cite-Paxos">Leslie Lamport, "The Part-Time Parliament", 1998.</li>
<li id="cite-Lamport02">Leslie Lamport, "Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers", 2002.</li>
<li id="cite-Lamport09">Leslie Lamport, "The PlusCal Algorithm Language", in Theoretical Aspects of Computing - ICTAC 2009, 2009.</li>
<li id="cite-LR80">Butler W. Lampson and David D. Redell, <a href="https://doi.org/10.1145/358818.358824">"Experience with Processes and Monitors in Mesa"</a>, 1980.</li>
<li id="cite-Lowe95">Gavin Lowe, <a href="https://doi.org/10.1016/0020-0190(95)00144-2">"An Attack on the Needham-Schroeder Public-Key Authentication Protocol"</a>, 1995.</li>
<li id="cite-Lowe96">Gavin Lowe, "Breaking and fixing the Needham-Schroeder Public-Key Protocol using FDR", in Tools and Algorithms for the Construction and Analysis of Systems, 1996.</li>
<li id="cite-MS96">Maged M. Michael and Michael L. Scott, "Simple, fast, and practical non-blocking and blocking concurrent queue algorithms", in Proceedings of the 15th annual ACM Symposium on Principles of Distributed Computing (PODC), 1996.</li>
<li id="cite-MWA19">Ellis Michael, Doug Woos, Thomas Anderson, Michael D. Ernst, and Zachary Tatlock, <a href="https://doi.org/10.1145/3302424.3303947">"Teaching Rigorous Distributed Systems With Efficient Model Checking"</a>, in Proceedings of the Fourteenth EuroSys Conference 2019, 2019.</li>
<li id="cite-NS78">Roger M. Needham and Michael D. Schroeder, <a href="https://doi.org/10.1145/359657.359659">"Using Encryption for Authentication in Large Networks of Computers"</a>, 1978.</li>
<li id="cite-Peterson81">Gary L. Peterson, <a href="http://www.sciencedirect.com/science/article/pii/002001908190106X">"Myths about the mutual exclusion problem"</a>, 1981.</li>
<li id="cite-SS83">Richard D. Schlichting and Fred B. Schneider, <a href="http://dx.doi.org/10.1145/357369.357371">"Fail-Stop Processors: An Approach to Designing Fault-Tolerant Computing Systems"</a>, 1983.</li>
<li id="cite-S90">Fred B. Schneider, "Implementing fault-tolerant services using the state machine approach: A tutorial", 1990.</li>
<li id="cite-Schneider97">Fred B. Schneider, "On Concurrent Programming", 1997.</li>
<li id="cite-vRS04">Robbert van Renesse and Fred B. Schneider, <a href="http://www.usenix.org/events/osdi04/tech/renesse.html">"Chain Replication for Supporting High Throughput and Availability"</a>, in 6th Symposium on Operating System Design and Implementation (OSDI 2004), San Francisco, California, USA, December 6-8, 2004, 2004.</li>
</ol>


<p><div id='sec-235'>
<h1>Appendix A. Harmony Language Details</h1>
<p><div id='sec-236'>
<h2>Section A.1. Value Types and Operators</h2>

<p><a href='#sec-28'>Chapter 4</a> provides an introduction to Harmony values.
Below is a complete list of Harmony value types with examples:<p><table border='0'>
<tr>
<td>
Type</td>
 <td>
Name</td>
 <td>
Example</td>


</tr>
<tr>
<td>
Boolean</td>
 <td>
"bool"</td>
 <td>
<b>False</b>, <b>True</b></td>


</tr>
<tr>
<td>
Integer</td>
 <td>
"int"</td>
 <td>
..., -2, -1, 0, 1, 2, ...</td>


</tr>
<tr>
<td>
String</td>
 <td>
"str"</td>
 <td>
"example", .<i>example</i></td>


</tr>
<tr>
<td>
Program Counter</td>
 <td>
"pc"</td>
 <td>
(method names, lambdas, and labels)</td>


</tr>
<tr>
<td>
List</td>
 <td>
"list"</td>
 <td>
[ 1, 2, 3, ], ( (1, 2), 3 ), [1,], () </td>


</tr>
<tr>
<td>
Dictionary</td>
 <td>
"dict"</td>
 <td>
{ .<i>account</i>: 12345, .<i>valid</i>: <b>False</b> }, {:}</td>


</tr>
<tr>
<td>
Set</td>
 <td>
"set"</td>
 <td>
{}, { 1, 2, 3 }, { <b>False</b>, .<i>id</i>, 3 }</td>


</tr>
<tr>
<td>
Address</td>
 <td>
"address"</td>
 <td>
?<i>lock</i>, ?<i>flags</i>[2], <b>None</b></td>


</tr>
<tr>
<td>
Context</td>
 <td>
"context"</td>
 <td>
(generated by <b>stop</b> or <b>save</b> expression)</td>

</tr>
</table>

In Harmony, there is no distinction between tuples (denoted with
parentheses) and lists (denoted by square brackets).
That is, their format is either (<i>e</i>, <i>e</i>, ..., <i>e</i>,) or [<i>e</i>, <i>e</i>, ..., <i>e</i>,].
They map indexes (starting at 0) to Harmony values.
If the list has two or more elements, then the final comma is optional.<p>Method <b>type</b> <i>e</i> returns the type name of <i>e</i>.<p>All Harmony values are ordered with respect to one another.  First they
are ordered by type according to the table above.
So, for example, <b>True</b> &lt; 0 &lt; .<i>xyz</i> &lt; { 0 }.
Within types, the following rules apply:<p><ul><li> <b>False</b> &lt; <b>True</b>;
<li> integers are ordered in the natural way;
<li> strings are lexicographically ordered;
<li> program counters are ordered by their integer values;
<li> lists are lexicographically ordered;
<li> dictionaries are first converted into a list of ordered (key, value)
pairs.  Then two dictionaries are lexicographically ordered by this
representation;
<li> a set is first converted into an ordered list, then lexicographically
ordered;
<li> Except for <b>None</b>, an address is a pair of a function a list of
arguments.  Addresses are lexicographically ordered accordingly.
<b>None</b> is the smallest address.
<li> contexts (<a href='#sec-298'>Section C.3</a>) are ordered deterministically in an
unspecified way.
</ul>

Harmony supports the following comparison operators:<p><center><table border='0'>
<tr>
<td>
<i>e</i> == <i>e</i></td>
 <td>
equivalence</td>


</tr>
<tr>
<td>
<i>e</i> != <i>e</i></td>
 <td>
inequivalence</td>


</tr>
<tr>
<td>
<i>e</i> &lt; <i>e</i>, <i>e</i> &lt;= <i>e</i>, <i>e</i> &gt; <i>e</i>, <i>e</i> &gt;= <i>e</i></td>
 <td>
comparison</td>

</tr>
</table>
</center>

Comparison operators can be chained: <i>x</i> &lt;= <i>y</i> == <i>z</i>
means <i>x</i> &lt;= <i>y</i> <b>and</b> <i>y</i> == <i>z</i>, although <i>y</i> is evaluated once in the
former and twice in the latter expression.
Note that evaluation of a chain stops as soon as one of the
comparisons fails.  So, 1 &lt; 0 &lt; <i>x</i> does not evaluate <i>x</i>.<p>Harmony supports atomic expression evaluation using the
following syntax: <b>atomically</b> <i>e</i>, where <i>e</i> is some expression.<p><div id='sec-237'>
<h3 id="sec-237">Boolean</h3><p>The boolean type has only two possible values: <b>False</b> and
<b>True</b>.  Unlike Python, in Harmony booleans are distinct
from integers, and in particular  <span 
class="cmbx-10">False</span> <span 
class="cmmi-10">&#x003C; </span>0 .  In statements
and expressions where booleans are expected, it is not possible to
substitute values of other types.<p>Operations on booleans include:
<center><table border='0'>
<tr>
<td>
<i>e</i> <b>and</b> <i>e</i> <b>and</b> ...</td>
 <td>
conjuction</td>


</tr>
<tr>
<td>
<i>e</i> <b>or</b> <i>e</i> <b>or</b> ...</td>
 <td>
disjunction</td>


</tr>
<tr>
<td>
<i>e</i> =&gt; <i>e</i>, <i>e</i> <b>not</b> =&gt; <i>e</i></td>
 <td>
implication</td>


</tr>
<tr>
<td>
<b>not</b> <i>e</i></td>
 <td>
negation</td>


</tr>
<tr>
<td>
<i>v</i> <b>if</b> <i>e</i> <b>else</b> <i>v</i>'</td>
 <td>
<i>v</i> or <i>v</i>' depending on <i>e</i></td>


</tr>
<tr>
<td>
<b>any</b> <i>s</i>, <b>all</b> <i>s</i></td>
 <td>
disjunction / conjunction for set or list <i>s</i></td>

</tr>
</table>
</center>

The meanings of <b>or</b>, <b>and</b>, and =&gt; are perhaps best explained by putting
them in terms of the ternary <b>if</b> <b>else</b> operator:<p><ul><li> <i>x</i> <b>or</b> <i>y</i> means <b>True</b> <b>if</b> <i>x</i> <b>else</b> <i>y</i>
<li> <i>x</i> <b>and</b> <i>y</i> means <b>False</b> <b>if</b> <b>not</b> <i>x</i> <b>else</b> <i>y</i>
<li> <i>x</i> =&gt; <i>y</i> means <b>True</b> <b>if</b> <b>not</b> <i>x</i> <b>else</b> <i>y</i>
</ul>

Note that this means that the result of the operation may not be
a Boolean. For example, (<b>False</b> <b>or</b> 2) == 2.  Also, the operators
are not commutative.  2 <b>or</b> <b>False</b> is an illegal expression because
you cannot use an integer as a condition for <b>if</b>.
(Unlike in Python, in Harmony only <b>True</b> is &quot;thruthy&quot; and
only <b>False</b> is &quot;falsy.&quot;)
We recommend using only Booleans for these operators,
so that their outputs are also guaranteed to be a Boolean.
Finally, note that the righthand side of the expression may not be evaluated.
For example, <b>True</b> <b>or</b> <i>x</i> evaluates to <b>True</b> without evaluating
<i>x</i>.
</div>

<div id='sec-238'>
<h3 id="sec-238">Integer</h3><p>The integer type supports any whole number.
Harmony supports decimal integers, hexadecimal integers (start
with `0x'), binary integers (start with `0b'), and octal integers
(start with `0o').<p>In the C-based model checker, integers are currently implemented
by two's complement 60-bit words.
The model checker checks for overflow on various operations.<p>Operations on integers include:<p><center><table border='0'>
 <tr>
<td>
-<i>e</i></td>
 <td>
negation</td>


</tr>
<tr>
<td>
<b>abs</b> <i>e</i></td>
 <td>
absolute value</td>


</tr>
<tr>
<td>
<i>e</i> + <i>e</i> + ...</td>
 <td>
sum</td>


</tr>
<tr>
<td>
<i>e</i> - <i>e</i></td>
 <td>
difference</td>


</tr>
<tr>
<td>
<i>e</i> * <i>e</i> * ...</td>
 <td>
product</td>


</tr>
<tr>
<td>
<i>e</i> / <i>e</i>, <i>e</i> // <i>e</i></td>
 <td>
integer division</td>


</tr>
<tr>
<td>
<i>e</i> % <i>e</i>, <i>e</i> <b>mod</b> <i>e</i></td>
 <td>
integer division remainder</td>


</tr>
<tr>
<td>
<i>e</i> ** <i>e</i></td>
 <td>
power</td>


</tr>
<tr>
<td>
~<i>e</i></td>
 <td>
binary inversion</td>


</tr>
<tr>
<td>
<i>e</i> & <i>e</i> & ...</td>
 <td>
binary and</td>


</tr>
<tr>
<td>
<i>e</i> | <i>e</i> | ...</td>
 <td>
binary or</td>


</tr>
<tr>
<td>
<i>e</i> ^ <i>e</i> ^ ...</td>
 <td>
binary exclusive or</td>


</tr>
<tr>
<td>
<i>e</i> &lt;&lt; <i>e</i></td>
 <td>
binary shift left</td>


</tr>
<tr>
<td>
<i>e</i> &gt;&gt; <i>e</i></td>
 <td>
binary shift right</td>


</tr>
<tr>
<td>
{ <i>e..e</i>' }</td>
 <td>
set of integers from <i>e</i> to  <span 
class="cmmi-10">e</span><span 
class="cmsy-10">&#x2032; </span> inclusive</td>

</tr>
</table>
</center>
</div>

<div id='sec-239'>
<h3 id="sec-239">String</h3><p>A string is a sequence of zero or more unicode characters.
If it consists entirely of alphanumerical characters or underscore
characters and does not start with a digit,
then a string can be represented by a &quot;.&quot; followed by the characters.
For example, .<i>example</i> is the same as the string "example".<p>Native operations on strings include the following:<p><center><table border='0'>
 <tr>
<td>
<i>s</i> <i>k</i></td>
 <td>
indexing</td>


</tr>
<tr>
<td>
<i>s</i> <i>s</i> ...</td>
 <td>
concatenation</td>


</tr>
<tr>
<td>
<i>s</i> + <i>s</i> + ...</td>
 <td>
concatenation</td>


</tr>
<tr>
<td>
<i>s</i> * <i>n</i></td>
 <td>
<i>n</i> copies of <i>s</i> concatenated</td>


</tr>
<tr>
<td>
<i>v</i> [<b>not</b>] <b>in</b> <i>s</i></td>
 <td>
check if <i>v</i> is [not] a substring in <i>s</i></td>


</tr>
<tr>
<td>
<b>len</b> <i>s</i></td>
 <td>
the length of <i>s</i></td>


</tr>
<tr>
<td>
<b>str</b> <i>e</i></td>
 <td>
string representation of any value <i>e</i></td>

</tr>
</table>
</center>
</div>

<div id='sec-240'>
<h3 id="sec-240">Set</h3><p>In Harmony you can create a set of any collection of Harmony values.
Its syntax is  <span 
class="cmmi-10">v</span><sub><span 
class="cmr-7">0</span></sub><span 
class="cmmi-10">,v</span><sub><span 
class="cmr-7">1</span></sub><span 
class="cmmi-10">,...</span>
.
Python users: note that in Harmony the empty set is denoted as {}.
(In Python, {} means the empty dictionary, which is represented
as {:} in Harmony.)<p>The <code>set</code> module (<a href='#sec-293'>Section B.7</a>)
contains various convenient routines that operate on sets.
Native operations on sets include:<p><center><table border='0'>
 <tr>
<td>
<b>len</b> <i>s</i></td>
 <td>
cardinality</td>


</tr>
<tr>
<td>
<i>s</i> - <i>s</i></td>
 <td>
set difference</td>


</tr>
<tr>
<td>
<i>s</i> & <i>s</i> & ...</td>
 <td>
intersection</td>


</tr>
<tr>
<td>
<i>s</i> | <i>s</i> | ...</td>
 <td>
union</td>


</tr>
<tr>
<td>
<i>s</i> ^ <i>s</i> ^ ...</td>
 <td>
inclusion/exclusion (elements in odd number of sets)</td>


</tr>
<tr>
<td>
<b>choose</b> <i>s</i></td>
 <td>
select an element (Harmony will try all)</td>


</tr>
<tr>
<td>
<b>min</b> <i>s</i></td>
 <td>
minimum element</td>


</tr>
<tr>
<td>
<b>max</b> <i>s</i></td>
 <td>
maximum element</td>


</tr>
<tr>
<td>
<b>any</b> <i>s</i></td>
 <td>
<b>True</b> if any value is <b>True</b></td>


</tr>
<tr>
<td>
<b>all</b> <i>s</i></td>
 <td>
<b>True</b> if all values are <b>True</b></td>

</tr>
</table>
</center>


<p>In Python, the  <span 
class="cmmi-10">&#x003C; </span> operator on sets represents the subset relation.
However, in Harmony  <span 
class="cmmi-10">&#x003C; </span> is a total order.
If you want to check
if <i>x</i> is a subset of <i>y</i>, either use the <var>subset</var> method in the
<var>set</var> module or write something like (<i>x</i> | <i>y</i>) == <i>y</i> (the union of
<i>x</i> and <i>y</i> is <i>y</i>).<p>Harmony also supports <i>set comprehension</i>.  In its simplest form,
{<var>f</var>(<i>v</i>) <b>for</b> <i>v</i> <b>in</b> <i>s</i>} returns a set that is constructed
by applying <code>f</code> to all elements in <i>s</i> (where <i>s</i> is a set or
a list).
This is known as <i>mapping</i>.  But set comprehension is much more
powerful and can include joining multiple sets (using nested for
loops) and filtering (using the <code>where</code> keyword).<p>For example: <i>x</i> + <i>y</i> <b>for</b> <i>x</i> <b>in</b> <i>s</i> <b>for</b> <i>y</i> <b>in</b> <i>s</i> <b>where</b> (<i>x</i> * <i>y</i>) == 4
returns a set that is constructed by summing pairs of elements from <i>s</i>
that, when multiplied, have the value 4.
</div>

<div id='sec-241'>
<h3 id="sec-241">List or Tuple</h3><p>In Harmony, there is no distinction between a list or a tuple.
You can denote a list by a sequence of values, each value terminated
by a comma.  As per usual, you can use brackets or parentheses
at your discretion.  For Python users, the important thing to note
is that a singleton list in Harmony must contain a comma.  For
example  [1<span 
class="cmmi-10">,</span>]
 is a list containing the value  1 , while  [1] 
is simply the value 
1 .<p>The <code>list</code> module (<a href='#sec-292'>Section B.6</a>) contains various
convenient routines that operate on lists or tuples.
Native operations on lists or tuples include the following:<p><center><table border='0'>
 <tr>
<td>
<i>t</i> <i>k</i></td>
 <td>
indexing</td>


</tr>
<tr>
<td>
<i>t</i> <i>t</i> ...</td>
 <td>
concatenation</td>


</tr>
<tr>
<td>
<i>t</i> + <i>t</i> + ...</td>
 <td>
concatenation</td>


</tr>
<tr>
<td>
<i>t</i> * <i>n</i></td>
 <td>
<i>n</i> copies of <i>t</i> concatenated</td>


</tr>
<tr>
<td>
<i>v</i> [<b>not</b>] <b>in</b> <i>t</i></td>
 <td>
check if <i>v</i> is [not] a value in <i>t</i></td>


</tr>
<tr>
<td>
<b>len</b> <i>t</i></td>
 <td>
the length of <i>t</i></td>


</tr>
<tr>
<td>
<b>min</b> <i>t</i></td>
 <td>
the minimum value in <i>t</i></td>


</tr>
<tr>
<td>
<b>max</b> <i>t</i></td>
 <td>
the maximum value in <i>t</i></td>


</tr>
<tr>
<td>
<b>any</b> <i>t</i></td>
 <td>
<b>True</b> if any value is <b>True</b></td>


</tr>
<tr>
<td>
<b>all</b> <i>t</i></td>
 <td>
<b>True</b> if all values are <b>True</b></td>

</tr>
</table>
</center>

Lists and tuples support comprehension.
In its most basic form: [<var>f</var>(<i>v</i>) <b>for</b> <i>v</i> <b>in</b> <i>t</i>].
For example, to check if any element in a list <i>t</i> is even, you
can write: <b>any</b>((<i>x</i> % 2) == 0 <b>for</b> <i>x</i> <b>in</b> <i>t</i>).<p>The domain of a list  <span 
class="cmmi-10">L </span> of length <i>n</i>, interpreted as a function, are the
integers  0<span 
class="cmmi-10">..n </span><span 
class="cmsy-10">- </span>1 .  It is illegal to read  <span 
class="cmmi-10">L</span>[<span 
class="cmmi-10">n</span>] .  However, unlike
Python, it is possible to write into  <span 
class="cmmi-10">L</span>[<span 
class="cmmi-10">n</span>] .  For example, if
variable <i>x</i> contains [1, 2], then the statement <i>x</i>[2] = 3
results in <i>x</i> having the value [1, 2, 3].
</div>

<div id='sec-242'>
<h3 id="sec-242">Dictionary</h3><p>A dictionary maps a set of values (known as <i>keys</i>)
to another set of values.
The generic syntax of a dictionary is

<span 
class="cmsy-10">{</span><span 
class="cmmi-10">k</span><sub><span 
class="cmr-7">0</span></sub> : <span 
class="cmmi-10">v</span><sub><span 
class="cmr-7">0</span></sub><span 
class="cmmi-10">,k</span><sub><span 
class="cmr-7">1</span></sub> : <span 
class="cmmi-10">v</span><sub><span 
class="cmr-7">1</span></sub><span 
class="cmmi-10">,...</span><span 
class="cmsy-10">} </span>.
Different from Python, the empty dictionary is written as {:}
(because {} is the empty set in Harmony).
If there are duplicate keys in the list, then only the one with
the maximum value survives.
Therefore the order of the keys in the dictionary does not matter.<p>Dictionaries support comprehension.  The basic form is:
{ <var>f</var>(<i>v</i>):<var>g</var>(<i>v</i>) <b>for</b> <i>v</i> <b>in</b> <i>s</i> }.<p>There are various special cases of dictionaries,
including lists, tuples, strings,
and bags (multisets) that are individually described below.<p>Operations on dictionaries include the following:<p><center><table border='0'>
 <tr>
<td>
<i>d</i> <i>k</i></td>
 <td>
indexing</td>


</tr>
<tr>
<td>
<b>len</b> <i>d</i></td>
 <td>
the number of keys in <i>d</i></td>


</tr>
<tr>
<td>
<b>keys</b> <i>d</i></td>
 <td>
the set of keys in <i>d</i></td>


</tr>
<tr>
<td>
<i>k</i> [<b>not</b>] <b>in</b> <i>d</i></td>
 <td>
check if <i>k</i> is [not] a key in <i>d</i></td>


</tr>
<tr>
<td>
<b>min</b> <i>d</i></td>
 <td>
the minimum value in <i>d</i></td>


</tr>
<tr>
<td>
<b>max</b> <i>d</i></td>
 <td>
the maximum value in <i>d</i></td>


</tr>
<tr>
<td>
<b>any</b> <i>d</i></td>
 <td>
<b>True</b> if any value is <b>True</b></td>


</tr>
<tr>
<td>
<b>all</b> <i>d</i></td>
 <td>
<b>True</b> if all values are <b>True</b></td>


</tr>
<tr>
<td>
<i>d</i> & <i>d</i> & ...</td>
 <td>
dictionary intersection</td>


</tr>
<tr>
<td>
<i>d</i> | <i>d</i> | ...</td>
 <td>
dictionary union</td>

</tr>
</table>
</center>

Because in Harmony brackets are used for parsing purposes only,
you can write <i>d</i>[<i>k</i>] (or <i>d</i>(<i>k</i>)) instead of <i>d</i> <i>k</i>.
However, if <i>k</i> is a string like .<i>id</i>, then you might
prefer the notation <i>k.id</i>.<p>Dictionary intersection and dictionary union are defined so that
they work well with bags.  With disjoint dictionaries, intersection
and union work as expected.  If there is a key in the intersection, then
dictionary intersection retains the minimum value while dictionary
union retains the maximum value.  Unlike Python, Harmony
dictionary intersection and union are commutative and associative.<p>A bag is represented by a dictionary that maps each element to its
multiplicity. For example, { 10:2, 12:1 } is the bag containing
two copies of 10 and one copy of 12.
The <code>bag</code> module (<a href='#sec-289'>Section B.3</a>) contains various
convenient routines that operate on bags.
Native operations on bags include the following:<p><center><table border='0'>
 <tr>
<td>
<i>v</i> [<b>not</b>] <b>in</b> <i>b</i></td>
 <td>
check if <i>v</i> is [not] in <i>b</i></td>


</tr>
<tr>
<td>
<i>t</i> & <i>t</i> & ...</td>
 <td>
bag intersection</td>


</tr>
<tr>
<td>
<i>t</i> | <i>t</i> | ...</td>
 <td>
bag union</td>

</tr>
</table>
</center>
</div>

<div id='sec-243'>
<h3 id="sec-243">Program Counter</h3><p>A program counter is an integer that can be used to index into Harmony
bytecode.  When you define a method, a lambda function, or a label,
you are creating a constant of the program counter type.
You can create lambda functions similarly to Python, except that the
expression has to end on the keyword <b>end</b>.  For example:
<b>lambda</b>(<i>x</i>,<i>y</i>): <i>x</i>+<i>y</i> <b>end</b>.
</div>

<div id='sec-244'>
<h3 id="sec-244">Address</h3><p>A Harmony address is a type of <i>thunk</i> consisting of a curried
function and a list of arguments  [<a href="#cite-Ingerman61">27</a>].
A thunk delays the invocation of the
curried function.  A function can be a constant or a
variable and the arguments are all Harmony values.
Given an address <i>p</i> = ?<var>a</var>[<i>b</i>][<i>c</i>]..., you can use the notation !<i>p</i>
to evaluate it.  Harmony will first evaluate <var>a</var>,
then apply the result to <i>b</i>, then apply the result to <i>c</i>, and so on.<p>As a simple example, ?5 is the address of the constant 5, and
therefore !?5 evaluates to 5.
Now consider the following program:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>let</b> <i>p</i> = ?5:
    <b>assert</b> !<i>p</i> == 5
    !<i>p</i> = 5
    !<i>p</i> = 4
</code></pre>
</center>

The only line in this program that fails is the last one, as you are
not allowed to store 4 at the address of 5.<p><var>a</var> can be a constant that maps Harmony values to
Harmony values: dictionaries, lists, and strings.  In that case, ?<var>a</var>[<i>b</i>]
refers to the value of entry <i>b</i> in <var>a</var>.<p>The most common use of addresses is when <var>a</var> is a shared variable.
In that case !?<var>a</var> evaluates to the current value of <var>a</var>.<p>Finally, <var>a</var> can be a program counter value (method or lambda).
?<var>a</var>(<i>b</i>) is then the thunk representing a delayed call to
method <var>a</var> and argument <i>b</i>.
In this case, !?<var>a</var>(<i>b</i>) evaluates <var>a</var>(<i>b</i>).  For example, the
following Harmony program, perhaps surprisingly, does not run into
failing assertions:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>counter</i> = 0

<b>def</b> <var>f</var>():
    <i>counter</i> += 1
    <i>result</i> = <i>counter</i>

<b>let</b> <i>p</i> = ?<var>f</var>():
    <b>if</b> !<i>p</i> != 1: <b>assert</b> <b>False</b>
    <b>if</b> !<i>p</i> != 2: <b>assert</b> <b>False</b>
    <b>if</b> !<i>p</i> != 3: <b>assert</b> <b>False</b>
</code></pre>
</center>

Internally, Harmony uses the address of a method variable
and sometimes you see them on the stack during a computation.
If <i>k</i> is a method variable, then its address is output as ?@<i>k</i>.
However, at the Harmony language level there is no such thing
as the address of a local variable.
Consider the following two programs:<p><center><table border='0'>
 <tr>
<td>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><i>x</i> = 1
<b>let</b> <i>p</i> = ?<i>x</i>:
    <i>x</i> = 2
    <b>assert</b> !<i>p</i> == 2
</code></pre>
</td>

<td>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><b>var</b> <i>x</i> = 1
<b>let</b> <i>p</i> = ?<i>x</i>:
    <i>x</i> = 2
    <b>assert</b> !<i>p</i> == 1
</code></pre>
</td>

</table>
</center>

In the program on the left, <i>x</i> is a shared variable, and ?<i>x</i> is
the location of variable <i>x</i>.  In the program on the right, <i>x</i>
is a local variable.  ?<i>x</i> evaluates <i>x</i> and then takes its address,
so in this case ?<i>x</i> equals ?1.<p>Like C, Harmony supports
the shorthand <i>p</i>-&gt;<i>v</i> for the expression (!<i>p</i>).<i>v</i>.
</div>

<div id='sec-245'>
<h3 id="sec-245">Context</h3><p>A context value (aka continuation) captures the state of a thread.
A context is itself composed over various Harmony values.
The following operations generate contexts:
<center><table border='0'>
 <tr>
<td>
<b>save</b> <i>e</i></td>
 <td>
returns a Harmony value (see below)</td>


</tr>
<tr>
<td>
<b>stop</b> <i>p</i></td>
 <td>
saves context in !<i>p</i> and stops the thread (see below)</td>

</tr>
</table>
</center>

The <b>save</b> <i>e</i> expression, when invoked, returns a tuple (<i>e</i>, <i>c</i>) where
<i>c</i> is the context value of the thread right after the <b>save</b> instruction
finished.
Using <b>go</b> <i>c</i> <i>r</i> the context can be turned into a new thread that, instead,
returns <i>r</i> from the <b>save</b> <i>e</i> expression.  See <a href='#sec-260'>Figure B.1</a>
for an example of how this could be used to <i>fork</i> a thread into
two threads.<p>The <b>stop</b> <i>p</i> expression stores the context of the thread right after
the expression in !<i>p</i> (i.e., <i>p</i> must be an address value) and
terminates the thread.  The thread can later be reinstantiated with
<b>go</b> !<i>p</i> <i>r</i>, in which case the <b>stop</b> expression returns <i>r</i>.
A thread can be for ever suspended using <b>stop</b> <b>None</b> or just <b>stop</b>().
</div>
</div>

<div id='sec-246'>
<h2>Section A.2. Statements</h2>
<p>Harmony currently supports the following statements
(below, <var>S</var> is a list of statements and an <i>lvalue</i> is an
expression you can use on the left-hand side of an assignment statement):<p><table border='0'>
 <tr>
<td>
<i>e</i></td>
 <td>
<i>e</i> is an expression</td>


</tr>
<tr>
<td>
<i>lv</i> = [<i>lv</i> =]... <i>e</i></td>
 <td>
<i>lv</i> is an lvalue and <i>e</i> is an expression</td>


</tr>
<tr>
<td>
<i>lv</i> [<i>op</i>]= <i>e</i></td>
 <td>
<i>op</i> is one of <code>+</code>, <code>-</code>,
*, /, //, %,
&, |, ^, <b>and</b>, <b>or</b></td>


</tr>
<tr>
<td>
<b>assert</b> <i>b</i> [, <i>e</i>]</td>
 <td>
<i>b</i> is a boolean.  Optionally report value of expression <i>e</i></td>


</tr>
<tr>
<td>
<b>await</b> <i>b</i></td>
 <td>
<i>b</i> is a boolean</td>


</tr>
<tr>
<td>
<b>const</b> <var>a</var> = <i>e</i></td>
 <td>
<var>a</var> is a bound variable, <i>e</i> is a constant expression</td>


</tr>
<tr>
<td>
<b>def</b> <i>m</i> <var>a</var> [<b>returns</b> <i>v</i>]: <var>S</var></td>
 <td>
<i>m</i> is an identifier, <var>a</var> a bound variable, and <i>v</i> a variable</td>


</tr>
<tr>
<td>
<b>del</b> <i>lv</i></td>
 <td>
delete <i>lv</i></td>


</tr>
<tr>
<td>
<b>finally</b> <i>e</i></td>
 <td>
<i>e</i> is a boolean expression that must hold in each final state</td>


</tr>
<tr>
<td>
<b>for</b> <var>a</var>[:<i>b</i>] <b>in</b> <i>e</i> [<b>where</b> <i>c</i>]: <var>S</var></td>
 <td>
<var>a</var> and <i>b</i> are bound variables, <i>e</i> is a set, dictionary, or string</td>


</tr>
<tr>
<td>
<b>from</b> <i>m</i> <b>import</b> ...</td>
 <td>
<i>m</i> identifies a module</td>


</tr>
<tr>
<td>
<b>global</b> <i>v</i>, ... </td>
 <td>
<i>v</i> is a shared global variable</td>


</tr>
<tr>
<td>
<b>go</b> <i>c</i> <i>e</i></td>
 <td>
<i>c</i> is a context, <i>e</i> is an expression</td>


</tr>
<tr>
<td>
<b>if</b> <i>b</i>: <var>S</var> <b>else</b>: <var>S</var></td>
 <td>
<i>b</i> is a boolean, <var>S</var> is a list of statements</td>


</tr>
<tr>
<td>
<b>import</b> <i>m</i>, ...</td>
 <td>
<i>m</i> identifies a module</td>


</tr>
<tr>
<td>
<b>invariant</b> <i>e</i></td>
 <td>
<i>e</i> is an invariant (must always hold)</td>


</tr>
<tr>
<td>
<b>let</b> <var>a</var> = <i>e</i>: <var>S</var></td>
 <td>
<var>a</var> is a bound variable, <i>e</i> is an expression</td>


</tr>
<tr>
<td>
<b>pass</b></td>
 <td>
do nothing</td>


</tr>
<tr>
<td>
<b>print</b> <i>e</i></td>
 <td>
<i>e</i> is an expression</td>


</tr>
<tr>
<td>
<b>sequential</b> <i>v</i>, ...</td>
 <td>
<i>v</i> has sequential consistency</td>


</tr>
<tr>
<td>
<b>spawn</b> [<b>eternal</b>] <i>lv</i> [, <i>t</i>]</td>
 <td>
<i>lv</i> is an lvalue expression,
<i>t</i> is the thread-local state</td>


</tr>
<tr>
<td>
<b>trap</b> <i>lv</i></td>
 <td>
<i>lv</i> is an lvalue expression</td>


</tr>
<tr>
<td>
<b>var</b> <i>v</i> = <i>e</i></td>
 <td>
<i>v</i> is a new variable, <i>e</i> is an expression</td>


</tr>
<tr>
<td>
<b>when</b> <i>b</i>: <var>S</var></td>
 <td>
<i>b</i> is a boolean, <var>S</var> a list of statements</td>


</tr>
<tr>
<td>
<b>when</b> <b>exists</b> <var>a</var> <b>in</b> <i>e</i>: <var>S</var></td>
 <td>
<var>a</var> is a bound variable, <i>e</i> is an expression</td>


</tr>
<tr>
<td>
<b>while</b> <i>b</i>: <var>S</var></td>
 <td>
<i>b</i> is a boolean, <var>S</var> a list of statements</td>

</tr>
</table>

<ul><li> Bound variables are read-only.
<li> A statement can be preceded by the <b>atomically</b> keyword to make
the statement atomic.
<li> Multiple <b>for</b> statements can be combined into a single statement.
<li> Multiple <b>let</b> and <b>when</b> statements can be combined into
a single statement.
</ul>

<div id='sec-247'>
<h3 id="sec-247">Single expression evaluation</h3><p>Any expression by itself can be used as a statement.  The most common
form of this is a function application, for example: <code>f</code>().
This statement evaluates <code>f</code>() but ignores its result.
It is equivalent to the assignment statement  _ = <span 
class="cmtt-10">f</span>() .
</div>

<div id='sec-248'>
<h3 id="sec-248">Assignment</h3><p>The statement <i>x</i> = 3 changes the state by assigning 3 to
variable <i>x</i> (assuming <i>x</i> was not already 3).
<i>x</i> may be a local variable or a shared variable.
The statement <i>x</i> = <i>y</i> = 3 first updates <i>y</i>, then <i>x</i>.
The statement <i>x</i>[<var>f</var>()] = <i>y</i>[<var>g</var>()] = <var>h</var>() first computes
the address of <i>x</i>[<var>f</var>()], then computes the address of
<i>y</i>[<var>g</var>()], then evaluates <var>h</var>(),
then assigns the resulting value to <i>y</i>[<var>g</var>()]
(using its previously computed address),
and finally assigns the same value to <i>x</i>[<var>f</var>()]
(again using its previously computed address).
The statement <var>a</var>,<i>b</i> = <i>c</i> assumes that <i>c</i> is a tuple with two values.
It first evaluates the addresses of <var>a</var> and <i>b</i> and first assigns to
the latter and then the former.
If <i>c</i> is not a tuple with two values, then Harmony will report an error.<p>Assigning to <var>_</var> (underscore) evaluates the righthand side expression
but is otherwise a no-op.
The left-hand side can also contain constants.
For example (3, <i>x</i>) = (3, <b>True</b>) assigns <b>True</b> to <i>x</i>.
However, (3, <i>x</i>) = (4, <b>True</b>) fails.<p>The statement  <span 
class="cmmi-10">x</span><span 
class="cmmi-10">&#x00A0;</span>+
 = 3  loads <i>x</i>, adds 3, and then stores the
results in <i>x</i>.  In this case, it is equivalent to  <span 
class="cmmi-10">x </span>= <span 
class="cmmi-10">x </span>+ 3 .
However, in general this is not so.  For example, <i>x</i>[<var>f</var>()] += 3
only evaluates <var>f</var>() once.  Unlike Python, however,
<i>x</i> += [3,] is equivalent to <i>x</i> = <i>x</i> + [3,] in Harmony.
(In Python, the following two compound statements lead to different results
for <i>y</i>: <i>x</i> = <i>y</i> = []; <i>x</i> += [3] and <i>x</i> = <i>y</i> = []; <i>x</i> = <i>x</i> + [3].)
</div>

<div id='sec-249'>
<h3 id="sec-249"><b>assert</b></h3><p>The statement <b>assert</b> <i>b</i> evaluates <i>b</i> and reports an error
if <i>b</i> is false.  It should be considered a no-op---it is part of the
<i>specification</i>, not part of the <i>implementation</i> of the algorithm.
In particular, it specifies an invariant: whenever the program counter is
at the location where the <b>assert</b> statement is, then <i>b</i> is
always true.<p>If <i>b</i> is an expression, then it is evaluated atomically.
Moreover, the expression is not allowed to change the state.
If it does change the state, Harmony will report an error as well.<p>As in Python, you can specify an additional expression:
<b>assert</b> <i>b</i>, <i>e</i>.  The value of <i>e</i> will be reported as part
of the error should <i>b</i> evaluate to false.
</div>

<div id='sec-250'>
<h3 id="sec-250"><b>atomically</b></h3><p>A statement can be preceded by the <b>atomically</b> keyword to
make the statement atomic.
The statement <b>atomically</b>: <var>S1</var>; <var>S2</var>; ... evaluates statements
<var>S1</var>, <var>S2</var>, ... atomically.
This means that the statement runs indivisibly---no other thread can
interleave in the atomic statement.  The only exception
to this is if the atomic block executes a <b>stop</b> expression.
In this case, another thread can run.  When the original thread
is resumed (using a <b>go</b> statement), it is once again
atomically executing.<p><b>atomically</b> statements are useful for specification and
implementing synchronization primitives such as test-and-set.
It is also useful for testing.
It is not a replacement for lock/unlock, and should not generally be used
for synchronization otherwise.  Lock/unlock does allow other
threads to run concurrently---just not in the same critical section.
</div>

<div id='sec-251'>
<h3 id="sec-251"><b>await</b></h3><p>The statement <b>await</b> <i>b</i> is equivalent to <b>when</b> <i>b</i>: <b>pass</b>.
It is intended to improve readability of your code.
</div>

<div id='sec-252'>
<h3 id="sec-252"><b>const</b></h3><p>The expression <b>const</b> <var>N</var> = 3 introduces a new constant
<var>N</var> with the value 3.  Evaluating <var>N</var> does not lead to
loading from a memory location.  The assignment can be overridden with
the <code>-c</code> flag: <code>harmony -cN=4</code> executes the model checker
with 4 assigned to <var>N</var> instead of 3.
Harmony also supports <b>const</b> <var>N</var>, <var>M</var> = 3, 4, which
assigns 3 to <var>N</var> and 4 to <var>M</var>.
Harmony has limited support for <i>constant folding</i>.  For example,
<b>const</b> <var>N</var> = 3 + 4 assigns value 7 to constant <var>N</var>.
</div>

<div id='sec-253'>
<h3 id="sec-253"><b>def</b></h3><p>The statement <b>def</b> <i>m</i> <var>a</var> [<b>returns</b> <i>r</i>]: <var>S1</var>; <var>S2</var>: ...
defines a new program counter constant <i>m</i> referring to
a method that takes an argument <var>a</var> and executes the statements
<var>S1</var>, <var>S2</var>, ....  The argument <var>a</var> can be a tuple pattern similar
to those used in <b>let</b> and <b>for</b> statements.
Examples include (), (<i>x</i>,), (<i>x</i>, <i>y</i>), and (<i>x</i>, (<i>y</i>, <i>z</i>)).
The given local variable names are assigned upon application and
are read-only.
Optionally, a result variable <i>r</i> can be declared.  If not declared,
there is (for backwards compatibility), a default result variable
called <i>result</i>, initialized to <b>None</b>.
Harmony does not support a <code>return</code> statement that <i>breaks out</i>
of the code before executing the last statement.
</div>

<div id='sec-254'>
<h3 id="sec-254"><b>del</b></h3><p>The statement <b>del</b> <i>x</i> removes variable <i>x</i> from the
state.  <i>x</i> can be either a local or a shared variable.  For
example, the statement <b>del</b> <i>x.age</i> removes
the .<i>age</i> field from dictionary <i>x</i>.
Harmony automatically removes top-level local variables that
are no longer in use
from the state in order to attempt to reduce the number of states
that are evaluated during model checking.<p><b>del</b> can also be used to remove elements from a list.
<i>x</i> = [.<i>a</i>, .<i>b</i>, .<i>c</i>]; <b>del</b> <i>x</i>[1] results in <i>x</i> having value [.<i>a</i>, .<i>c</i>].
</div>

<div id='sec-255'>
<h3 id="sec-255"><b>finally</b></h3><p>The statement <b>finally</b> <i>c</i> declares that boolean expression <i>c</i>
must hold in each final state.
<i>c</i> is only allowed to read shared variables and
is evaluated in each final state.
If it evaluates to <b>False</b>, Harmony reports an error.  Harmony
also reports an error if the expression evaluates to a value other
than <b>False</b> or <b>True</b>.
</div>

<div id='sec-256'>
<h3 id="sec-256"><b>for</b> ... <b>in</b> ... [<b>where</b> ...]</h3><p>The statement <b>for</b> <i>x</i> <b>in</b> <i>y</i>: <var>S1</var>; <var>S2</var>; ...
iterates over <i>y</i> and executes for each element the statements
<var>S1</var>, <var>S2</var>, ....
<i>y</i> must be a set, list, dictionary, or string.  <i>y</i> is evaluated only once at
the beginning of the evaluation of this statement.  In case of a set,
the result is sorted (using Harmony's global order on all values).
In case of a dictionary, the statement iterates over the keys in order.
For each element, the statements <var>S1</var>, <var>S2</var>, ... are executed with
local variable <i>y</i> having the value of the element.
<i>x</i> can be a pattern such as  (<span 
class="cmmi-10">a</span>)  or  (<span 
class="cmmi-10">a,</span>(<span 
class="cmmi-10">b,c</span>)) .
If the pattern cannot be matched, Harmony detects and error.
It is allowed, but discouraged, to assign different values to <i>x</i>
within statements <var>S1</var>, <var>S2</var>, ....<p>Harmony also supports the form
<b>for</b> <i>k</i>:<i>v</i> <b>in</b> <i>y</i>: <var>S1</var>; <var>S2</var>; ....  This works similar,
except that <i>k</i> is bound to the key and <i>v</i> is bound to the value.
If <i>y</i> is not a dictionary, then <i>k</i> ranges from 0 to
<b>len</b>(<i>y</i>) - 1.<p>The statement also supports nesting and filtering.
Nesting is of the form
<b>for</b> <i>x1</i> <b>in</b> <i>y1</i> <b>for</b> <i>x2</i> <b>in</b> <i>y2</i>: <var>S1</var>; <var>S2</var>; ...,
which is equivalent to the statement
<b>for</b> <i>x1</i> <b>in</b> <i>y1</i>: <b>for</b> <i>x2</i> <b>in</b> <i>y2</i>: <var>S1</var>; <var>S2</var>; ....
Filtering is of the form
<b>for</b> <i>x</i> <b>in</b> <i>y</i> <b>where</b> <i>z</i>: <var>S1</var>; <var>S2</var>; ....
For example,
<b>for</b> <i>x</i> <b>in</b> 1 .. 10 <b>where</b> (<i>x</i> % 2) == 0: <var>S1</var>; <var>S2</var>; ...
only evaluates statements <var>S1</var>, <var>S2</var>, ... for even <i>x</i>,
that is, 2, 4, 6, 8, and 10.<p>Harmony does not support <b>break</b> or <b>continue</b> statements.
</div>

<div id='sec-257'>
<h3 id="sec-257"><b>from</b> ... <b>import</b></h3><p>The statement <b>from</b> <i>x</i> <b>import</b> <var>a</var>, <i>b</i>, ...
imports module <i>x</i> and makes its constants <var>a</var>, <i>b</i>, ... also constants
in the current module.  If a module is imported more than once, its code
is only included the first time.  The constants will typically be the
names of methods (program counter constants) within the module.<p>You can import all constants from a module <i>m</i>
(including program counter constants) using the statement
<b>from</b> <i>m</i> <b>import</b> *.
This, however, excludes constants whose names start with the character
<code>_</code>: those are considered <i>private</i> to the module.
</div>

<div id='sec-258'>
<h3 id="sec-258"><b>global</b></h3><p>The statement <b>global</b> <i>v</i>, ... tells the compiler that the given
variables are shared global variables.
</div>

<div id='sec-259'>
<h3 id="sec-259"><b>go</b></h3><p><div id='sec-260'>
<center>
<pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>fork</var>():
    <b>atomically</b>:
        <b>let</b> (<i>r</i>, <i>ctx</i>) = <b>save</b> <b>True</b>:
            <i>result</i> = <i>r</i>
            <b>if</b> <i>r</i>:
                <b>go</b> <i>ctx</i> (<b>False</b>, <b>None</b>)

<b>def</b> <var>main</var>():
    <b>if</b> <var>fork</var>():
        <b>print</b> "parent"
    <b>else</b>:
        <b>print</b> "child"

<b>spawn</b> <b>eternal</b> <var>main</var>()
</code></pre>
</center>
<h4>Figure B.1. Using <b>save</b> and <b>go</b> to implement <code>fork()</code></h4>


</div>

The statement <b>go</b> <i>c</i> <i>e</i> starts a thread with context <i>c</i> that
has executed a <b>stop</b> or <b>save</b> expression.
The <b>stop</b> or <b>save</b> expression returns value <i>e</i>.
The same context can be started multiple times, allowing threads to
<i>fork</i>.  See <a href='#sec-260'>Figure B.1</a> for an example.
</div>

<div id='sec-261'>
<h3 id="sec-261"><b>if</b> ... [<b>elif</b> ...]* [<b>else</b>]</h3><p>Harmony supports <b>if</b> statements.
In its most basic form, <b>if</b> <i>c</i>: <var>S1</var>; <var>S2</var>; ... evaluates <i>c</i>
and executes statements <var>S1</var>, <var>S2</var>, ... if and only if boolean expression
<i>c</i> evaluated to true.
Harmony checks that <i>c</i> is either <b>False</b> or <b>True</b>---if neither
is the case, Harmony reports an error.
The statement <b>if</b> <i>c</i>: <var>S1</var>, <var>S2</var>, ... <b>else</b>: <var>T1</var>; <var>T2</var>; ...
is similar, but executes statements <var>T1</var>, <var>T2</var>, ...
if and only if <i>c</i> evaluated to <b>False</b>.
You can think of <b>elif</b> <i>c</i>: as shorthand for <b>else</b>: <b>if</b> <i>c</i>:.
</div>

<div id='sec-262'>
<h3 id="sec-262"><b>import</b></h3><p>The statement <b>import</b> <i>m1</i>, <i>m2</i>, ... imports modules
<i>m1</i>, <i>m2</i>, ... in that order.
If a module is imported more than once,
its code is only included the first time.
The constants (including method constants) and shared variables declared 
in that module can subsequently be referenced by prepending &quot;<i>m</i>.&quot;.
For example, method <var>f</var>() in imported module <i>m</i> is invoked
by calling <i>m.f</i>().  If you would prefer to invoke it simply as
<var>f</var>(), then you have to import using the statement
<b>from</b> <i>m</i> <b>import</b> <var>f</var>.
</div>

<div id='sec-263'>
<h3 id="sec-263"><b>invariant</b></h3><p>The statement <b>invariant</b> <i>c</i> declares that boolean expression <i>c</i>
is an invariant.  <i>c</i> is only allowed to read shared variables and
is evaluated atomically after every state change.
If it ever evaluates to <b>False</b>, Harmony reports an error.  Harmony
also reports an error if the expression evaluates to a value other
than <b>False</b> or <b>True</b>.<p>
Invariants can be useful to specify the type of a global variable.
For example, you can write <b>invariant</b> (<b>type</b>(<i>x</i>) == "int") <b>and</b> ((<i>x</i> % 2) == 0)
to state that <i>x</i> is an even integer variable.
</div>

<div id='sec-264'>
<h3 id="sec-264"><b>let</b></h3><p>You can introduce new bound variables in a method using the
<b>let</b> statement.
The statement <b>let</b> <var>a</var> = <i>b</i>: <var>S1</var>; <var>S2</var>, ... evaluates <i>b</i>, assigns
the result to read-only variable <var>a</var>, and evaluates statements
<var>S1</var>, <var>S2</var>, ....  <b>let</b> supports pattern matching, so you can
write <b>let</b> <i>x</i>, (<i>y</i>, <i>z</i>) = <i>b</i>: <var>S1</var>; <var>S2</var>, ....  This will only work
if <i>b</i> is a tuple with two elements, the second of which also being a
tuple with two elements---if not, Harmony will report an error.<p><b>let</b> statements may be nested, such as
<b>let</b> <i>a1</i> = <i>b1</i> <b>let</b> <i>a2</i> = <i>b2</i>: <var>S1</var>; <var>S2</var>; ....
Doing so can improve readability by reducing indentation
compared to writing them as separate statements.
Compare the following two examples:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>let</b> <var>a</var> = <i>y</i>:
    <b>let</b> <i>b</i> = <i>z</i>:
        ...
</code></pre>
</center>

<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>let</b> <var>a</var> = <i>y</i>
<b>let</b> <i>b</i> = <i>z</i>:
</code></pre>
</center>
</div>

<div id='sec-265'>
<h3 id="sec-265"><b>pass</b></h3><p>The <b>pass</b> statement does nothing.
</div>

<div id='sec-266'>
<h3 id="sec-266"><b>print</b></h3><p>The statement <b>print</b> <i>e</i> evaluates <i>e</i>
and adds the result to the print log.  The print log is used to
create an &quot;external behavior DFA&quot; for the Harmony program.
</div>

<div id='sec-267'>
<h3 id="sec-267"><b>sequential</b></h3><p>In Harmony, shared variable <code>Load</code> and <code>Store</code> operations
are atomic and have <i>sequential consistency</i>.
However, Harmony does check for <i>data races</i>.  A data race occurs
when two or more threads simultaneously access the same shared variable,
with at least one of the accesses being a <code>Store</code> operation
<i>outside of an atomic block</i>.
If so, Harmony will report an error.  This error can be suppressed by
declaring the shared variable as sequential.  In particular, the statement
<b>sequential</b> <i>x</i>, <i>y</i>, ... specifies that the algorithm assumes
that the given variables have sequential consistency.<p>Note that few modern processors support sequentially consistent memory
by default, as doing so would lead to high overhead.
</div>

<div id='sec-268'>
<h3 id="sec-268"><b>spawn</b></h3><p>The statement <b>spawn</b> <i>lv</i> starts a new thread that evaluates
lvalue expression <i>lv</i>.  The most typical form is
<b>spawn</b> <var>f</var>(<var>a</var>), where <var>f</var> is some method called with argument <var>a</var>.
However, if  <span 
class="cmmi-10">c</span>
 is a thunk, one could also call <b>spawn</b> !<i>c</i>, say.<p>The default thread-local state of the thread, called <i>self</i>,
is the empty dictionary by default.  It can be specified by adding
a parameter: <b>spawn</b> <i>m</i> <var>a</var>, <i>e</i> specifies that <i>e</i> should be
the initial value of the thread-local state.<p>Harmony normally checks that all threads eventually terminate.
If a thread may never terminate, you should spawn it with
<b>spawn</b> <b>eternal</b> <i>m</i> <var>a</var> to suppress those checks.
</div>

<div id='sec-269'>
<h3 id="sec-269"><b>trap</b></h3><p>The statement <b>trap</b> <i>lv</i> specifies that the current thread
should evaluate <i>lv</i> at some future, unspecified,
time.  It models a timer interrupt or any kind of asynchronous event to
be handled by the thread.  Such interrupts can be disabled by setting
the interrupt level of the thread to <b>True</b> using the
<b>setintlevel</b> operator.
</div>

<div id='sec-270'>
<h3 id="sec-270"><b>var</b></h3><p>You can introduce new local variables in a method using the
<b>var</b> statement.
The statement <b>var</b> <var>a</var> = <i>b</i> evaluates <i>b</i> and assigns
the result to local variable <var>a</var>.
<b>var</b> supports pattern matching, so you can
write <b>var</b> <i>x</i>, (<i>y</i>, <i>z</i>) = <i>b</i>.  This will only work
if <i>b</i> is a tuple with two elements, the second of which also being a
tuple with two elements---if not, Harmony will report an error.
</div>

<div id='sec-271'>
<h3 id="sec-271"><b>when</b></h3><p>The statement <b>when</b> <i>c</i>: <var>S1</var>; <var>S2</var>; ... executes statements
<var>S1</var>, <var>S2</var>, ... after waiting until <i>c</i> evaluates to <b>True</b>.
<b>when</b> statements are most useful when combined with the
<b>atomically</b> keyword.
If <i>waiting</i> is an unused local variable,
then <b>atomically</b> <b>when</b> <i>c</i>: <var>S1</var>; <var>S2</var>; ... is equivalent to<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>var</b> <i>waiting</i> = <b>True</b>
<b>while</b> <i>waiting</i>:
    <b>atomically</b>:
        <b>if</b> <i>c</i>:
            <var>S1</var>
            <var>S2</var>
            ...
            <i>waiting</i> = <b>False</b>
</code></pre>
</center>

Multiple <b>let</b> and <b>when</b> statements can be combined.
The expressions before the colon are re-evaluated repeated until all
<b>when</b> conditions are satisfied.
</div>

<div id='sec-272'>
<h3 id="sec-272"><b>when</b> <b>exists</b> ... <b>in</b> ...</h3><p>The statement <b>when</b> <b>exists</b>} <i>x</i> <b>in</b> <i>y</i>: <var>S1</var>; <var>S2</var>; ...
requires that <i>y</i> evaluates to a set value.
The statement does the following three things:
<ul><li> it waits until <i>y</i> is non-empty;
<li> it selects one element of <i>y</i> non-deterministically (using
a <b>choose</b> expression);
<li> it executes statements <var>S1</var>, <var>S2</var>, ... with the selected element
bound to read-only variable <i>x</i>.
</ul>
<i>x</i> may be a pattern, like in <b>let</b>, <b>for</b>, and <b>def</b>
statements.
Harmony reports an error if <i>y</i> evaluates to a value that is not a set.<p><b>when</b> statements are most useful when combined with the
<b>atomically</b> keyword.
If <i>waiting</i> is an unused local variable,
then <b>atomically</b> <b>when</b> <b>exists</b> <i>x</i> <b>in</b> <i>y</i>: <var>S1</var>; <var>S2</var>; ... is equivalent to<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>var</b> <i>waiting</i> = <b>True</b>:
    <b>while</b> <i>waiting</i>:
        <b>atomically</b>:
            <b>if</b> <i>y</i> != {}:
                <b>let</b> <i>x</i> = <b>choose</b>(<i>y</i>):
                    <var>S1</var>
                    <var>S2</var>
                    ...
                <i>waiting</i> = <b>False</b>
</code></pre>
</center>

The statement is particularly useful in programming network protocols
when having to wait for one or more messages and executing a set
of actions atomically after the desired messages have arrived.
</div>

<div id='sec-273'>
<h3 id="sec-273"><b>while</b></h3><p>The statement <b>while</b> <i>c</i>: <var>S1</var>; <var>S2</var>; ... executes statements
<var>S1</var>, <var>S2</var>, ... repeatedly as long as <i>c</i> evaluates to <b>True</b>.
Harmony does not support <b>break</b> or <b>continue</b> statements.
</div>
</div>

<div id='sec-274'>
<h2>Section A.3. Harmony is not object-oriented</h2>
<p>Python is object-oriented, but Harmony is not.  For Python programmers,
this can lead to some unexpected differences.
For example, consider the following code:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>x</i> = <i>y</i> = [ 1, 2 ]
<i>x</i>[0] = 3
<b>assert</b> <i>y</i>[0] == 1
</code></pre>
</center>

In Python, lists are objects.  Thus <i>x</i> and <i>y</i> point to the same list,
and the assertion would fail if executed by Python.
In Harmony, lists are values.  So, when <i>x</i> is updated in Line 2, it does
not affect the value of <i>y</i>.  The assertion succeeds.
Harmony supports references to values (<a href='#sec-53'>Chapter 7</a>),
allowing programs to implement shared objects.<p>Because Harmony does not have objects, it also does not have object methods.
However, Harmony methods and lambdas are program counter constants.
These constants can be added to dictionaries.
For example, in <a href='#sec-54'>Figure 7.1</a>
you can add the <code>P_enter</code> and
<code>P_exit</code> methods to the <code>P_mutex</code> dictionary
like so:
<center>

<pre><code class="language-harmony" data-prismjs-copy="Copy">{ .<i>turn</i>: 0, .<i>flags</i>: [ <b>False</b>, <b>False</b> ], .<i>enter</i>: <var>P_enter</var>, .<i>exit</i>: <var>P_exit</var> }
</code></pre>
</center>
That would allow you to simulate object methods.<p>There are at least two reasons why Harmony is not object-oriented.
First,
object-orientation often adds layers of indirection that would make it
harder to model check and also to interpret the results.  Consider, for example,
a lock.  In Python, a lock is an object.  A lock variable would contain a
reference to a lock object.  In Harmony, a lock variable contains the value
of the lock itself.
Thus, the following statement means something quite different in Python and
Harmony:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>x</i> = <i>y</i> = <var>Lock</var>()
</code></pre>
</center>

In Python, this creates two variables <i>x</i> and <i>y</i> referring to the same lock.
In Harmony, the two variables will be two different locks.  If you want two
variables referring to the same lock in Harmony, you might write:<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>lock</i> = <var>Lock</var>()
<i>x</i> = <i>y</i> = ?<i>lock</i>
</code></pre>
</center>

or, using the <var>alloc</var> module,<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>
<i>x</i> = <i>y</i> = <var>malloc</var>(<var>Lock</var>())
</code></pre>
</center>

The second reason for Harmony not being object-oriented is that
many concurrency solutions in the literature are
expressed in C or some other low-level language that does not support
object-orientation, but instead use <var>malloc</var> and <var>free</var>.
</div>

<div id='sec-275'>
<h2>Section A.4. Constants, Global and Local Variables</h2>

<p>Each (non-reserved) identifier in a Harmony program refers to either
a global constant, a global shared variable, a local bound variable,
a local mutable variable, or a module.
Constants are declared using <b>const</b> statements.
Those constants are evaluated at compile-time.<p>Mutable method variables can be declared using the <b>returns</b> clause of
a <b>def</b> statement or using <b>var</b>.
Bound variables, which are immutable, can be declared in
<b>def</b> statements (i.e., arguments),
<b>let</b> statements, <b>for</b> loops, and <code>when exists</code> statements.
Each thread has a mutable variable called <b>this</b> that contains
the thread-local state.
Method variables are tightly scoped and cannot be shared
between threads.
While in theory one method can be declared within another,
they cannot share local variables either.
All other variables are global and must be initialized
before spawned threads start executing.
</div>

<div id='sec-276'>
<h2>Section A.5. Operator Precedence</h2>
<p>In Harmony, there is no syntactic difference between applying an argument to a function
or an index to a dictionary.  Both use the syntax <var>a</var> <i>b</i> <i>c</i> ....
We call this <i>application</i>, and application is left-associative.
So, <var>a</var> <i>b</i> <i>c</i> is interpreted as (<var>a</var> <i>b</i>) <i>c</i>: <i>b</i> is applied to <var>a</var>,
and then <i>c</i> is applied to the result.
For readability, it may help to write  <span 
class="cmmi-10">a</span>(<span 
class="cmmi-10">b</span>)  for function application and
 <span 
class="cmmi-10">a</span>[<span 
class="cmmi-10">b</span>]  for indexing.  In case <i>b</i> is a simple string,
you can also write 
<span 
class="cmmi-10">a.b </span> for indexing.<p>There are three levels of precedence.
Application has the highest precedence.  So, !<var>a</var> <i>b</i> is interpreted as
!(<var>a</var> <i>b</i>) and <var>a</var> <i>b</i> + <i>c</i> <i>d</i> is interpreted as (<var>a</var> <i>b</i>) + (<i>c</i> <i>d</i>).
Unary operators have the next highest precedence,
and the remaining operators have the lowest precedence.
For example,  <span 
class="cmsy-10">-</span>2 + 3  evaluates to 1, not  <span 
class="cmsy-10">-</span>5 .<p>Associative operators ( + ,  <span 
class="cmsy-10">* </span>,  <span 
class="cmsy-10">| </span>, &, ^, <b>and</b>, <b>or</b>)
are interpreted as general <i>n</i>-ary operators, and you are allowed to write
 <span 
class="cmmi-10">a </span>+ <span 
class="cmmi-10">b </span>+ <span 
class="cmmi-10">c </span>.  However, ambiguous expressions such as  <span 
class="cmmi-10">a </span><span 
class="cmsy-10">- </span><span 
class="cmmi-10">b </span><span 
class="cmsy-10">- </span><span 
class="cmmi-10">c </span> are illegal,
as is any combination of operators with an
arity larger than one, such as 
<span 
class="cmmi-10">a </span>+ <span 
class="cmmi-10">b &#x003C; c </span>.
In such cases you have to add parentheses or brackets to indicate what
the intended evaluation order is, such as  (<span 
class="cmmi-10">a </span>+ <span 
class="cmmi-10">b</span>) <span 
class="cmmi-10">&#x003C; c </span>.<p>In almost all expressions, subexpressions are evaluated left to right.
So, <var>a</var>[<i>b</i>] + <i>c</i>
first evaluates <var>a</var>, then <i>b</i> (and then applies <i>b</i> to <var>a</var>), and then <i>c</i>.  The one
exception is the expression <var>a</var> <b>if</b> <i>c</i> <b>else</b> <i>b</i>, where <i>c</i> is evaluated
first.  In that expression, only <var>a</var> or <i>b</i> is evaluated depending on the value of <i>c</i>.
In the expression <var>a</var> <b>and</b> <i>b</i> <b>and</b>  <span 
class="cmmi-10">...</span>
, evaluation is left
to right but stops once one of the subexpressions evaluates to <b>False</b>.
Similarly for <b>or</b>, where evaluation stops once one of the subexpressions
evaluates to <b>True</b>.
A sequence of comparison operations, such as  <span 
class="cmmi-10">a &#x003C; b &#x003C; c </span>, is evaluated left to right
but stops as soon as one of the comparisons fails.<p></div>

<div id='sec-277'>
<h2>Section A.6. Tuples, Lists, and Pattern Matching</h2>
<p>Harmony tuples and lists are equivalent.
They can be bracketed either by '(' and ')' or by '[' and ']', but
the brackets are often optional.  Importantly, with a singleton list, the
one element must be followed by a comma.
For example, the statement <i>x</i> = 1, assigns a singleton tuple (or list) to <i>x</i>.<p>Harmony does not support special slicing syntax like Python.
To modify lists, use the <code>subseq</code> method in the <code>list</code> module
(<a href='#sec-292'>Section B.6</a>).<p>Harmony allows pattern matching against nested tuples in various
language constructs.
<a id="index:pattern-matching:1"></a>
The following are the same in Python and Harmony:
<ul><li> <i>x</i>, = 1,: assigns 1 to <i>x</i>;
<li> <i>x</i>, <i>y</i> = 1, (2, 3): assigns 1 to <i>x</i> and (2, 3) to <i>y</i>;
<li> <i>x</i>, (<i>y</i>, <i>z</i>) = 1, (2, 3): assigns 1 to <i>x</i>, 2 to <i>y</i>, and
3 to  <span 
class="cmmi-10">z </span>;
<li> <i>x</i>, (<i>y</i>, <i>z</i>) = 1, 2: generates an runtime error because 2 cannot
be matched with (<i>y</i>, <i>z</i>);
<li> <i>x</i>[0], <i>x</i>[1] = <i>x</i>[1], <i>x</i>[0]: swaps the first two elements of list <i>x</i>.
</ul>

As in Python, pattern matching can also be used in <b>for</b> statements.
For example:
<center><b>for</b> <i>key</i>, <i>value</i> <b>in</b> [ (1, 2), (3, 4) ]:
    ...
</center>

Harmony (but not Python)
also allows pattern matching in defining and invoking methods.
For example, you can write:
<center><b>def</b> <var>f</var>[<var>a</var>, (<i>b</i>, <i>c</i>)]: ...
</center>
and then call <var>f</var>[1, (2, 3)].
Note that the more familiar: <b>def</b> <var>g</var>(<var>a</var>) defines a method <var>g</var> with
a single argument <var>a</var>.  Invoking <var>g</var>(1, 2) would assign the tuple (1, 2) to
<var>a</var>.  This is not consistent with Python syntax.  For single argument methods,
you may want to declare as follows: <b>def</b> <var>g</var>(<var>a</var>,).
Calling g(1,) assigns 1 to <var>a</var>, while calling g(1, 2) would result in a
runtime error as (1, 2) cannot be matched with (<var>a</var>,).<p>Pattern matching can also be used in <b>const</b>, <b>let</b>,
and <b>when</b> <b>exists</b> statements.<p></div>

<div id='sec-278'>
<h2>Section A.7. Dynamic Allocation</h2>
<p>



<p><div id='sec-279'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>stack</var> <b>import</b> <var>Stack</var>, <var>push</var>, <var>pop</var>

<i>teststack</i> = <var>Stack</var>()
<var>push</var>(?<i>teststack</i>, 1)
<var>push</var>(?<i>teststack</i>, 2)
<i>v</i> = <var>pop</var>(?<i>teststack</i>)
<b>assert</b> <i>v</i> == 2
<var>push</var>(?<i>teststack</i>, 3)
<i>v</i> = <var>pop</var>(?<i>teststack</i>)
<b>assert</b> <i>v</i> == 3
<i>v</i> = <var>pop</var>(?<i>teststack</i>)
<b>assert</b> <i>v</i> == 1
</code></pre>

</center>
<h4>Figure B.2. [<a href='https://harmony.cs.cornell.edu/code/stacktest.hny'>code/stacktest.hny</a>] Testing a stack implementation.</h4>


</div>

<div id='sec-280'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>Stack</var>() <b>returns</b> <var>stack</var>:
    <var>stack</var> = []

<b>def</b> <var>push</var>(<i>st</i>, <i>v</i>):
    (!<i>st</i>)[<b>len</b>(!<i>st</i>)] = <i>v</i>

<b>def</b> <var>pop</var>(<i>st</i>) <b>returns</b> <i>next</i>:
    <b>let</b> <i>n</i> = <b>len</b>(!<i>st</i>) - 1:
        <i>next</i> = (!<i>st</i>)[<i>n</i>]
        <b>del</b> (!<i>st</i>)[<i>n</i>]
</code></pre>

</center>
<h4>Figure B.3. [<a href='https://harmony.cs.cornell.edu/code/stack1.hny'>code/stack1.hny</a>] Stack implemented using a dynamically updated list.</h4>


</div>

<div id='sec-281'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>list</var>

<b>def</b> <var>Stack</var>() <b>returns</b> <var>stack</var>:
    <var>stack</var> = []

<b>def</b> <var>push</var>(<i>st</i>, <i>v</i>):
    !<i>st</i> += [<i>v</i>,]

<b>def</b> <var>pop</var>(<i>st</i>) <b>returns</b> <i>next</i>:
    <b>let</b> <i>n</i> = <b>len</b>(!<i>st</i>) - 1:
        <i>next</i> = (!<i>st</i>)[<i>n</i>]
        !<i>st</i> = <var>list.subseq</var>(!<i>st</i>, 0, <i>n</i>)
</code></pre>

</center>
<h4>Figure B.4. [<a href='https://harmony.cs.cornell.edu/code/stack2.hny'>code/stack2.hny</a>] Stack implemented using static lists.</h4>


</div>

<div id='sec-282'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>def</b> <var>Stack</var>() <b>returns</b> <var>stack</var>:
    <var>stack</var> = ()

<b>def</b> <var>push</var>(<i>st</i>, <i>v</i>):
    (!<i>st</i>) = (<i>v</i>, !<i>st</i>)

<b>def</b> <var>pop</var>(<i>st</i>) <b>returns</b> <i>next</i>:
    <b>let</b> (<i>top</i>, <i>rest</i>) = !<i>st</i>:
        <i>next</i> = <i>top</i>
        !<i>st</i> = <i>rest</i>
</code></pre>

</center>
<h4>Figure B.5. [<a href='https://harmony.cs.cornell.edu/code/stack3.hny'>code/stack3.hny</a>] Stack implemented using a recursive tuple data structure.</h4>


</div>

<div id='sec-283'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>, <var>free</var>

<b>def</b> <var>Stack</var>() <b>returns</b> <var>stack</var>:
    <var>stack</var> = <b>None</b>

<b>def</b> <var>push</var>(<i>st</i>, <i>v</i>):
    !<i>st</i> = <var>malloc</var>({ .<i>value</i>: <i>v</i>, .<i>rest</i>: !<i>st</i> })

<b>def</b> <var>pop</var>(<i>st</i>) <b>returns</b> <i>next</i>:
    <b>let</b> <i>node</i> = !<i>st</i>:
        <i>next</i> = <i>node</i>-&gt;<i>value</i>
        !<i>st</i> = <i>node</i>-&gt;<i>rest</i>
        <var>free</var>(<i>node</i>)
</code></pre>

</center>
<h4>Figure B.6. [<a href='https://harmony.cs.cornell.edu/code/stack4.hny'>code/stack4.hny</a>] Stack implemented using a linked list.</h4>


</div>

Harmony supports various options for dynamic allocation.
By way of example, consider a stack.
<a href='#sec-279'>Figure B.2</a> presents a test program for a stack.
We present four different stack implementations to illustrate
options for dynamic allocation:
<ol><li> <a href='#sec-280'>Figure B.3</a> uses a single list to represent the
stack.  It is updated to perform <var>push</var> and <var>pop</var> operations;
<li> <a href='#sec-281'>Figure B.4</a> also uses a list but, instead of updating
the list, it replaces the list with a new one for each operation;
<li> <a href='#sec-282'>Figure B.5</a> represents a stack as a recursively nested tuple
 (<span 
class="cmmi-10">v,f</span>) , where <i>v</i> is the element on top of the stack and <i>r</i> is a stack
that is the remainder;
<li> <a href='#sec-283'>Figure B.6</a> implements a stack as a linked list with nodes
allocated using the <var>alloc</var> module.
</ol>

While the last option is the most versatile (it allows cyclic
data structures), Harmony does not support garbage collection
for memory allocated this way and so allocated memory that is no
longer in use must be explicitly released using <var>free</var>.
</div>

<div id='sec-284'>
<h2>Section A.8. Comments</h2>
<p>Harmony supports the same commenting conventions as Python.
In particular, anything after a <i>#</i> character on a line is
ignored.
You can also enclose comments on separate lines within triple
quotes.
In addition, Harmony supports nested multi-line comments
of the form <code>(* comment *)</code>.
</div>

<div id='sec-285'>
<h2>Section A.9. Type Checking</h2>
<p>Harmony is dynamically typed.  You can add type annotations to your
program in the form of assertions and invariants.  For example:<p>

<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>invariant</b> (<b>type</b>(<i>x</i>) == "int") <b>and</b> ((<i>x</i> % 2) == 0)
<i>x</i> = <b>choose</b> { 0, 2, 4, 6 }

<b>def</b> <var>double</var>(<i>n</i>) <b>returns</b> <i>result</i>:
    <b>assert</b> <b>type</b>(<i>n</i>) == "int"
    <i>result</i> = <i>n</i> * 2
    <b>assert</b> <b>type</b>(<i>result</i>) == "int"

<b>def</b> <var>main</var>():
    <i>x</i> = <var>double</var>(<i>x</i>)

<b>spawn</b> <var>main</var>()
</code></pre>
</center>

The invariant in Line 1 states that <i>x</i> is an even integer.
The assertion in Line 5 states that the argument to function
<var>double</var> is an integer.
The assertion in Line 7 states that the return value of the
function is also an integer.
Harmony checks these types as it evaluates the program.
</div>
</div>

<div id='sec-286'>
<h1>Appendix B. Modules</h1>

<p>Harmony modules provide convenient access to various data structures,
algorithms, and synchronization paradigms.
They are all implemented in the Harmony language itself (so
you can look at their code) although some methods have also been implemented
directly into the underlying model checker for more efficient model checking.<p>Currently there are the following modules:<p>
<table border='0'>
 <tr>
<td>
<var>action</var></td>
 <td>
<a href='#sec-287'>Section B.1</a></td>
 <td>
support for action-based specifications</td>


</tr>
<tr>
<td>
<var>alloc</var></td>
 <td>
<a href='#sec-288'>Section B.2</a></td>
 <td>
dynamic memory allocation</td>


</tr>
<tr>
<td>
<var>bag</var></td>
 <td>
<a href='#sec-289'>Section B.3</a></td>
 <td>
multi-sets</td>


</tr>
<tr>
<td>
<var>fork</var></td>
 <td>
<a href='#sec-290'>Section B.4</a></td>
 <td>
fork/join interface to threads</td>


</tr>
<tr>
<td>
<var>hoare</var></td>
 <td>
<a href='#sec-291'>Section B.5</a></td>
 <td>
Hoare module interface</td>


</tr>
<tr>
<td>
<var>list</var></td>
 <td>
<a href='#sec-292'>Section B.6</a></td>
 <td>
common operations on lists</td>


</tr>
<tr>
<td>
<var>set</var></td>
 <td>
<a href='#sec-293'>Section B.7</a></td>
 <td>
common operations on sets</td>


</tr>
<tr>
<td>
<var>synch</var></td>
 <td>
<a href='#sec-294'>Section B.8</a></td>
 <td>
synchronization</td>

</tr>
</table>

<div id='sec-287'>

<h2>Section B.1. The <var>action</var> module</h2>

<p>The <var>action</var> module supports <i>action-based</i> specification.
Such a specification consists of a explicit global state and rules
for how to make state transitions.  <a href='#sec-212'>Chapter 29</a> provides
an example.  The module has only one method:<p><table border='0'>
 <tr>
<td>
<var>explore</var>(<i>x</i>)</td>
 <td>
explore the state space</td>

</table>

Here <i>x</i> is a set of lambdas, each of which can return a set of
<i>thunks</i>, each representing a possible action (state change).
The union of the results of the lambdas should generate all possible
actions.  A thunk represents a method and its arguments that
updates the state accordingly.
</div>

<div id='sec-288'>
<h2>Section B.2. The <var>alloc</var> module</h2>

<p>The <var>alloc</var> module
<a id="index:alloc-module:1"></a>
supports thread-safe (but not interrupt-safe) dynamic allocation of
shared memory locations.  There are just two methods:<p><table border='0'>
 <tr>
<td>
<var>malloc</var>(<i>v</i>)</td>
 <td>
return a pointer to a memory location initialized to <i>v</i></td>


</tr>
<tr>
<td>
<var>free</var>(<i>p</i>)</td>
 <td>
free an allocated memory location <i>p</i></td>

</tr>
</table>

The usage is similar to <var>malloc</var> and <var>free</var> in C.
<var>malloc</var>() is specified to return <b>None</b> when running out of
memory, although this is an impossible outcome in the current
implementation of the module.
</div>

<div id='sec-289'>
<h2>Section B.3. The <var>bag</var> module</h2>

<p>The <code>bag</code> module
<a id="index:bag-module:1"></a>
has various useful methods that operate on bags or
multisets:<p>

<p><table border='0'>
 <tr>
<td>
<var>empty</var>()</td>
 <td>
returns an empty bag</td>


</tr>
<tr>
<td>
<var>fromSet</var>(<i>s</i>)</td>
 <td>
create a bag from set <i>s</i></td>


</tr>
<tr>
<td>
<var>fromList</var>(<i>t</i>)</td>
 <td>
convert list <i>t</i> into a bag</td>


</tr>
<tr>
<td>
<var>multiplicity</var>(<i>b</i>, <i>e</i>)</td>
 <td>
count how many times <i>e</i> occurs in bag <i>b</i></td>


</tr>
<tr>
<td>
<var>bchoose</var>(<i>b</i>)</td>
 <td>
like <code>choose(s)</code>, but applied to a bag</td>


</tr>
<tr>
<td>
<var>add</var>(<i>b</i>, <i>e</i>)</td>
 <td>
add one copy of <i>e</i> to bag <i>b</i></td>


</tr>
<tr>
<td>
<var>remove</var>(<i>b</i>, <i>e</i>)</td>
 <td>
remove one copy of <i>e</i> from bag <i>b</i></td>


</tr>
<tr>
<td>
<var>combinations</var>(<i>b</i>, <i>k</i>)</td>
 <td>
return set of all <i>subbags</i> of size <i>k</i></td>

</tr>
</table>
</div>

<div id='sec-290'>
<h2>Section B.4. The <var>fork</var> module</h2>

<p><a id="index:fork-module:1"></a>
The <code>fork</code> module implements the fork/join interface to threads.<p>



<p><table border='0'>
 <tr>
<td>
<var>fork</var>(<i>thunk</i>)</td>
 <td>
spawn <i>thunk</i> and return a thread handle</td>


</tr>
<tr>
<td>
<var>join</var>(<i>handle</i>)</td>
 <td>
wait for the thread to finish and return its result</td>

</tr>
</table>

For example, the following code doubles each element of <i>data</i> in parallel
and then sums the result when done.<p>


<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>fork</var> <b>import</b> *
<b>from</b> <var>list</var> <b>import</b> *

<i>data</i> = { 1, 2, 4 }

<b>def</b> <var>main</var>():
    <b>let</b> <var>double</var> = <b>lambda</b> <i>x</i>: 2*<i>x</i> <b>end</b>
    <b>let</b> <var>map</var> = { <var>fork</var>(?<var>double</var>(<i>k</i>)) <b>for</b> <i>k</i> <b>in</b> <i>data</i> }:
        <b>print</b> <var>sum</var>(<var>join</var>(<i>t</i>) <b>for</b> <i>t</i> <b>in</b> <var>map</var>)

<b>spawn</b> <var>main</var>()
</code></pre>
</center>
</div>

<div id='sec-291'>
<h2>Section B.5. The <var>hoare</var> module</h2>

<p><a id="index:hoare-module:1"></a>
The <code>hoare</code> module implements support for Hoare-style monitors
and condition variables.<p>
<p><table border='0'>
 <tr>
<td>
<var>Monitor</var>()</td>
 <td>
return a monitor mutex</td>


</tr>
<tr>
<td>
<var>enter</var>(<i>m</i>)</td>
 <td>
enter a monitor.  <i>m</i> points to a monitor mutex</td>


</tr>
<tr>
<td>
<var>exit</var>(<i>m</i>)</td>
 <td>
exit a monitor</td>


</tr>
<tr>
<td>
<var>Condition</var>()</td>
 <td>
return a condition variable</td>


</tr>
<tr>
<td>
<var>wait</var>(<i>c</i>, <i>m</i>)</td>
 <td>
wait on condition variable pointed to by <i>c</i> in monitor pointed to by <i>m</i></td>


</tr>
<tr>
<td>
<var>signal</var>(<i>c</i>, <i>m</i>)</td>
 <td>
signal a condition variable</td>

</tr>
</table>
</div>

<div id='sec-292'>
<h2>Section B.6. The <var>list</var> module</h2>

<p>












<p><a id="index:list-module:1"></a>
The <code>list</code> module has various useful methods that operate on lists
or tuples:<p><table border='0'>
 <tr>
<td>
<var>subseq</var>(<i>t</i>, <i>b</i>, <i>f</i>)</td>
 <td>
return a <i>slice</i> of list <i>t</i> starting
at index <i>b</i> and ending just before <i>f</i></td>


</tr>
<tr>
<td>
<var>append</var>(<i>t</i>, <i>e</i>)</td>
 <td>
returns <i>t</i> + [<i>e</i>,]</td>


</tr>
<tr>
<td>
<var>head</var>(<i>t</i>)</td>
 <td>
return the first element of list <i>t</i></td>


</tr>
<tr>
<td>
<var>tail</var>(<i>t</i>)</td>
 <td>
return all but the first element of list <i>t</i></td>


</tr>
<tr>
<td>
<var>index</var>(<i>t</i>, <i>e</i>)</td>
 <td>
return the index of element <i>e</i> in list <i>t</i></td>


</tr>
<tr>
<td>
<var>startswith</var>(<i>t</i>, <i>s</i>)</td>
 <td>
returns whether <i>s</i> is a prefix of <i>t</i></td>


</tr>
<tr>
<td>
<var>filter</var>(<i>f</i>, <i>t</i>)</td>
 <td>
returns a list of elements of <i>t</i> satisfying function <i>f</i></td>


</tr>
<tr>
<td>
<var>map</var>(<i>f</i>, <i>t</i>)</td>
 <td>
returns a list of elements of <i>t</i> mapped by function <i>f</i></td>


</tr>
<tr>
<td>
<var>permuted</var>(<i>t</i>)</td>
 <td>
returns a permutation of set <i>t</i></td>


</tr>
<tr>
<td>
<var>reversed</var>(<i>t</i>)</td>
 <td>
returns the elements of list <i>t</i> in reverse order</td>


</tr>
<tr>
<td>
<var>sorted</var>(<i>t</i>)</td>
 <td>
returns a sorted list from the elements or set or list <i>t</i></td>


</tr>
<tr>
<td>
<var>set</var>(<i>t</i>)</td>
 <td>
convert a list into a set</td>


</tr>
<tr>
<td>
<var>list</var>(<i>t</i>)</td>
 <td>
convert a set into a list</td>


</tr>
<tr>
<td>
<var>values</var>(<i>t</i>)</td>
 <td>
convert values of a dict into a list sorted by key</td>


</tr>
<tr>
<td>
<var>items</var>(<i>t</i>)</td>
 <td>
convert dict into (key, value) list sorted by key</td>


</tr>
<tr>
<td>
<var>enumerate</var>(<i>t</i>)</td>
 <td>
like Python enumerate</td>


</tr>
<tr>
<td>
<var>sum</var>(<i>t</i>)</td>
 <td>
returns the sum of all elements in <i>t</i></td>


</tr>
<tr>
<td>
<var>qsort</var>(<i>t</i>)</td>
 <td>
returns a copy of <i>t</i> sorted using quicksort</td>


</tr>
<tr>
<td>
<var>foldl</var>(<i>t</i>, <i>f</i>, <i>z</i>)</td>
 <td>
left fold with <i>f</i> a binary method and <i>z</i> the initial value</td>


</tr>
<tr>
<td>
<var>foldr</var>(<i>t</i>, <i>f</i>, <i>z</i>)</td>
 <td>
right fold with <i>f</i> a binary method and <i>z</i> the initial value</td>


</tr>
<tr>
<td>
<var>reduce</var>(<i>f</i>, <i>t</i>, <i>z</i>)</td>
 <td>
same as <var>foldl</var>(<i>t</i>, <i>f</i>, <i>z</i>)</td>

</tr>
</table>
</div>

<div id='sec-293'>
<h2>Section B.7. The <var>set</var> module</h2>

<p>The <code>set</code> module
<a id="index:set-module:1"></a>
implements the following methods:<p>










<p><table border='0'>
 <tr>
<td>
<var>issubseteq</var>(<i>s</i>, <i>t</i>)</td>
 <td>
returns whether <i>s</i> is a subset of <i>t</i></td>


</tr>
<tr>
<td>
<var>issubsetstrict</var>(<i>s</i>, <i>t</i>)</td>
 <td>
returns whether <i>s</i> is a strict subset of <i>t</i></td>


</tr>
<tr>
<td>
<var>issubset</var>(<i>s</i>, <i>t</i>)</td>
 <td>
same as <var>issubseteq</var>(<i>s</i>, <i>t</i>)</td>


</tr>
<tr>
<td>
<var>issuperseteq</var>(<i>s</i>, <i>t</i>)</td>
 <td>
returns whether <i>s</i> is a superset of <i>t</i></td>


</tr>
<tr>
<td>
<var>issupersetstrict</var>(<i>s</i>, <i>t</i>)</td>
 <td>
returns whether <i>s</i> is a strict superset of <i>t</i></td>


</tr>
<tr>
<td>
<var>issuperset</var>(<i>s</i>, <i>t</i>)</td>
 <td>
same as <var>issuperseteq</var>(<i>s</i>, <i>t</i>)</td>


</tr>
<tr>
<td>
<var>add</var>(<i>s</i>, <i>e</i>)</td>
 <td>
returns  <span 
class="cmmi-10">s</span><span 
class="cmsy-10">&#x222A;{</span><span 
class="cmmi-10">e</span><span 
class="cmsy-10">} </span></td>


</tr>
<tr>
<td>
<var>remove</var>(<i>s</i>, <i>e</i>)</td>
 <td>
returns  <span 
class="cmmi-10">s</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">\</span><span 
class="cmmi-10">&#x00A0;</span><span 
class="cmsy-10">{</span><span 
class="cmmi-10">e</span><span 
class="cmsy-10">}</span>
</td>


</tr>
<tr>
<td>
<var>subsets</var>(<i>s</i>)</td>
 <td>
returns the set of subsets of <i>s</i></td>


</tr>
<tr>
<td>
<var>union</var>(<i>s</i>)</td>
 <td>
returns the union of the elements of <i>s</i></td>


</tr>
<tr>
<td>
<var>filter</var>(<i>f</i>, <i>s</i>)</td>
 <td>
returns a set of elements of <i>s</i> satisfying function <i>f</i></td>


</tr>
<tr>
<td>
<var>map</var>(<i>f</i>, <i>s</i>)</td>
 <td>
returns a set of elements of <i>s</i> mapped by function <i>f</i></td>


</tr>
<tr>
<td>
<var>cartesian</var>(<i>d</i>)</td>
 <td>
<i>d</i> is a list of sets.  Returns the Cartesian product.</td>


</tr>
<tr>
<td>
<var>combinations</var>(<i>s</i>, <i>k</i>)</td>
 <td>
returns set of all subsets of size <i>k</i></td>


</tr>
<tr>
<td>
<var>reduce</var>(<i>f</i>, <i>t</i>, <i>z</i>)</td>
 <td>
same as Python's <code>functools</code> <var>reduce</var>()</td>

</tr>
</table>

For Python programmers: note that <i>s</i> &lt;= <i>t</i> does not check if <i>s</i> is a subset of
<i>t</i> when <i>s</i> and <i>t</i> are sets, as &quot;&lt;=&quot; implements a total order on all Harmony values including sets (and the subset relation is not a total order).
</div>

<div id='sec-294'>
<h2>Section B.8. The <var>synch</var> module</h2>

<p><a id="index:synch-module:2"></a>
The <var>synch</var> module provides the following methods:<p><table border='0'>
 <tr>
<td>
<var>atomic_load</var>(<i>p</i>)</td>
 <td>
atomically evaluate !<i>p</i></td>


</tr>
<tr>
<td>
<var>atomic_store</var>(<i>p</i>, <i>v</i>)</td>
 <td>
atomically assign !<i>p</i> = <i>v</i></td>


</tr>
<tr>
<td>
<var>tas</var>(<i>lk</i>)</td>
 <td>
test-and-set on !<i>lk</i></td>


</tr>
<tr>
<td>
<var>cas</var>(<i>ptr</i>, <i>old</i>, <var>new</var>)</td>
 <td>
compare-and-swap on !<i>ptr</i></td>


</tr>
<tr>
<td>
<var>BinSema</var>(<i>v</i>)</td>
 <td>
return a binary semaphore initialized to <i>v</i></td>


</tr>
<tr>
<td>
<var>Lock</var>()</td>
 <td>
return a binary semaphore initialized to <b>False</b></td>


</tr>
<tr>
<td>
<var>acquire</var>(<i>bs</i>)</td>
 <td>
acquire binary semaphore !<i>bs</i></td>


</tr>
<tr>
<td>
<var>release</var>(<i>bs</i>)</td>
 <td>
release binary semaphore !<i>bs</i></td>


</tr>
<tr>
<td>
<var>Condition</var>()</td>
 <td>
return a condition variable</td>


</tr>
<tr>
<td>
<var>wait</var>(<i>c</i>, <i>lk</i>)</td>
 <td>
wait on condition variable !<i>c</i> and lock <i>lk</i></td>


</tr>
<tr>
<td>
<var>notify</var>(<i>c</i>)</td>
 <td>
notify a thread waiting on condition variable !<i>c</i></td>


</tr>
<tr>
<td>
<var>notifyAll</var>(<i>c</i>)</td>
 <td>
notify all threads waiting on condition variable !<i>c</i></td>


</tr>
<tr>
<td>
<var>Semaphore</var>(<i>cnt</i>)</td>
 <td>
return a counting semaphore initialized to <i>cnt</i></td>


</tr>
<tr>
<td>
<var>P</var>(<i>sema</i>)</td>
 <td>
procure !<i>sema</i></td>


</tr>
<tr>
<td>
<var>V</var>(<i>sema</i>)</td>
 <td>
vacate !<i>sema</i></td>


</tr>
<tr>
<td>
<var>Queue</var>()</td>
 <td>
return a synchronized queue object</td>


</tr>
<tr>
<td>
<var>get</var>(<i>q</i>)</td>
 <td>
return next element of <i>q</i>, blocking if empty</td>


</tr>
<tr>
<td>
<var>put</var>(<i>q</i>, <i>item</i>)</td>
 <td>
add <i>item</i> to <var>a</var></td>

</tr>
</table>
</div>

</div>

<div id='sec-295'>
<h1>Appendix C. The Harmony Virtual Machine</h1>
<p>The Harmony Virtual Machine (HVM, <a href='#sec-28'>Chapter 4</a>)
has the following state:<p><table border='0'>
 <tr>
<td>
code</td>
 <td>
a list of HVM machine instructions</td>


</tr>
<tr>
<td>
variables</td>
 <td>
a dictionary mapping strings to values</td>


</tr>
<tr>
<td>
ctxbag</td>
 <td>
a bag of runnable contexts</td>


</tr>
<tr>
<td>
stopbag</td>
 <td>
a bag of stopped contexts</td>


</tr>
<tr>
<td>
choosing</td>
 <td>
if not <b>None</b>, indicates a context that is choosing</td>

</tr>
</table>

There is initially a single context with name
<var>__init__</var>() and program counter 0.  It starts executing
in atomic mode until it finishes executing the last
<code>Return</code> instruction.
Other threads, created through <b>spawn</b> statements, do not
start executing until then.<p>A <i>step</i> is the execution of a single HVM machine instruction
by a context.
Each step generates a new state.
When there are multiple contexts, the HVM can interleave them.
However, trying to interleave every step would be needlessly expensive,
as many steps involve changes to a context that are invisible to
other contexts.<p>A <i>stride</i>
<a id="index:stride:1"></a>
can involve multiple steps.  The following
instructions start a new stride: <code>Load</code>, <code>Store</code>,
<code>AtomicInc</code>, and <code>Continue</code>.  The HVM
interleaves stides, not steps.  Like steps, each
stride involves a single context.  Unlike a step, a stride
can leave the state unchanged (because its steps lead back
to where the stride started).<p>Executing a Harmony program results in a graph where the nodes are Harmony
states and the edges are strides.
When a state is <code>choosing</code>, the edges from that state are
by a single context, one for each choice.  If not, the edges from
the state are one per context.<p>Consecutive strides by the same thread are called a <i>turn</i>.
Each state maintains the shortest path to it from the initial state in terms
of turns.
The diameter of the graph is the length of the longest path found in
terms of turns.<p>If some states have a problem, the state with the shortest path is reported.
Problematic states include states that experienced exceptions.
If there are no exceptions, Harmony computes the strongly connected components (SCCs)
of the graph (the number of such components are printed as part of the output).
The sink SCCs should each consist of a terminal state without any threads.
If not, again the state with the shortest path is reported.<p>If there are no problematic states, Harmony reports &quot;no issues found&quot; and outputs
in the HTML file the state with the longest path.<p><div id='sec-296'>
<h2>Section C.1. Machine Instructions</h2>

<p><p><table border='0'>
<tr>
<td>
Apply <i>m</i></td>
 <td>
call method <i>m</i></td>


</tr>
<tr>
<td>
Assert, Assert2</td>
 <td>
pop <i>b</i> and check that it is <b>True</b>.  Assert2 also pops value to print</td>


</tr>
<tr>
<td>
AtomicInc/Dec</td>
 <td>
increment/decrement the atomic counter of this context</td>


</tr>
<tr>
<td>
Continue</td>
 <td>
no-op (but causes a context switch)</td>


</tr>
<tr>
<td>
Choose</td>
 <td>
choose an element from the set on top of the stack</td>


</tr>
<tr>
<td>
Cut</td>
 <td>
retrieve an element from a iterable type</td>


</tr>
<tr>
<td>
Del [<i>v</i>]</td>
 <td>
delete shared variable <i>v</i></td>


</tr>
<tr>
<td>
DelVar [<i>v</i>]</td>
 <td>
delete thread variable <i>v</i></td>


</tr>
<tr>
<td>
Dup</td>
 <td>
duplicate the top element of the stack</td>


</tr>
<tr>
<td>
Finally <i>pc</i></td>
 <td>
<i>pc</i> is the pc of a lambda that returns a boolean</td>


</tr>
<tr>
<td>
Frame <i>m</i> <var>a</var></td>
 <td>
start method <i>m</i> with arguments <var>a</var>,
initializing variables</td>


</tr>
<tr>
<td>
Go</td>
 <td>
pop context and value, push value on context's stack, and add to context bag</td>


</tr>
<tr>
<td>
Invariant <i>pc</i></td>
 <td>
<i>pc</i> is the pc of a lambda that takes arguments <i>pre</i>, <i>post</i> and returns a boolean</td>


</tr>
<tr>
<td>
Jump <i>p</i></td>
 <td>
set program counter to <i>p</i></td>


</tr>
<tr>
<td>
JumpCond <i>e</i> <i>p</i></td>
 <td>
pop expression and, if equal to <i>e</i>, set program counter to <i>p</i></td>


</tr>
<tr>
<td>
Load [<i>v</i>]</td>
 <td>
evaluate the address on the stack (or load shared variable <i>v</i>)</td>


</tr>
<tr>
<td>
LoadVar <i>v</i></td>
 <td>
push the value of a thread variable onto the stack</td>


</tr>
<tr>
<td>
Move <i>i</i></td>
 <td>
move stack element at offset <i>i</i> to top of the stack</td>


</tr>
<tr>
<td>
<i>n</i>-ary <i>op</i></td>
 <td>
apply <i>n</i>-ary operator <i>op</i> to the top <i>n</i> elements on the stack</td>


</tr>
<tr>
<td>
Pop</td>
 <td>
pop a value of the stack and discard it</td>


</tr>
<tr>
<td>
Print</td>
 <td>
pop a value and add to the print history</td>


</tr>
<tr>
<td>
Push <i>c</i></td>
 <td>
push constant <i>c</i> onto the stack</td>


</tr>
<tr>
<td>
ReadonlyInc/Dec</td>
 <td>
increment/decrement the read-only counter of this context</td>


</tr>
<tr>
<td>
Return [<i>v</i> [, <i>d</i>]]</td>
 <td>
pop return address, push <i>v</i> (or default value <i>d</i>), and restore pc</td>


</tr>
<tr>
<td>
Sequential</td>
 <td>
pop an address of a variable that has sequential consistency</td>


</tr>
<tr>
<td>
SetIntLevel</td>
 <td>
pop <i>e</i>, set interrupt level to <i>e</i>, and push old interrupt level</td>


</tr>
<tr>
<td>
Spawn [eternal]</td>
 <td>
pop initial thread-local state, argument, and method and spawn a new context</td>


</tr>
<tr>
<td>
Split</td>
 <td>
pop tuple and push its elements</td>


</tr>
<tr>
<td>
Stop [<i>v</i>]</td>
 <td>
save context into shared variable <i>v</i> and remove from context bag</td>


</tr>
<tr>
<td>
Store [<i>v</i>]</td>
 <td>
pop a value from the stack and store it in a shared variable</td>


</tr>
<tr>
<td>
StoreVar [<i>v</i>]</td>
 <td>
pop a value from the stack and store it in a thread variable</td>


</tr>
<tr>
<td>
Trap</td>
 <td>
pop interrupt argument and method</td>

</tr>
</table>
<p>
Clarifications:
<ul><li> Even though Harmony code does not allow taking addresses of thread variables, both
shared and thread variables can have addresses.
<li> The <code>Load</code>, <code>Del</code>, <code>DelVar</code>,
and <code>Stop</code> instructions have an optional
variable name: if omitted the top of the stack must contain the address of
the variable.
<li> The <code>Store</code> instruction has an optional variable name.
The <code>StoreVar</code> instruction can even have a nested tuple of variable names
such as (<var>a</var>, (<i>b</i>, <i>c</i>)).
In both cases the value to be assigned is on the top
of the stack.  If the name is omitted, the address is underneath that
value on the stack.
<li> The <code>Frame</code> instruction pushes the value of the thread
register (<i>i.e.</i>, the values of the thread variables) onto the
stack.
The <code>Return</code> instruction restores the thread register by popping
its value of the stack.
<li> All method calls have exactly one argument, although it sometimes
appears otherwise:
<ul><li> <i>m</i>() invokes method <i>m</i> with the empty dictionary () as argument;
<li> <i>m</i>(<var>a</var>) invokes method <i>m</i> with argument <var>a</var>;
<li> <i>m</i>(<var>a</var>, <i>b</i>, <i>c</i>) invokes method <i>m</i> with tuple (<var>a</var>, <i>b</i>, <i>c</i>) as argument.
</ul>
The <code>Frame</code> instruction unpacks the argument to the method and places them into thread variables by the given names.
<li> The <code>Apply</code> instruction is unnecessary as it can be implemented using <code>2-ary Closure</code> and <code>Load</code>.  However, method calls are frequent enough
to warrant a faster mechanism, reducing model checking time.
<li> The <code>Return</code> instruction has an optional result variable and default
value.  If neither is specified, the result value is on top of the stack.
Otherwise it tries to read the local variable.  If the variable does not exist,
the default value is used or an error is thrown.
<li> Every <code>Stop</code> instruction must immediately be followed by a 
<code>Continue</code> instruction.
<li> There are two versions of <code>AtomicInc</code>: <i>lazy</i> or <i>eager</i>.
When eager, an atomic section immediately causes a <i>switch point</i>
(switch between threads).
When lazy, the state change does not happen until the first <code>Load</code>,
<code>Store</code>, or <code>Print</code> instruction.  If there are no such
instructions, the atomic section may not even cause a switch point.
</ul>

The <i>n</i>-<code>Ary</code> instruction can have many different operators as
argument.
<a href='#sec-236'>Section A.1</a> describes many of these operators, but some are used
internally only.  The current set of such operators are as follows:<p><table border='0'>
<tr>
<td>
AddArg</td>
 <td>
pop an argument and an address and push an address with the argument added</td>


</tr>
<tr>
<td>
Closure</td>
 <td>
pop an argument and a function and push an address with the single argument</td>


</tr>
<tr>
<td>
DictAdd</td>
 <td>
pop a value, a key, and a dictionary, and push an updated dictionary</td>


</tr>
<tr>
<td>
ListAdd</td>
 <td>
pop a value and a list, and push a new list with the given value added to the end</td>


</tr>
<tr>
<td>
SetAdd</td>
 <td>
pop a value and a set, and push a new set with the given value added</td>


</tr>
</table>
</div>

<div id='sec-297'>
<h2>Section C.2. Addresses and Method Calls</h2>

<p>Syntactically, Harmony does not make a distinction between methods calls
and indexing in Harmony dictionaries, lists, and strings.  This is because
Harmony makes all four look like functions that map a value to another value.
Beuses dynamic types, an expression like <var>a</var> <i>b</i> could mean that variable
<var>a</var> contains a program counter value and a method call must be made with
<i>b</i> as argument, or index <i>b</i> must be looked up in the <var>a</var> value.
Things can get more complicated for an expression like <var>a</var> <i>b</i> <i>c</i>, which
means ((<var>a</var> <i>b</i>) <i>c</i>): <var>a</var> <i>b</i> could return a program counter value or an
indexable Harmony value.<p>To deal with this, Harmony has a fairly unique address type.  An address
consists of a function and a list of arguments, which we will denote here
as  <span 
class="cmsy-10">&#x27E8;</span><span 
class="cmmi-10">f,</span><span 
class="cmmi-10">&#x00A0;</span>[<span 
class="cmmi-10">a</span><sub><span 
class="cmr-7">0</span></sub><span 
class="cmmi-10">,a</span><sub><span 
class="cmr-7">1</span></sub><span 
class="cmmi-10">,...</span>]<span 
class="cmsy-10">&#x27E9; </span>.  If <var>a</var> is a shared variable,
then the address of <var>a</var> <i>b</i> <i>c</i> is  <span 
class="cmsy-10">&#x27E8;</span>$<span 
class="cmmi-10">,</span><span 
class="cmmi-10">&#x00A0;</span>[ &quot;<var>a</var>&quot; <span 
class="cmmi-10">,</span><span 
class="cmmi-10">&#x00A0;b,</span><span 
class="cmmi-10">&#x00A0;c</span><span 
class="cmmi-10">&#x00A0;</span>]<span 
class="cmsy-10">&#x27E9; </span>, where
$ is the function that maps the names of shared variables to their values.
In particular, $(&quot;<var>a</var>&quot;) is the value of variable <var>a</var>.  A function can
also be a program counter value or an indexable Harmony value.  So, if <var>a</var> is
instead a method (i.e., a program counter constant), then the address would
by  <span 
class="cmsy-10">&#x27E8;</span><span 
class="cmmi-10">a,</span>[<span 
class="cmmi-10">b,c</span>]<span 
class="cmsy-10">&#x27E9; </span>.  In the Harmony Virtual Machine, the $ function
is represented as the program counter value 
<span 
class="cmsy-10">-</span>1 .<p>To evaluate the Harmony expression <var>a</var> <i>b</i> <i>c</i>, Harmony first generates its address
(evaluating the expression left to right).  If <var>a</var> is a variable name, then
the function in the address depends on whether it is a shared variable or a thread
variable.  After the address is computed and pushed onto the stack, the
<code>Load</code> instruction evaluates the address, possibly in multiple steps
in an iterative manner.<p>A basic step of evaluating  <span 
class="cmsy-10">&#x27E8;</span><span 
class="cmti-10">function</span><span 
class="cmmi-10">,</span><span 
class="cmti-10">arguments</span><span 
class="cmsy-10">&#x27E9; </span>
proceeds as follows:<p><ol><li> If <i>arguments</i> is empty, replace the address by <i>function</i>
      and proceed to the next instruction.
<li> If <i>function</i> is an indexable Harmony value (list, string, or dictionary),
<i>arg</i> is the first argument, and <i>remainder</i> are the remaining arguments,
then replace the address by 
<span 
class="cmsy-10">&#x27E8;</span><span 
class="cmti-10">function</span>[<span 
class="cmti-10">arg</span>]<span 
class="cmmi-10">,</span><span 
class="cmti-10">remainder</span><span 
class="cmsy-10">&#x27E9; </span> and repeat.
<li> If <i>function</i> is $, then replace the address by
 <span 
class="cmsy-10">&#x27E8;</span>$[<span 
class="cmti-10">arg</span>]<span 
class="cmmi-10">,</span><span 
class="cmti-10">remainder</span><span 
class="cmsy-10">&#x27E9; </span> and repeat.
<li> If <i>function</i> is a program counter value, then push <i>remainder</i>,
the current program counter (still pointing to the <code>Load</code> instruction), and
<i>arg</i> onto the stack and set the program counter to <i>function</i>.
The <code>Return</code> instruction pushes
 <span 
class="cmsy-10">&#x27E8;</span><span 
class="cmmi-10">r,</span><span 
class="cmti-10">remainder</span><span 
class="cmsy-10">&#x27E9; </span>, where  <span 
class="cmmi-10">r </span> is the result of the function,
and restores the program counter so it executes the <code>Load</code> instruction again.
</ol>

The Harmony Virtual Machine can sometimes to multiple of these basic steps in one
big step.  For example, if  <var>a</var> <i>b</i> <i>c</i>  is a memory address, the <code>Load</code>
instruction will finish in a single atomic step.  Both <code>Load</code> and <code>Return</code>
are optimized in such ways.
</div>

<div id='sec-298'>
<h2>Section C.3. Contexts and Threads</h2>

<p>A context captures the state of a thread.  Each time the thread
executes an instruction, it goes from one context to another.
All instructions update the program counter (<code>Jump</code> instructions
are not allowed to jump to their own locations), and so no instruction
leaves the context the same.
There may be multiple threads
with the same state at the same time.
A context consists of the following:<p><table border='0'>
<tr>
<td>
program counter</td>
 <td>
an integer value pointing into the code</td>


</tr>
<tr>
<td>
atomic</td>
 <td>
if non-zero, the thread is in atomic mode</td>


</tr>
<tr>
<td>
readonly</td>
 <td>
if non-zero, the thread is in read-only mode</td>


</tr>
<tr>
<td>
stack</td>
 <td>
a list of Harmony values</td>


</tr>
<tr>
<td>
method variables</td>
 <td>
a dictionary mapping strings (names of method variables) to values</td>


</tr>
<tr>
<td>
thread-local variables</td>
 <td>
a dictionary mapping strings (names of thread-local variables) to values</td>


</tr>
<tr>
<td>
stopped</td>
 <td>
a boolean indicating if the context is stopped</td>


</tr>
<tr>
<td>
failure</td>
 <td>
if not None, string that describes how the thread failed</td>

</tr>
</table>

Details:
<ul><li> A thread terminates when it reaches the <code>Return</code> instruction
of the top-level method (when the stack frame is of type <var>thread</var>)
or when it hits an exception.  Exceptions include divide by zero,
reading a non-existent key in a dictionary, accessing a non-existent
variable, as well as when an assertion fails;
<li> The execution of a thread in <i>atomic mode</i> does not get interleaved
with that of other threads.
<li> The execution of a thread in <i>read-only mode</i> is not allowed
to update shared variables of spawn threads.
<li> The register of a thread always contains a dictionary, mapping
strings to arbitrary values.  The strings correspond to the variable names
in a Harmony program.
</ul>
</div>

<div id='sec-299'>
<h2>Section C.4. Formal Specification</h2>

<p>Most of the Harmony Virtual Machine is specified in TLA+.
Given a Harmony program, you can output the TLA+ specification for
the program using the following command:<p><center>$ harmony -o program.tla program.hny
</center>

For most Harmony programs, including Peterson's algorithm and the Dining
Philosophers in this book, the result is complete enough to run through
the TLC model checker.
</div>
</div>

<div id='sec-300'>
<h1>Appendix D. How Harmony Works</h1>
<p>This appendix gives a very brief overview of how Harmony works.
In a nutshell, Harmony goes through the following three phases:<p><ol><li> The Harmony <i>compiler</i> turns your Harmony program into
bytecode.  A recursive descent parser and code generator written in
Python (see <code>harmony.py</code>) turns an <code>x.hny</code> program
into <code>x.hvm</code>, a JSON file containing the corresponding
bytecode.
<li> The Harmony <i>model checker</i> evaluates the state space
that the program (now in bytecode) can generate.  The model checker
is written in C as it needs to be highly efficient (see <code>charm.c</code>).
The model checker starts from the initial state, and then, iteratively,
checks for each state that it has found what next steps are possible and
generates the next states using the Harmony virtual machine
(<a href='#sec-295'>Appendix C</a>).  If the model is finite, eventually the model
checker will generate a graph with all possible states.
If there is a problematic path in this graph (see below), then it will
report the shortest such path in the <code>x.hco</code> output file in JSON
format.
<li> The <code>x.hco</code> output file is translated twice by
<code>harmony.py</code>.  There is a so-called <i>brief output</i> that
is written to standard output.  The rest depends on whether there was
a problem with the execution or not.  If there was a problem, the more
comprehensive output is placed in the <code>x.htm</code> HTML output file,
allowing you to navigate the problematic path and all the details of
each of the states on the path.  If not, a DFA of the print behavior
is generated and compared with a provided DFA if specified with the
<code>-B</code> flag.
</ol>

<div id='sec-301'>
<h2>Section D.1. Compiler</h2>
<p>The Harmony compiler, in order to stay true to the Harmony source program,
does not do much in the way of optimizations.  The main optimizations that
it does are:<p><ul><li> Constant folding: (simple) expressions consisting only of constants
are evaluated by the compiler rather than by the model checker;
<li> Jump threading: Harmony eliminates jump to jump instructions;
<li> Dead variable elimination: Harmony removes method variables that
are no longer in use from the state in order to reduce the state space
to be explored.
</ul>
</div>

<div id='sec-302'>
<h2>Section D.2. Model Checker</h2>
<p>The Harmony model checker, called <i>Charm</i>, takes the output from
the compiler and explores the entire state space in breadth-first order.
Even though Harmony does not really support input, there are three sources of
non-determinism that make this exploration non-trivial:<p><ul><li> <b>choose</b> <i>expressions</i>: Harmony's ability to let the program
choose a value from a set;
<li> <i>thread interleaving</i>: different threads run pseudo-concurrently
with their instructions interleaved in arbitrary ways;
<li> <i>interrupts</i>: Harmony programs can set interrupts that can go
off at arbitrary times.
</ul>

A thread can be in <i>atomic</i> mode or not.
In atomic mode, the execution of the thread is not interleaved with
other threads.
A thread can also be in <i>read-only</i> mode or not.
In read-only mode, the thread cannot write or deleted shared variables.<p>Charm has some tricks to significantly reduce the state space to explore.
<ul><li> A thread can have local state (program counter, stack,
method variables, and thread-local state variables).
That state is called the <i>context</i> of the thread.
The context of a thread cannot be accessed by other
threads, nor by <b>invariant</b> or <b>finally</b> statements.
So, the model checker only interleaves threads at <b>Load</b>,
<b>Store</b>, and <b>Del</b> instructions where a thread
interacts with global
variables.
<li> Threads are anonymous, and therefore two or more threads can
have the same context.  The state of the model checker therefore maintains
a <i>bag</i> (multiset) of contexts rather are than a <i>set</i> of contexts.
Thus even if there are hundreds of threads, there may be only tens of
possible context states.
</ul>

That said, <i>state space explosion</i> is still a possibility, and
Harmony programmers should keep this in mind when writing and testing
their programs.  Do not be too ambitious: start with small tests and
gradually build them up as necessary.<p>The model checker stops either when it finds a failing execution or when
it has explored the entire state space, whichever comes first.  An execution
can fail for a variety of reasons:<p><ul><li> An invariant failing: Harmony evaluates all invariants in all states
that if finds---if one fails, Harmony stops further exploration;
<li> An assertion failing;
<li> A behavior violation: this is when the sequence of printed values
are not recognized by the provided DFA (using the <code>-B</code> flag);
<li> A <i>silly</i> error: this includes reading variables that have not
been assigned, trying to add a set to an integer, taking the length of
something that is not a set of a dictionary, and so on;
<li> An infinite loop: a thread goes into an infinite loop without
accessing shared variables.
</ul>
</div>

<div id='sec-303'>
<h2>Section D.3. Model Checker Output Analysis</h2>
<p><a id="index:Kripke-structure:1"></a>
The output of the model checker is a graph (a so-called
<i>Kripke structure</i>) that is typically very large.
If some execution failed, then Harmony will simply report the path of
that failing execution.  But otherwise there may be the following
outcomes:<p><ul><li> No issues: no failing executions and each program can terminate;
<li> Non-terminating states: some executions lead to some form of deadlock
or other issue that causes some (non-eternal) threads not to be able to
terminate;
<li> Race conditions: there are executions in which two threads access
the same shared state variable, with at least one of those accesses being a
<b>Store</b> operation;
<li> Busy waiting: executions in which threads are actively waiting for
some condition, usually by releasing and reacquiring locks.
</ul>


In order to diagnose these outcomes, Harmony must analyze the graph.<p>The first thing that Harmony does is to locate non-terminating
states, if any.  To do this, Harmony first determines the
<i>strongly connected components</i> of the graph using Kosaraju's algorithm.
A component (subgraph) of a graph is strongly connected if each
vertex (state) in the component can be reached from each other vertex.
The components then form a Directed Acyclic Graph (DAG).
The DAG is easier to analyze than the original graph.
One can easily determine the sink components
(the components with no outgoing edges).  If such a component
has non-eternal threads in it, then each state in that component
is a non-terminating state.<p>To find race conditions, the model checker looks in the graph for
states in which there are multiple threads that can make a step.
If there is a step in which multiple threads access the same shared
variable, at least one of those accesses is a store operation, and
at least one of those threads is not in atomic mode, then Harmony
reports the shortest path to such a state.<p>To show how Harmony detects busy waiting, we will first show how
Harmony determines if a thread is blocked or not.  A thread is considered
blocked if it cannot terminate without the help of another thread.
For example, a thread waiting for a lock is blocked and cannot terminate
until another thread releases the lock.  Determining whether a thread
is blocked in a particular state can be done within the confines of the
connected component: the analyzer tries all possible executions of the
thread.  If it cannot &quot;escape&quot; the connected component by doing so, it
is considered blocked.
A thread is considered <i>busy waiting</i> if it is blocked, but it is
also changing the shared state while doing so.  A thread that is waiting
on a spinlock only observes the state.<p>In the output, each thread has a unique identifier:
<code>T0</code> is the initialization thread; <code>T</code><i>n</i> is the  <span 
class="cmmi-10">n</span><sup><span 
class="cmmi-7">th</span></sup>

spawned thread that executes.  This seems to contradict the fact that
Harmony threads are anonymous.  The output analyzer assigns these
identifiers <i>a posteriori</i> to the threads in the state graph
by keeping track, along the reported execution path, what state each
thread is in.  So, by examining the initial context of the thread that
is running from some particular state, it can determine if that context
corresponds to the current context of some thread that ran previously
or if the context belongs to a new thread that has not run before.<p>If there are no issues, Harmony also generates a DFA of the print
behavior.  Starting with the original state graph or Kripke structure,
the edges are inspected.  If there are multiple print operations on
an edge, additional states are inserted so that there are either 0
or 1 print operations on an edge.  This graph of nodes (states) and edges
(transitions)
forms a Non-deterministic Finite Automaton (NFA) with  <span 
class="cmmi-10">&#x03F5; </span>-transitions
(transitions without print operations).  Harmony turns the NFA into a DFA
and by default also minimizes the DFA (although not strictly
necxessary).  The DFA can be fed into another run of the model checker
to check that its print operations are consistent with the provided DFA.
</div>
</div>

<div id='sec-304'>
<h1>Appendix E. Simplified Grammar</h1>
<p>The next pages show a compact version of the complete Harmony grammar.
The precedence rules are loosely as follows.
Application binds most strongly.
Next are unary operators.  Next are binary operators.
Thus -<var>a</var>[1] - <var>a</var>[2] parses as (-(<var>a</var>[1])) - (<var>a</var>[2]).
!<var>a</var>[1] parses as !(<var>a</var>[1]).
Harmony will complain about ambiguities such as <var>a</var> - <i>b</i> + <i>c</i>.
Avoiding other ambiguities, Harmony does not allow expressions of the
form <var>a</var> @<i>b</i> where @ is some kind of unary operator.  You have to
write this as either <var>a</var>[@<i>b</i>] or <var>a</var>(@<i>b</i>).
The simplified grammar ignores indentation rules.<p>






<p><center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>block</i>: <i>statement</i> [[<var>NEWLINE</var> | ';'] <i>statement</i>]*;

<i>statement</i>
    : <i>e</i>     <i># usually a function call</i></code></pre>
</center>

<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><i>e</i>   <i># expression</i></code></pre>
</center>
</div>

<div id='sec-305'>
<h1>Appendix F. Directly checking linearizability</h1>

<a id="gls:linearizable:1"></a><p>

<p><div id='sec-306'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>from</b> <var>synch</var> <b>import</b> <var>Lock</var>, <var>acquire</var>, <var>release</var>
<b>from</b> <var>alloc</var> <b>import</b> <var>malloc</var>, <var>free</var>

<b>def</b> <var>Queue</var>():
    <i>result</i> = { .<i>head</i>: <b>None</b>, .<i>tail</i>: <b>None</b>, .<i>lock</i>: <var>Lock</var>(), .<i>time</i>: 0 }

<b>def</b> <var>_linpoint</var>(<i>q</i>):
    <b>atomically</b>:
        <b>this.qtime</b> = <i>q</i>-&gt;<i>time</i>
        <i>q</i>-&gt;<i>time</i> += 1

<b>def</b> <var>put</var>(<i>q</i>, <i>v</i>):
    <b>let</b> <i>node</i> = <var>malloc</var>({ .<i>value</i>: <i>v</i>, .<i>next</i>: <b>None</b> }):
        <var>acquire</var>(?<i>q</i>-&gt;<i>lock</i>)
        <b>if</b> <i>q</i>-&gt;<i>tail</i> == <b>None</b>:
            <i>q</i>-&gt;<i>tail</i> = <i>q</i>-&gt;<i>head</i> = <i>node</i>
        <b>else</b>:
            <i>q</i>-&gt;<i>tail</i>-&gt;<i>next</i> = <i>node</i>
            <i>q</i>-&gt;<i>tail</i> = <i>node</i>
        <var>_linpoint</var>(<i>q</i>)
        <var>release</var>(?<i>q</i>-&gt;<i>lock</i>)
    
<b>def</b> <var>get</var>(<i>q</i>):
    <var>acquire</var>(?<i>q</i>-&gt;<i>lock</i>)
    <b>let</b> <i>node</i> = <i>q</i>-&gt;<i>head</i>:
        <b>if</b> <i>node</i> == <b>None</b>:
            <i>result</i> = <b>None</b>
        <b>else</b>:
            <i>result</i> = <i>node</i>-&gt;<i>value</i>
            <i>q</i>-&gt;<i>head</i> = <i>node</i>-&gt;<i>next</i>
            <b>if</b> <i>q</i>-&gt;<i>head</i> == <b>None</b>:
                <i>q</i>-&gt;<i>tail</i> = <b>None</b>
            <var>free</var>(<i>node</i>)
    <var>_linpoint</var>(<i>q</i>)
    <var>release</var>(?<i>q</i>-&gt;<i>lock</i>)
</code></pre>

</center>
<h4>Figure G.1. [<a href='https://harmony.cs.cornell.edu/code/queuelin.hny'>code/queuelin.hny</a>] Queue implementation with linearization points</h4>


</div>

<div id='sec-307'>
<center><pre><code class="language-harmony" data-prismjs-copy="Copy"><b>import</b> <var>queuelin</var>, <var>queuespec</var>

<b>const</b> <var>NOPS</var> = 4
<b>const</b> <var>VALUES</var> = { 1..NOPS }

<b>sequential</b> <i>qtime</i>
<i>qtime</i> = 0

<i>implq</i> = <var>queuelin.Queue</var>()
<i>specq</i> = <var>queuespec.Queue</var>()

<b>def</b> <var>thread</var>():
    <b>let</b> <i>op</i> = <b>choose</b>({ "get", "put" }):
        <b>if</b> <i>op</i> == "put":
            <b>let</b> <i>v</i> = <b>choose</b>(<var>VALUES</var>):
                <var>queuelin.put</var>(?<i>implq</i>, <i>v</i>)
                <b>await</b> <i>qtime</i> == <b>this.qtime</b>
                <var>queuespec.put</var>(?<i>specq</i>, <i>v</i>)
        <b>else</b>:
            <b>let</b> <i>v</i> = <var>queuelin.get</var>(?<i>implq</i>):
                <b>await</b> <i>qtime</i> == <b>this.qtime</b>
                <b>let</b> <i>w</i> = <var>queuespec.get</var>(?<i>specq</i>):
                    <b>assert</b> <i>v</i> == <i>w</i>
    <b>atomically</b> <i>qtime</i> += 1

<b>for</b> <i>i</i> <b>in</b> {1..NOPS}:
    <b>spawn</b> <var>thread</var>()
</code></pre>

</center>
<h4>Figure G.2. [<a href='https://harmony.cs.cornell.edu/code/qtestconc.hny'>code/qtestconc.hny</a>] Concurrent queue test</h4>


</div>

We want a concurrent queue to behave
consistently with a sequential queue in that all
<var>put</var>
and <var>get</var> operations should appear to happen
in a total order.
Moreover, we want to make sure that if some
<var>put</var> or <var>get</var> operation  <span 
class="cmmi-10">o</span><sub><span 
class="cmr-7">1</span></sub>  finished
before another operation  <span 
class="cmmi-10">o</span><sub><span 
class="cmr-7">2</span></sub>
 started, then  <span 
class="cmmi-10">o</span><sub><span 
class="cmr-7">1</span></sub> 
should appear to happen before  <span 
class="cmmi-10">o</span><sub><span 
class="cmr-7">2</span></sub>  in the total order.
If these two conditions are met, then we say that
the concurrent queue implementation is <i>linearizable</i>.<p>In general, if a data structure is protected by
a single lock and every operation on that data
structure starts with acquiring the lock and ends
with releasing the lock, it will automatically be
linearizable.
The queue implementation in <a href='#sec-81'>Figure 11.3</a> does
not quite match this pattern, as the <var>put</var>
operation allocates a new node before acquiring
the lock.
However, in this case that is not a problem, as
the new node has no dependencies on the queue
when it is allocated.<p>Still, it would be useful to check in Harmony that
<a href='#sec-81'>Figure 11.3</a> is linearizable.
To do this, instead of applying the operations sequentially,
we want the test program to invoke the operations concurrently,
consider all possible interleavings, and see if the result
is consistent with an appropriate sequential execution of the
operations.<p><a id="index:logical-timestamp:2"></a>
Harmony provides support for testing linearizability,
but requires that the programmer
identifies what are known as <i>linearization points</i>
in the implementation that indicate exactly <i>which</i> sequential
execution the concurrent execution must align with.
<a href='#sec-306'>Figure G.1</a> is a copy of <a href='#sec-81'>Figure 11.3</a> extended with
linearization points.
For each operation (<var>get</var> and <var>put</var>), the corresponding
linearization point must occur somewhere between acquiring and releasing
the lock.
Each linearization point execution is assigned a logical timestamp.
Logical timestamps are numbered  0<span 
class="cmmi-10">,</span>1<span 
class="cmmi-10">,...</span>

To do so, we have added a counter (<code>time</code>) to the <var>Queue</var>.
Method <var>_linpoint</var> saves the current counter in
<b>this.qtime</b> and increments the counter.
The <b>this</b> dictionary maintains <i>thread-local state</i> associated
with the thread (<a href='#sec-28'>Chapter 4</a>)---it contains variables that
can be accessed by any method in the thread.<p>Given the linearization points, <a href='#sec-307'>Figure G.2</a> shows how
linearizability can be tested.
The test program is similar to the sequential test program
(<a href='#sec-96'>Figure 13.1</a>) but starts a thread for each operation.
The operations are executed concurrently on the concurrent queue
implementation of <a href='#sec-306'>Figure G.1</a>, but they are executed sequentially
on the sequential queue specification of <a href='#sec-79'>Figure 11.1</a>(a).
To that end, the test program maintains a global time variable
<i>qtime</i>, and each thread waits until the timestamp assigned to
the last concurrent queue operation matches <i>qtime</i> before invoking
the sequential operation in the specification.
Afterward, it atomically increments the shared <i>qtime</i> variable.
This results in the operations being executed sequentially against the
sequential specification in the same order of the linearization points
of the concurrent specification.
</div>

<div id='sec-308'>
<h1>Appendix G. Manual Pages</h1>
<p><div id='sec-309'>
<h2 id="sec-309">NAME</h2><p>Harmony --- the Harmony compiler and model checker
</div>

<div id='sec-310'>
<h2 id="sec-310">SYNOPSIS</h2><p><code>harmony [options] filename</code>
</div>

<div id='sec-311'>
<h2 id="sec-311">DESCRIPTION</h2><p><code>harmony</code> is a compiler and model checker for the Harmony
programming language.  <code>harmony</code> compiles Harmony into
bytecode and then model checks the bytecode.  The result is analyzed
for failing assertions and invariants, non-terminating conditions
such as deadlock and infinite loops, race conditions, deviations
from specifications, and busy waiting.  There are three phases:<p><ul><li> <i>compile</i>: parses Harmony source code and generates
Harmony virtual machine code;
<li> <i>model check</i>: generates a graph of all reachable
states from the Harmony virtual machine code while checking for
safety violations;
<li> <i>analysis</i>: checks the graph for non-termination,
race conditions, and busy waiting.
</ul>

The Harmony file name extensions are as follows:<p><ul><li> <code>.hny</code>: Harmony source code;
<li> <code>.hvm</code>: Harmony virtual machine code (in JSON format);
<li> <code>.hco</code>: Harmony output (in JSON format);
<li> <code>.hvb</code>: Harmony verbose output (human readable);
<li> <code>.hfa</code>: Harmony finite automaton, describing the possible <b>print</b> outputs (in JSON format).
</ul>

In addition, <code>harmony</code> can also generate
<code>.tla</code> (TLA+),
<code>.htm</code> (HTML), 
<code>.gv</code>: (Graphviz DOT version of <code>.hfa</code> output),
<code>.png</code>: (PNG version of <code>.hfa</code> output), and
<code>.tex</code>: (LaTeX formatted source code).<p>By default, running ``<code>harmony x.hny</code>' will generate
<code>x.hvm</code>, <code>x.hco</code>, <code>x.hvb</code>, <code>x.png</code>,
and <code>x.hvm</code> files.
Harmony will also, by default, automatically start a web browser to
display the <code>x.hvm</code> file.  Various options can be used to
change the behavior.<p>When importing a module using <b>import</b> <i>x</i>, <code>harmony</code> will
try to find the corresponding <code>.hny</code> file in the following order:
<ol><li> check if the module file is specified with the <code>-m</code> or
<code>--module</code> option;
<li> see if a file by the name <i>x.hny</i> is present in the same
directory as the source file;
<li> see if a file by the name <i>x.hny</i> is present in the
installation's <code>modules</code> directory.
</ol>
</div>

<div id='sec-312'>
<h2 id="sec-312">OPTIONS</h2><p><div id='sec-313'>
<h3 id="sec-313">Output file options:</h3>
<ul><li> <code>-o</code> <i>filename.gv</i>: specify the name of the
file where the <code>graphviz</code> (DOT) output should be stored;
<li> <code>-o</code> <i>filename.hco</i>: specify the name of the
file where model checker output should be stored;
<li> <code>-o</code> <i>filename.hfa</i>: specify the name of the
file where the Harmony finite automaton should be stored;
<li> <code>-o</code> <i>filename.htm</i>: specify the name of the
file where the HTML output should be stored;
<li> <code>-o</code> <i>filename.hvb</i>: specify the name of the
file where the verbose output should be stored;
<li> <code>-o</code> <i>filename.hvm</i>: specify the name of the
file where the Harmony virtual machine code should be stored;
<li> <code>-o</code> <i>filename.png</i>: specify the name of the
file where the PNG output should be stored;
<li> <code>-o</code> <i>filename.tla</i>: generate a TLA+ file
specifying the behaviors of the Harmony virtual machine code;
<li> <code>-o</code> <i>filename.tex</i>: generate a LaTeX+ file
containing the formatted source code.
</ul>
</div>

<div id='sec-314'>
<h3 id="sec-314">Other options:</h3><p><ul><li> <code>-a</code>: compile only and list machine code (with labels);
<li> <code>-A</code>: compile only and list machine code (without labels);
<li> <code>-B</code> <code>filename.hfa</code>: check Harmony code against output behaviors described in <code>filename.hfa</code> (result of another Harmony run);
<li> <code>-c</code>, <code>--const</code> <i>constant</i>=<i>expression</i>: set the value of the given constant (which must be defined in the code) to the result of evaluating the given expression;
<li> <code>-m</code>, <code>--module</code> <i>module</i>=<i>filename.hny</i>: load the given module instead of looking in default locations;
<li> <code>--noweb</code>: do not start a web browser upon completion;
<li> <code>-v</code>, <code>--version</code>: print the <code>harmony</code> version number.
<li> <code>-w</code> <i>#workers</i>: specify the number of concurrent threads the model checker uses.
</ul>
</div>
</div>




</div>


<div id='sec-315'>
<h1 id="sec-315">Acknowledgments</h1><p>I received considerable help and inspiration from various people
while writing this book.<p>First and foremost I would like to thank my student Haobin Ni with
whom I've had numerous discussions about the initial design of Harmony.
Haobin even contributed some code to the Harmony compiler.
Many thanks are also due to William Ma who refactored the Harmony code
to make it easier to maintain.
He also wrote the first version of the behavior automaton generator
and created the first graphs using the graphviz tool.
I have had lots of discussions with him about a wide range of
improvements to the Harmony language, many of which came to fruition.
I also want to thank Ariel Kellison with whom I discussed approaches
to formally specify the Harmony virtual machine in TLA+.<p>Kevin Sun and Anthony Yang built a beautiful VSCode extension for Harmony
called HarmonyLang and proceeded to build an animator for Harmony
executions and two cloud-based Harmony offerings, which you can learn
about at <a href='http://harmony.cs.cornell.edu'>http://harmony.cs.cornell.edu</a>.  They also developed much of
that web site and made valuable suggestions for improvements to the
Harmony language.  Later they were joined by Shi Chong Zhao and Robin Li,
who also made significant contributions.
Kevin, Anthony, and Robin continue to make
great contributions to the Harmony distribution.<p>I also would like to acknowledge my regular conversation about Harmony
with Sasha Sandler of the Oracle Cloud Infrastructure group.
He is an early industrial adopter of
Harmony and has used it successfully to find and fix bugs in industrial
settings.  His insights have been invaluable.<p>Most of what I know about concurrent programming I learned from
my colleague Fred Schneider.  He suggested I write this book after
demonstrating Harmony to him.  Being a foremost security expert, he also
assisted significantly with the chapter on the Needham-Schroeder protocol.<p>Leslie Lamport introduced me to using model checking to test properties
of a concurrent system.  My experimentation with using TLC on Peterson's
Algorithm became an aha moment for me.  I have learned so much from his
papers.<p>I first demonstrated Harmony to the students in my CS6480 class on systems
and formal verification and received valuable feedback from them.
The following people contributed by making comments on or finding bugs in
early drafts of the book:
Alex Chang,
Anneke van Renesse,
Brendon Nguyen,
CJ Lee,
Harshul Sahni,
Hartek Sabharwal,
Heather Zheng,
Jack Rehmann,
Jacob Brugh,
Liam Arzola,
Lorenzo Alvisi,
Maria Martucci,
Nalu Concepcion,
Phillip O'Reggio,
Saleh Hassen,
Sunwook Kim,
Terryn Jung,
Melissa Reifman,
Trishita Tiwari,
Xiangyu Zhang,
Yidan Wang,
Zhuoyu Xu,
and
Zoltan Csaki.<p>Finally, I would like to thank my family who had to suffer as I obsessed
over writing the code and the book, at home, during the turbulent months of
May and June 2020.<p></div>


<h1 id="sec-316">Index</h1>
<table border="0"><tr><td valign="top">
<ul>
<li><a href="#index:acknowledgment:1">acknowledgment</a></li>
<li><a href="#index:acquire:1">acquire</a></li>
<li><a href="#index:action:1">action</a></li>
<li><a href="#index:actor-model:1">actor model</a></li>
<li><a href="#index:address:1">address</a>, <a href="#index:address:2"><i>also</i></a></li>
<li><a href="#index:alloc-module:1">alloc module</a></li>
<li><a href="#index:alternating-bit-protocol:1">alternating bit protocol</a></li>
<li><a href="#index:atomic-instruction:1">atomic instruction</a></li>
<li><a href="#index:atomicity:1">atomicity</a></li>
</ul><ul>
<li><a href="#index:bag:1">bag</a></li>
<li><a href="#index:bag-module:1">bag module</a></li>
<li><a href="#index:barrier-synchronization:1">barrier synchronization</a></li>
<li><a href="#index:big-lock:1">big lock</a></li>
<li><a href="#index:blocked-thread:1">blocked thread</a></li>
<li><a href="#index:blocking-queue:1">blocking queue</a></li>
<li><a href="#index:bounded-buffer:1">bounded buffer</a></li>
<li><a href="#index:broadcast:1">broadcast</a></li>
<li><a href="#index:busy-waiting:1">busy waiting</a></li>
<li><a href="#index:bytecode:1">bytecode</a></li>
</ul><ul>
<li><a href="#index:choose-operator:1">choose operator</a></li>
<li><a href="#index:client/server-model:1">client/server model</a></li>
<li><a href="#index:coarse-grained-lock:1">coarse-grained lock</a></li>
<li><a href="#index:constant:1">constant</a></li>
<li><a href="#index:context:1">context</a></li>
<li><a href="#index:continuation:1">continuation</a></li>
<li><a href="#index:corner-case:1">corner case</a></li>
<li><a href="#index:critical-region:1">critical region</a></li>
<li><a href="#index:critical-section:1">critical section</a></li>
</ul><ul>
<li><a href="#index:data-race:1">data race</a></li>
<li><a href="#index:deadlock:1">deadlock</a></li>
<li><a href="#index:deadlock-avoidance:1">deadlock avoidance</a></li>
<li><a href="#index:determinism:1">determinism</a>, <a href="#index:determinism:2"><i>also</i></a></li>
<li><a href="#index:dictionary:1">dictionary</a></li>
<li><a href="#index:dining-philosopher:1">dining philosopher</a></li>
<li><a href="#index:directory:1">directory</a></li>
<li><a href="#index:distributed-system:1">distributed system</a>, <a href="#index:distributed-system:2"><i>also</i></a></li>
<li><a href="#index:double-turnstile:1">double turnstile</a></li>
<li><a href="#index:dynamic-allocation:1">dynamic allocation</a></li>
</ul><ul>
<li><a href="#index:exception:1">exception</a></li>
</ul><ul>
<li><a href="#index:failure:1">failure</a></li>
<li><a href="#index:fairness:1">fairness</a></li>
<li><a href="#index:fine-grained-lock:1">fine-grained lock</a></li>
<li><a href="#index:flow-control:1">flow control</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#index:fork-module:1">fork module</a></li>
<li><a href="#index:formal-verification:1">formal verification</a></li>
</ul><ul>
<li><a href="#index:go-statement:1">go statement</a></li>
</ul><ul>
<li><a href="#index:hand-over-hand-locking:1">hand-over-hand locking</a></li>
<li><a href="#index:Harmony-method:1">Harmony method</a></li>
<li><a href="#index:Harmony-Virtual-Machine:1">Harmony Virtual Machine</a>, <a href="#index:Harmony-Virtual-Machine:2"><i>also</i></a></li>
<li><a href="#index:Heisenbug:1">Heisenbug</a></li>
<li><a href="#index:hoare-module:1">hoare module</a></li>
<li><a href="#index:HVM:1">HVM</a></li>
</ul><ul>
<li><a href="#index:idempotent:1">idempotent</a></li>
<li><a href="#index:import-statement:1">import statement</a></li>
<li><a href="#index:inductive-invariant:1">inductive invariant</a></li>
<li><a href="#index:interleaving:1">interleaving</a></li>
<li><a href="#index:interrupt:1">interrupt</a></li>
<li><a href="#index:interrupt-safety:1">interrupt-safety</a></li>
<li><a href="#index:invariant:1">invariant</a>, <a href="#index:invariant:2"><i>also</i></a></li>
</ul><ul>
<li><a href="#index:Kripke-structure:1">Kripke structure</a></li>
</ul><ul>
<li><a href="#index:list-module:1">list module</a></li>
<li><a href="#index:liveness-property:1">liveness property</a></li>
<li><a href="#index:lock:1">lock</a>, <a href="#index:lock:2"><i>also</i></a></li>
<li><a href="#index:lock-granularity:1">lock granularity</a></li>
<li><a href="#index:logical-timestamp:1">logical timestamp</a>, <a href="#index:logical-timestamp:2"><i>also</i></a></li>
</ul><ul>
<li><a href="#index:machine-instruction:1">machine instruction</a></li>
<li><a href="#index:Mesa:1">Mesa</a></li>
<li><a href="#index:message-passing:1">message passing</a></li>
<li><a href="#index:model-checking:1">model checking</a></li>
<li><a href="#index:module:1">module</a></li>
<li><a href="#index:monitor:1">monitor</a></li>
<li><a href="#index:multiple-conditions,-waiting-on:1">multiple conditions, waiting on</a></li>
<li><a href="#index:multiset:1">multiset</a></li>
<li><a href="#index:mutual-exclusion:1">mutual exclusion</a></li>
</ul><ul>
<li><a href="#index:network:1">network</a></li>
<li><a href="#index:non-blocking-synchronization:1">non-blocking synchronization</a></li>
<li><a href="#index:non-determinism:1">non-determinism</a></li>
<li><a href="#index:notify:1">notify</a></li>
<li><a href="#index:notifyAll:1">notifyAll</a></li>
</ul><ul>
<li><a href="#index:pattern-matching:1">pattern matching</a></li>
<li><a href="#index:Peterson's-Algorithm:1">Peterson's Algorithm</a></li>
<li><a href="#index:pipeline:1">pipeline</a></li>
<li><a href="#index:pointer:1">pointer</a></li>
<li><a href="#index:producer/consumer-problem:1">producer/consumer problem</a></li>
<li><a href="#index:program-counter:1">program counter</a></li>
<li><a href="#index:progress:1">progress</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#index:property:1">property</a></li>
<li><a href="#index:protocol:1">protocol</a></li>
</ul><ul>
<li><a href="#index:race-condition:1">race condition</a></li>
<li><a href="#index:reachable-state:1">reachable state</a></li>
<li><a href="#index:reader/writer-lock:1">reader/writer lock</a></li>
<li><a href="#index:register:1">register</a></li>
<li><a href="#index:release:1">release</a></li>
<li><a href="#index:replication:1">replication</a></li>
<li><a href="#index:reserve-debugging:1">reserve debugging</a></li>
<li><a href="#index:retransmission:1">retransmission</a></li>
</ul><ul>
<li><a href="#index:safety-property:1">safety property</a></li>
<li><a href="#index:seqlock:1">seqlock</a></li>
<li><a href="#index:sequence-number:1">sequence number</a></li>
<li><a href="#index:sequential:1">sequential</a></li>
<li><a href="#index:sequential-consistency:1">sequential consistency</a></li>
<li><a href="#index:set-module:1">set module</a></li>
<li><a href="#index:shared-variable:1">shared variable</a></li>
<li><a href="#index:signal:1">signal</a></li>
<li><a href="#index:single-point-of-failure:1">single point of failure</a></li>
<li><a href="#index:spinlock:1">spinlock</a>, <a href="#index:spinlock:2"><i>also</i></a></li>
<li><a href="#index:split-binary-semaphore:1">split binary semaphore</a></li>
<li><a href="#index:stack-machine:1">stack machine</a></li>
<li><a href="#index:starvation:1">starvation</a>, <a href="#index:starvation:2"><i>also</i></a></li>
<li><a href="#index:state:1">state</a></li>
<li><a href="#index:state-machine-replication:1">state machine replication</a></li>
<li><a href="#index:step:1">step</a></li>
<li><a href="#index:stop-expression:1">stop expression</a></li>
<li><a href="#index:stride:1">stride</a></li>
<li><a href="#index:synch-module:1">synch module</a>, <a href="#index:synch-module:2"><i>also</i></a></li>
<li><a href="#index:synchronized-queue:1">synchronized queue</a></li>
</ul><ul>
<li><a href="#index:TAS:1">TAS</a></li>
<li><a href="#index:test:1">test</a></li>
<li><a href="#index:test-and-set:1">test-and-set</a></li>
<li><a href="#index:thread:1">thread</a>, <a href="#index:thread:2"><i>also</i></a>, <a href="#index:thread:3"><i>also</i></a></li>
<li><a href="#index:thread-safety:1">thread safety</a></li>
<li><a href="#index:thread-variable:1">thread variable</a></li>
<li><a href="#index:thread-local:1">thread-local</a></li>
<li><a href="#index:thunk:1">thunk</a></li>
<li><a href="#index:Time-Of-Check-Time-Of-Execution:1">Time Of Check Time Of Execution</a></li>
<li><a href="#index:TOCTOE:1">TOCTOE</a></li>
<li><a href="#index:trace:1">trace</a></li>
</ul><ul>
<li><a href="#index:virtual-machine:1">virtual machine</a></li>
</ul><ul>
<li><a href="#index:wait:1">wait</a></li>
<li><a href="#index:wait-free-synchronization:1">wait-free synchronization</a></li>
</ul>
</td></tr></table>
<p>
<h1 id="sec-317">Glossary</h1>
<ul>
<li><a href="#gls:actor-model:1">Actor model</a> is a concurrency model where there are no shared variables, only threads with private variables that communicate through message passing.</li>
<li><a href="#gls:atomic-instruction:1">Atomic instruction</a> a machine instruction that may involve multiple memory load and/or store operations and is executed atomically.</li>
<li><a href="#gls:atomicity:1">Atomicity</a> describes that a certain machine instruction or sequence of machine instructions is executed indivisibly by a thread and cannot be interleaved with machine instructions of another thread.</li>
<li><a href="#gls:barrier-synchronization:1">Barrier synchronization</a> is when a set of threads execute in rounds, waiting for one another to complete each round.</li>
<li><a href="#gls:behavior:1">Behavior</a> is a sequence of states.  A trace uniquely defines a behavior but not vice versa.</li>
<li><a href="#gls:blocked-thread:1">Blocked thread</a> is a thread that cannot change the state or terminate or can only do so after another thread changes the state first.  For example, a thread that is waiting for a lock to become available.</li>
<li><a href="#gls:busy-waiting:1">Busy waiting</a> (aka spin-waiting) is when a thread waits in a loop for some application-defined condition instead of blocking.</li>
<li><a href="#gls:concurrent-execution:1">Concurrent execution</a> (aka parallel execution) is when there are multiple threads executing and their machine instructions are interleaved in an unpredictable manner.</li>
<li><a href="#gls:condition-variable:1">Condition variable</a> a variable that keeps track of which threads are waiting for a specific application-level condition.  The variable can be waited on as well as signaled or notified.</li>
<li><a href="#gls:conditional-critical-section:1">Conditional critical section</a> is a critical section with, besides mutual exclusion, additional conditions on when a thread is allowed to enter the critical section.</li>
<li><a href="#gls:context:1">Context</a> (aka continuation) describes the state of a running thread, including its program counter, the values of its variables (stored in its register), and the contents of its stack.</li>
<li><a href="#gls:critical-section:1">Critical section</a> (aka critical region) is a set of instructions that only one thread is allowed to execute at a time.  The instructions are, however, not executed atomically, as other threads can continue to execute and access shared variables.</li>
<li><a href="#gls:data-race:1">Data race</a> is when there are two or more threads concurrently accessing a shared variable, at least one of which is an update to the variable.</li>
<li><a href="#gls:deadlock:1">Deadlock</a> is when there are two or more threads waiting indefinitely for one another to release a resource.</li>
<li><a href="#gls:determinism:1">Determinism</a> is when the outcome of an execution is uniquely determined by the initial state.</li>
<li><a href="#gls:fairness:1">Fairness</a> is when each thread eventually can access each resource it needs to access with high probability.</li>
<li><a href="#gls:invariant:1">Invariant</a> is a binary predicate over states that must hold for every reachable state of a thread.</li>
<li><a href="#gls:linearizable:1">Linearizable</a> is a consistency condition for concurrent access to an object, requiring that each access must appear to execute atomically sometime between the invocation of the access and its completion.</li>
<li><a href="#gls:lock:1">Lock</a> an object that can be owned by at most one thread at a time.  Useful for implementing mutual exclusion.</li>
<li><a href="#gls:machine-instruction:1">Machine instruction</a> is an atomic operation on the Harmony virtual machine, executed by a thread.</li>
<li><a href="#gls:model-checking:1">Model checking</a> is a formal verification method that explores all possible executions of a program, which must have a finite number of states.</li>
<li><a href="#gls:monitor:1">Monitor</a> is a programming language paradigm that supports mutual exclusion as well as waiting for resources to become available.</li>
<li><a href="#gls:mutual-exclusion:1">Mutual exclusion</a> is the property that two threads never enter the same critical section.</li>
<li><a href="#gls:non-blocking-synchronization:1">Non-blocking synchronization</a> (aka wait-free synchronization) is when access to a shared resource can be guaranteed in a bounded number of steps even if other threads are not making progress.</li>
<li><a href="#gls:producer/consumer-problem:1">Producer/consumer problem</a> is a synchronization problem whereby one or more producing threads submit items and one or more consuming threads want to receive them.  No item can get lost or forged or be delivered to more than one consumer, and producers and consumers should block if resources are exhausted.</li>
<li><a href="#gls:property:1">Property</a> describes a set of execution traces or behaviors or histories that are allowed by a program.  Safety properties are properties in which &quot;no bad things happen,&quot; such as violating mutual exclusion in a critical section.  Liveness properties are properties where &quot;something good eventually happens,&quot; like threads being able to enter the critical section if they want to.</li>
<li><a href="#gls:race-condition:1">Race condition</a> describes when multiple threads access shared state concurrently, leading to undesirable outcomes.</li>
<li><a href="#gls:reader/writer-lock:1">Reader/writer lock</a> is a lock on a resource that can be held by multiple threads if they all only read the resource.</li>
<li><a href="#gls:replication:1">Replication</a> maintains multiple copies of some resource to improve availability in the face of failures.</li>
<li><a href="#gls:semaphore:1">Semaphore</a> is a counter that can be atomically incremented and decremented, but blocks the thread until the counter is larger than zero first.</li>
<li><a href="#gls:sequential-consistency:1">Sequential consistency</a> is a consistency model in which shared memory accesses are executed in an order consistent with the program order.</li>
<li><a href="#gls:sequential-execution:1">Sequential execution</a> is when there is just one thread executing, as opposed to concurrent execution.</li>
<li><a href="#gls:shared-variable:1">Shared variable</a> is a variable that is stored in the memory of the Harmony virtual machine and shared between multiple threads, as opposed to a thread variable.</li>
<li><a href="#gls:spinlock:1">Spinlock</a> is an implementation of a lock whereby a thread loops until the lock is available, at which point the thread atomically obtains the lock.</li>
<li><a href="#gls:stack-machine:1">Stack machine</a> is a model of computing where the state of a thread is kept on a stack.  Harmony uses a combination of a stack machine and a register-based machine.</li>
<li><a href="#gls:starvation:1">Starvation</a> is when a thread cannot make progress because it is continuously losing a competition with other threads to get access to a resource.</li>
<li><a href="#gls:state:1">State</a> an assignment of values to variables.  In a Harmony virtual machine, this includes the contents of its shared memory and the set of contexts.</li>
<li><a href="#gls:state-machine-replication:1">State machine replication</a> is a replication technique in which a collection of deterministic state machines process the same inputs in the same order.</li>
<li><a href="#gls:step:1">Step</a> is the execution of a machine instruction by a thread, updating its state.</li>
<li><a href="#gls:thread:1">Thread</a> is code in execution.  We do not make the distinction between threads and threads.  A thread has a current context and updates its context every time it executes a machine instruction.</li>
<li><a href="#gls:thread-safety:1">Thread safety</a> is when the implementation of a data structure allows concurrent access with well-defined semantics.</li>
<li><a href="#gls:thread-variable:1">Thread variable</a> is a variable that is private to a single thread and stored in its register.</li>
<li><a href="#gls:trace:1">Trace</a> is a sequence of steps, starting from an initial state.</li>
</ul>
<p>
    </div>
  </body>
</html>

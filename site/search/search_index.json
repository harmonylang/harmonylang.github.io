{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Harmony Our online documentation is still a work in progress. For more complete documentation see the textbook . Overview Quick Start - Get started with Harmony. Language Reference - Language features and syntax. Library Reference - Built in modules and libraries. Changelog - What's new in Harmony 1.0.","title":"Overview"},{"location":"#harmony","text":"Our online documentation is still a work in progress. For more complete documentation see the textbook .","title":"Harmony"},{"location":"#overview","text":"Quick Start - Get started with Harmony. Language Reference - Language features and syntax. Library Reference - Built in modules and libraries. Changelog - What's new in Harmony 1.0.","title":"Overview"},{"location":"changelog/","text":"Changelog v1.0 Rewrote model checker in C for much faster performance Removed semicolons as a syntax requirement Updated imports syntax Requires Python3 and GCC in path to run v0.9 Initial release of the Harmony Language Model checker for concurrent programs HTML output with steps and shortest path to failure Required Python3 to run","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v10","text":"Rewrote model checker in C for much faster performance Removed semicolons as a syntax requirement Updated imports syntax Requires Python3 and GCC in path to run","title":"v1.0"},{"location":"changelog/#v09","text":"Initial release of the Harmony Language Model checker for concurrent programs HTML output with steps and shortest path to failure Required Python3 to run","title":"v0.9"},{"location":"guides/installation/","text":"Installation Requirements Harmony requires both Python 3 and the GCC compiler. Both must be on your PATH environment variable for Harmony to function. MacOS and Linux Download and install Python 3 Open terminal and verify that the python3 command works If not, add export PATH=/usr/local/share/python:$PATH to your ~/.bash_profile and/or ~/.zshrc Open terminal and verify that the gcc command works If not, install GCC, either through Homebrew on Mac ( brew install gcc ) or apt-get on Ubuntu and other distros ( sudo apt-get install build-essential ) Windows Download and install Python 3 Open terminal and verify that the python3 command works If not, add your python install directory to your PATH Install GCC (http://mingw-w64.org/doku.php). At the Settings window, make sure you select the x86-64 architecture (instead of the default i686) during installation After installation is complete, add {installation path}\\mingw64\\bin to your PATH environment variable Open CMD and verify that the gcc command works Compiler Only Download and unzip the Harmony compiler Add harmony's directory to your PATH environment variable see http://www.linux-migration.org/ch02s06.html If you run harmony in the harmony directory, you may have to run \"./harmony [args ...]\" instead of just \"harmony [args ...]\" HarmonyLang - VSCode Extension Download and Install Visual Studio Code Install the HarmonyLang extension from the Extension Marketplace","title":"Installation"},{"location":"guides/installation/#installation","text":"","title":"Installation"},{"location":"guides/installation/#requirements","text":"Harmony requires both Python 3 and the GCC compiler. Both must be on your PATH environment variable for Harmony to function.","title":"Requirements"},{"location":"guides/installation/#macos-and-linux","text":"Download and install Python 3 Open terminal and verify that the python3 command works If not, add export PATH=/usr/local/share/python:$PATH to your ~/.bash_profile and/or ~/.zshrc Open terminal and verify that the gcc command works If not, install GCC, either through Homebrew on Mac ( brew install gcc ) or apt-get on Ubuntu and other distros ( sudo apt-get install build-essential )","title":"MacOS and Linux"},{"location":"guides/installation/#windows","text":"Download and install Python 3 Open terminal and verify that the python3 command works If not, add your python install directory to your PATH Install GCC (http://mingw-w64.org/doku.php). At the Settings window, make sure you select the x86-64 architecture (instead of the default i686) during installation After installation is complete, add {installation path}\\mingw64\\bin to your PATH environment variable Open CMD and verify that the gcc command works","title":"Windows"},{"location":"guides/installation/#compiler-only","text":"Download and unzip the Harmony compiler Add harmony's directory to your PATH environment variable see http://www.linux-migration.org/ch02s06.html If you run harmony in the harmony directory, you may have to run \"./harmony [args ...]\" instead of just \"harmony [args ...]\"","title":"Compiler Only"},{"location":"guides/installation/#harmonylang-vscode-extension","text":"Download and Install Visual Studio Code Install the HarmonyLang extension from the Extension Marketplace","title":"HarmonyLang - VSCode Extension"},{"location":"guides/introduction/","text":"Introduction Harmony is a Python-like programming language for testing and experimenting with concurrent programs. Instead of \"running\" code, Harmony programs are model-checked so that all corner cases are explored. If there is a problem, Harmony provides a short but detailed example of an execution that leads to the problem. Here is Peterson's Algorithm in Harmony, along with code to verify mutual exclusion: flags = [ False, False ] turn = choose({0, 1}) in_cs = [ False, False ] # to check mutual exclusion def process(self): # Enter critical section flags[self] = True turn = 1 - self while flags[1 - self] and (turn == (1 - self)): pass # Critical section is here in_cs[self] = True assert not in_cs[1 - self] in_cs[self] = False # Leave critical section flags[self] = False spawn process(0) spawn process(1) Harmony allows two sources of non-determinism: interleaving of concurrent process executions and choose(S) expressions that select some element from set S. Running Harmony finds that no interleaving and no possible choices lead to the assertion being violated. Moreover, Harmony also finds that processes do not get stuck, indefinitely waiting to enter the critical section. Learning programming in Harmony should be straightforward to those familiar with Python or similar languages. Harmony is described in a free book with many programming examples. Although in PDF format, the book has many hyperlinks to simplify navigation.","title":"Introduction"},{"location":"guides/introduction/#introduction","text":"Harmony is a Python-like programming language for testing and experimenting with concurrent programs. Instead of \"running\" code, Harmony programs are model-checked so that all corner cases are explored. If there is a problem, Harmony provides a short but detailed example of an execution that leads to the problem. Here is Peterson's Algorithm in Harmony, along with code to verify mutual exclusion: flags = [ False, False ] turn = choose({0, 1}) in_cs = [ False, False ] # to check mutual exclusion def process(self): # Enter critical section flags[self] = True turn = 1 - self while flags[1 - self] and (turn == (1 - self)): pass # Critical section is here in_cs[self] = True assert not in_cs[1 - self] in_cs[self] = False # Leave critical section flags[self] = False spawn process(0) spawn process(1) Harmony allows two sources of non-determinism: interleaving of concurrent process executions and choose(S) expressions that select some element from set S. Running Harmony finds that no interleaving and no possible choices lead to the assertion being violated. Moreover, Harmony also finds that processes do not get stuck, indefinitely waiting to enter the critical section. Learning programming in Harmony should be straightforward to those familiar with Python or similar languages. Harmony is described in a free book with many programming examples. Although in PDF format, the book has many hyperlinks to simplify navigation.","title":"Introduction"},{"location":"guides/running-harmony/","text":"Running your first Harmony program Coming Soon","title":"Running a program"},{"location":"guides/running-harmony/#running-your-first-harmony-program","text":"Coming Soon","title":"Running your first Harmony program"},{"location":"reference/textbook/","text":"Textbook The Harmony textbook, written by Prof. Robbert Van Renesse at Cornell University, remains the primary source of documentation for the Harmony language. It contains the documentation for the language and built-in libraries, along with a full course on concurrent programming. Download the latest version: - PDF: Link The Harmony Textbook is licenced under the terms of the Creative Commons Attribution NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) at http://creativecommons.org/licenses/by-nc-sa/4.0 .","title":"Textbook"},{"location":"reference/textbook/#textbook","text":"The Harmony textbook, written by Prof. Robbert Van Renesse at Cornell University, remains the primary source of documentation for the Harmony language. It contains the documentation for the language and built-in libraries, along with a full course on concurrent programming. Download the latest version: - PDF: Link The Harmony Textbook is licenced under the terms of the Creative Commons Attribution NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) at http://creativecommons.org/licenses/by-nc-sa/4.0 .","title":"Textbook"},{"location":"reference/language/overview/","text":"Overview This reference manual describes the syntax and \u201ccore semantics\u201d of the language. It is terse, but attempts to be exact and complete. For an informal introduction to the language, see the tutorial . Value Types 1.1. Boolean 1.2. Integer 1.3. Atom 1.4. Set 1.5. Dictionary 1.6. List or Tuple 1.7. String 1.8. Bag or Multiset 1.9. Program Counter 1.10. Address 1.11. Context Statements","title":"Overview"},{"location":"reference/language/overview/#overview","text":"This reference manual describes the syntax and \u201ccore semantics\u201d of the language. It is terse, but attempts to be exact and complete. For an informal introduction to the language, see the tutorial . Value Types 1.1. Boolean 1.2. Integer 1.3. Atom 1.4. Set 1.5. Dictionary 1.6. List or Tuple 1.7. String 1.8. Bag or Multiset 1.9. Program Counter 1.10. Address 1.11. Context Statements","title":"Overview"},{"location":"reference/language/statements/","text":"List of Statements Harmony currently supports the following statements: Statement Description lv = [lv =]... e lv is an lvalue and e is an expression lv [op] = e op is one of + , - , * , / , // , % , \\& , | , \\^ , and , and or pass do nothing del lv delete assert b [, e] b is a boolean. Optionally report value of expression e const a = e a is a bounded variable, e is a constant expression def m a: S m is an identifier, a a bounded variable, S a list of statements let a = e [let ...]: S a is a bounded variable, e is an expression, S a list of statements if b: S else: S b is a boolean, S a list of statements while b: S b is a boolean, S a list of statements await b b is a boolean for a in e: S a is a bounded variable, e is a set, S a list of statements atomic: S S a list of statements spawn me[, t] m is a method, e is an expression, t is the initial thread-local state (an expression) trap m e m is a method and e is an expression go c e c is a context, e is an expression import m, ... m identifies a module from m import ... m identifies a module","title":"Statements"},{"location":"reference/language/statements/#list-of-statements","text":"Harmony currently supports the following statements: Statement Description lv = [lv =]... e lv is an lvalue and e is an expression lv [op] = e op is one of + , - , * , / , // , % , \\& , | , \\^ , and , and or pass do nothing del lv delete assert b [, e] b is a boolean. Optionally report value of expression e const a = e a is a bounded variable, e is a constant expression def m a: S m is an identifier, a a bounded variable, S a list of statements let a = e [let ...]: S a is a bounded variable, e is an expression, S a list of statements if b: S else: S b is a boolean, S a list of statements while b: S b is a boolean, S a list of statements await b b is a boolean for a in e: S a is a bounded variable, e is a set, S a list of statements atomic: S S a list of statements spawn me[, t] m is a method, e is an expression, t is the initial thread-local state (an expression) trap m e m is a method and e is an expression go c e c is a context, e is an expression import m, ... m identifies a module from m import ... m identifies a module","title":"List of Statements"},{"location":"reference/language/value-types/","text":"Value Types Chapter 4 provides an introduction to Harmony values. Below is a complete list of Harmony value types with examples: Type Example Boolean False,True Integer -inf, ..., -2, -1, 0, 1, 2, ..., inf Atom .example,.test1,.0x4A Program Counter (method names are program counter constants) Dictionary {.account: 12345, .valid: False } Set {1, 2, 3},{ False, .id, 3} Address ?lock, ?flags[2], None Context (generated bystopexpression) Tuples, lists, strings, and bags are all special cases of dictionaries. Both tuples and lists map indexes (starting at 0) to Harmony values. Their format is either (e,e, ...,e,) or [e,e, ..., e,] . If the tuple or list has two or more elements, then the final comma is optional. A string is represented as a tuple of its characters. Characters are one-character atoms, which can be expressed in hexadecimal unicode using the syntax .0xXX . A bag or multiset is a dictionary that maps a value to how many times it occurs in the bag. All Harmony values are ordered with respect to one another. First they are ordered by type according to the table above. So, for example, True < 0 < .xyz < { 0 }) . Within types, the following rules apply: False < True ; integers are ordered in the natural way; atoms are lexicographically ordered; program counters are ordered by their integer values; dictionaries are first converted into a list of ordered (key, value) pairs. Then two dictionaries are lexicographically ordered by this representation; a set is first converted into an ordered list, then lexicographically ordered; an address is a list of atoms. None is the empty list of atoms. Addresses are lexicographically ordered accordingly; contexts (Appendix E) are ordered first by name, then by program counter, then by the remaining content. Generic operators on Harmony values include: e == e equivalence e != e inequivalence e < e, e <= e, e > e, e >= e comparison 1.1 Boolean The Boolean type has only two possible values: False and True . Unlike in Python, in Harmony booleans are distinct from integers, and in particular False < 0 . In statements and expressions where booleans are expected, it is not possible to substibute values of other types. Operations on booleans include: e and e and ... conjuction e or e or ... disjunction e => e, e not => e implication not e negation v if e else v\u2032 v or v\u2032 depending one anys, alls disjunction / conjunction for set or lists 1.2 Integer The integer type supports any whole number, as well as \u2212inf and inf . In the Python-based model checker, integers are infinite precision. In the C-based model checker, integers are implemented by two\u2019s complement 61-bit words, and \u2212inf is represented by the minimal integer and inf is represented by the maximal integer. Operations on integers include: -e negation abs(e) absolute value e + e + ... sum e - e difference e * e * e ... product e / e, e // e integer division e % e, e mod e integer division remainder e ** e power ~e binary inversion e & e & ... binary and e \\| e \\| ... binary or e ^ e ^ ... binary exclusive or e << e binary shift left e >> e binary shift right {e..e\u2032} set of integers from e to e\u2032 inclusive 1.3 Atom Atoms are essentially names and consist of one or more unicode characters. If they do not contain special characters and do not start with a digit, then an atom can be represented by a \u201c.\u201d followed by the characters. For example, .hello is a representation of the atom \u201chello\u201d. A special character can be represented by .0xXX , where XX is the hexidecimal unicode for the character. Atoms should not be confused with strings. There are no special operations on atoms. (In the future, operators may be introduced that convert between strings and atoms.) 1.4 Set In Harmony you can create a set of any collection of Harmony values. Its syntax is { v 0 , v 1 , ... }. Python users: note that in Harmony the empty set is denoted as {} . The set module (Section C.5) contains various convenient routines that operate on sets. Native operations on sets include: lens cardinality s - s set difference s & s & ... intersection s \\| s \\| ... union s ^ s ^ ... inclusion/exclusion (elements in odd number of sets) choose s select an element (Harmony will try all) mins minimum element maxs maximum element anys True if any value is True alls True if all values are True Harmony also supports set comprehension. In its simplest form, { f(v) for v in s } returns a set that is constructed by applying f to all elements in s (where s is a set or a list). This is known as mapping. But set comprehension is much more powerful and can include joining multiple sets (using nested for loops) and filtering (using the where keyword). For example: { x + y for x in s for y in s such that (x * y ) == 4 } returns a set that is constructed by summing pairs of elements from s that, when multiplied, have the value 4 . 1.5 Dictionary A dictionary maps a set of values (known as keys ) to another set of values. The generic syntax of a dictionary is { k 0 : v 0 , k 1 : v 1 , ... }. Different from Python, the empty dictionary is either () or [] (because {} is the empty set in Harmony). If there are duplicate keys in the list, then only the one with the maximum value survives. Therefore the order of the keys in the dictionary does not matter. Dictionaries support comprehension. The basic form is: { f(k) : g(k) fork in s }. There are various special cases of dictionaries, including lists, tuples, strings, and bags (multi-sets) that are individually described below. Operations on dictionaries include the following: d k indexing len d the number of keys in d keys d the set of keys in d v [not] in keys d check if v is a key in d v [not] in d check if v is a value in d min d the minimum value in d max d the maximum value in d any d True if any value is True all d True if all values are True d & d & ... dictionary intersection d \\| d \\| ... dictionary union Because in Harmony brackets are used for parsing purposes only, you can write d[k] (or d(k) ) instead of d k . However, if k is an atom, like .id , then you might prefer the notation k.id . Python users beware: the Harmony v in d operator checks if there is some key k such that d[k] = v . In Python, the same syntax checks if v is a key in d . The difference exists because in Harmony a list is a special case of a dictionary. Dictionary intersection and dictionary union are defined so that they work well with bags. With disjoint dictionaries, intersection and union work as expected. If there is a key in the intersection, then dictionary intersection retains the minimum value while dictionary union retains the maximum value. Unlike Python, Harmony dictionary intersection and union are commutative and associative. 1.6 List or Tuple In Harmony, there is no distinction between a list or a tuple. Both are a special case of dictionary. In particular, a list of n values is represented by a dictionary that maps the integers 0, ..., n\u22121 to those values. Hence, if t is a list or tuple, then the notation t[0] returns the first element of the list. You can denote a list by a sequence of values, each value terminated by a comma. As per usual, you can use brackets or parentheses at your discretion. For Python users, the important thing to note is that a singleton list in Harmony must contain a comma. For example [1,] is a list containing the value 1, while [1] is simply the value 1. The list module contains various convenient routines that operate on lists or tuples. Native operations on lists or tuples include the following: t k indexing t + t + ... concatenation t * n n copies of t concatenated v [not] in t check if v is a value in t len t the length of t min t the minimum value in t max t the maximum value in t any t True if any value is True all t True if all values are True t & t & ... pairwise list minimum t | t | ... pairwise list maximum Lists and tuples support comprehension as well. In their most basic form: f(v) for v in s . For example, to check if any element in a list t is even, you can write: any((x%2) == 0 for x in t) . 1.7 String In Harmony, a string is a list of single-character atoms. The Python string notations mostly work in Harmony as well. For example, \u2019abc\u2019 is a three-character string consisting of the atoms .a , .b , and .c . \"abc\" is the same three-character string. Various special characters (including quotes, newlines, etc.) can be escaped using a backslash. Multi-line strings can be terminated by triple quotes or triple double-quotes. Native operations on strings include the following: s k indexing s + s + ... concatenation s * n n copies of s concatenated c[not] in s check if c (a one-character atom) is in s len s the length of s 1.8 Bag or Multiset A bag is represented by a dictionary that maps each element to its multiplicity, for example: { 10:2, 12:1 }. The bag module contains various convenient routines that operate on lists or tuples. Native operations on bags include the following: v[not] in keys b check if v is in b t & t & ... bag intersection t \\| t \\| ... bag union 1.9 Program Counter A program counter is an integer that can be used to index into Harmony bytecode. When you define a method, a lambda function, or a label, you are creating a constant of the program counter type. Operations on program counters include the following: | m a | invoke method with program counter m and argument `a | | atLabel l | return a bag of (method, argument) pairs of threads executing at label l | You can create lambda functions similarly to Python. For example: lambda(x, y): x + y . 1.10 Address In Harmony, each shared variable has an address, which is essentially a list of Harmony values. For example, the address of variable d . v[3] consists of the list .d , .v , and 3 . The only way to construct an address in Harmony is using the ? operator. ?d.v[3] returns the address of variable d.v[3] . An address can be dereferenced to return the value of the variable. If a is an address, then !a returns the value. Like C, Harmony supports the shorthand a->v for the expression (!a).v . 1.11 Context A context value captures the state of a thread. A context is itself composed over various Harmony values. Some of these values can be extracted. In particular, if c is a context, then: c.name returns the name of the thread\u2019s main method c.entry returns the program counter of the thread\u2019s main method c.arg returns the argument value of the thread\u2019s main method c.this returns the thread-local state c.mode returns themodeof the context The possible modes of a context are as follows: normal context of a executing thread stopped context of a stopped thread terminated context of a terminated thread failed context of a failed thread A thread can call getcontext() to retrieve its current context. Also, the function contexts() returns a bag of all contexts (including terminated ones). Both these functions should only be called in atomic mode and used for checking invariants.","title":"Values"},{"location":"reference/language/value-types/#value-types","text":"Chapter 4 provides an introduction to Harmony values. Below is a complete list of Harmony value types with examples: Type Example Boolean False,True Integer -inf, ..., -2, -1, 0, 1, 2, ..., inf Atom .example,.test1,.0x4A Program Counter (method names are program counter constants) Dictionary {.account: 12345, .valid: False } Set {1, 2, 3},{ False, .id, 3} Address ?lock, ?flags[2], None Context (generated bystopexpression) Tuples, lists, strings, and bags are all special cases of dictionaries. Both tuples and lists map indexes (starting at 0) to Harmony values. Their format is either (e,e, ...,e,) or [e,e, ..., e,] . If the tuple or list has two or more elements, then the final comma is optional. A string is represented as a tuple of its characters. Characters are one-character atoms, which can be expressed in hexadecimal unicode using the syntax .0xXX . A bag or multiset is a dictionary that maps a value to how many times it occurs in the bag. All Harmony values are ordered with respect to one another. First they are ordered by type according to the table above. So, for example, True < 0 < .xyz < { 0 }) . Within types, the following rules apply: False < True ; integers are ordered in the natural way; atoms are lexicographically ordered; program counters are ordered by their integer values; dictionaries are first converted into a list of ordered (key, value) pairs. Then two dictionaries are lexicographically ordered by this representation; a set is first converted into an ordered list, then lexicographically ordered; an address is a list of atoms. None is the empty list of atoms. Addresses are lexicographically ordered accordingly; contexts (Appendix E) are ordered first by name, then by program counter, then by the remaining content. Generic operators on Harmony values include: e == e equivalence e != e inequivalence e < e, e <= e, e > e, e >= e comparison","title":"Value Types"},{"location":"reference/language/value-types/#11-boolean","text":"The Boolean type has only two possible values: False and True . Unlike in Python, in Harmony booleans are distinct from integers, and in particular False < 0 . In statements and expressions where booleans are expected, it is not possible to substibute values of other types. Operations on booleans include: e and e and ... conjuction e or e or ... disjunction e => e, e not => e implication not e negation v if e else v\u2032 v or v\u2032 depending one anys, alls disjunction / conjunction for set or lists","title":"1.1 Boolean"},{"location":"reference/language/value-types/#12-integer","text":"The integer type supports any whole number, as well as \u2212inf and inf . In the Python-based model checker, integers are infinite precision. In the C-based model checker, integers are implemented by two\u2019s complement 61-bit words, and \u2212inf is represented by the minimal integer and inf is represented by the maximal integer. Operations on integers include: -e negation abs(e) absolute value e + e + ... sum e - e difference e * e * e ... product e / e, e // e integer division e % e, e mod e integer division remainder e ** e power ~e binary inversion e & e & ... binary and e \\| e \\| ... binary or e ^ e ^ ... binary exclusive or e << e binary shift left e >> e binary shift right {e..e\u2032} set of integers from e to e\u2032 inclusive","title":"1.2 Integer"},{"location":"reference/language/value-types/#13-atom","text":"Atoms are essentially names and consist of one or more unicode characters. If they do not contain special characters and do not start with a digit, then an atom can be represented by a \u201c.\u201d followed by the characters. For example, .hello is a representation of the atom \u201chello\u201d. A special character can be represented by .0xXX , where XX is the hexidecimal unicode for the character. Atoms should not be confused with strings. There are no special operations on atoms. (In the future, operators may be introduced that convert between strings and atoms.)","title":"1.3 Atom"},{"location":"reference/language/value-types/#14-set","text":"In Harmony you can create a set of any collection of Harmony values. Its syntax is { v 0 , v 1 , ... }. Python users: note that in Harmony the empty set is denoted as {} . The set module (Section C.5) contains various convenient routines that operate on sets. Native operations on sets include: lens cardinality s - s set difference s & s & ... intersection s \\| s \\| ... union s ^ s ^ ... inclusion/exclusion (elements in odd number of sets) choose s select an element (Harmony will try all) mins minimum element maxs maximum element anys True if any value is True alls True if all values are True Harmony also supports set comprehension. In its simplest form, { f(v) for v in s } returns a set that is constructed by applying f to all elements in s (where s is a set or a list). This is known as mapping. But set comprehension is much more powerful and can include joining multiple sets (using nested for loops) and filtering (using the where keyword). For example: { x + y for x in s for y in s such that (x * y ) == 4 } returns a set that is constructed by summing pairs of elements from s that, when multiplied, have the value 4 .","title":"1.4 Set"},{"location":"reference/language/value-types/#15-dictionary","text":"A dictionary maps a set of values (known as keys ) to another set of values. The generic syntax of a dictionary is { k 0 : v 0 , k 1 : v 1 , ... }. Different from Python, the empty dictionary is either () or [] (because {} is the empty set in Harmony). If there are duplicate keys in the list, then only the one with the maximum value survives. Therefore the order of the keys in the dictionary does not matter. Dictionaries support comprehension. The basic form is: { f(k) : g(k) fork in s }. There are various special cases of dictionaries, including lists, tuples, strings, and bags (multi-sets) that are individually described below. Operations on dictionaries include the following: d k indexing len d the number of keys in d keys d the set of keys in d v [not] in keys d check if v is a key in d v [not] in d check if v is a value in d min d the minimum value in d max d the maximum value in d any d True if any value is True all d True if all values are True d & d & ... dictionary intersection d \\| d \\| ... dictionary union Because in Harmony brackets are used for parsing purposes only, you can write d[k] (or d(k) ) instead of d k . However, if k is an atom, like .id , then you might prefer the notation k.id . Python users beware: the Harmony v in d operator checks if there is some key k such that d[k] = v . In Python, the same syntax checks if v is a key in d . The difference exists because in Harmony a list is a special case of a dictionary. Dictionary intersection and dictionary union are defined so that they work well with bags. With disjoint dictionaries, intersection and union work as expected. If there is a key in the intersection, then dictionary intersection retains the minimum value while dictionary union retains the maximum value. Unlike Python, Harmony dictionary intersection and union are commutative and associative.","title":"1.5 Dictionary"},{"location":"reference/language/value-types/#16-list-or-tuple","text":"In Harmony, there is no distinction between a list or a tuple. Both are a special case of dictionary. In particular, a list of n values is represented by a dictionary that maps the integers 0, ..., n\u22121 to those values. Hence, if t is a list or tuple, then the notation t[0] returns the first element of the list. You can denote a list by a sequence of values, each value terminated by a comma. As per usual, you can use brackets or parentheses at your discretion. For Python users, the important thing to note is that a singleton list in Harmony must contain a comma. For example [1,] is a list containing the value 1, while [1] is simply the value 1. The list module contains various convenient routines that operate on lists or tuples. Native operations on lists or tuples include the following: t k indexing t + t + ... concatenation t * n n copies of t concatenated v [not] in t check if v is a value in t len t the length of t min t the minimum value in t max t the maximum value in t any t True if any value is True all t True if all values are True t & t & ... pairwise list minimum t | t | ... pairwise list maximum Lists and tuples support comprehension as well. In their most basic form: f(v) for v in s . For example, to check if any element in a list t is even, you can write: any((x%2) == 0 for x in t) .","title":"1.6 List or Tuple"},{"location":"reference/language/value-types/#17-string","text":"In Harmony, a string is a list of single-character atoms. The Python string notations mostly work in Harmony as well. For example, \u2019abc\u2019 is a three-character string consisting of the atoms .a , .b , and .c . \"abc\" is the same three-character string. Various special characters (including quotes, newlines, etc.) can be escaped using a backslash. Multi-line strings can be terminated by triple quotes or triple double-quotes. Native operations on strings include the following: s k indexing s + s + ... concatenation s * n n copies of s concatenated c[not] in s check if c (a one-character atom) is in s len s the length of s","title":"1.7 String"},{"location":"reference/language/value-types/#18-bag-or-multiset","text":"A bag is represented by a dictionary that maps each element to its multiplicity, for example: { 10:2, 12:1 }. The bag module contains various convenient routines that operate on lists or tuples. Native operations on bags include the following: v[not] in keys b check if v is in b t & t & ... bag intersection t \\| t \\| ... bag union","title":"1.8 Bag or Multiset"},{"location":"reference/language/value-types/#19-program-counter","text":"A program counter is an integer that can be used to index into Harmony bytecode. When you define a method, a lambda function, or a label, you are creating a constant of the program counter type. Operations on program counters include the following: | m a | invoke method with program counter m and argument `a | | atLabel l | return a bag of (method, argument) pairs of threads executing at label l | You can create lambda functions similarly to Python. For example: lambda(x, y): x + y .","title":"1.9 Program Counter"},{"location":"reference/language/value-types/#110-address","text":"In Harmony, each shared variable has an address, which is essentially a list of Harmony values. For example, the address of variable d . v[3] consists of the list .d , .v , and 3 . The only way to construct an address in Harmony is using the ? operator. ?d.v[3] returns the address of variable d.v[3] . An address can be dereferenced to return the value of the variable. If a is an address, then !a returns the value. Like C, Harmony supports the shorthand a->v for the expression (!a).v .","title":"1.10 Address"},{"location":"reference/language/value-types/#111-context","text":"A context value captures the state of a thread. A context is itself composed over various Harmony values. Some of these values can be extracted. In particular, if c is a context, then: c.name returns the name of the thread\u2019s main method c.entry returns the program counter of the thread\u2019s main method c.arg returns the argument value of the thread\u2019s main method c.this returns the thread-local state c.mode returns themodeof the context The possible modes of a context are as follows: normal context of a executing thread stopped context of a stopped thread terminated context of a terminated thread failed context of a failed thread A thread can call getcontext() to retrieve its current context. Also, the function contexts() returns a bag of all contexts (including terminated ones). Both these functions should only be called in atomic mode and used for checking invariants.","title":"1.11 Context"},{"location":"reference/library/alloc/","text":"The alloc module The alloc module supports thread-safe (but not interrupt-safe) dynamic allocation of shared memory locations. There are just two methods: Method Description malloc(v) return a pointer to a memory location initialized to v free(p) free an allocated memory location p The usage is similar to malloc and free in C.malloc() is specified to return None when running out of memory, although this is an impossible outcome in the current implementation of the module.","title":"alloc"},{"location":"reference/library/alloc/#the-alloc-module","text":"The alloc module supports thread-safe (but not interrupt-safe) dynamic allocation of shared memory locations. There are just two methods: Method Description malloc(v) return a pointer to a memory location initialized to v free(p) free an allocated memory location p The usage is similar to malloc and free in C.malloc() is specified to return None when running out of memory, although this is an impossible outcome in the current implementation of the module.","title":"The alloc module"},{"location":"reference/library/bag/","text":"The bag module The bag module has various useful methods that operate on bags or multisets: Method Description empty() returns an empty bag fromSet(s) create a bag from sets fromList(t) convert listtinto a bag count(b, e) count how many timeseoccurs in bagb bchoose(b) like choose(s) , but applied to a bag add(pb, e) add one copy of e to bag !pb remove(pb, e) remove one copy ofefrom bag !pb","title":"bag"},{"location":"reference/library/bag/#the-bag-module","text":"The bag module has various useful methods that operate on bags or multisets: Method Description empty() returns an empty bag fromSet(s) create a bag from sets fromList(t) convert listtinto a bag count(b, e) count how many timeseoccurs in bagb bchoose(b) like choose(s) , but applied to a bag add(pb, e) add one copy of e to bag !pb remove(pb, e) remove one copy ofefrom bag !pb","title":"The bag module"},{"location":"reference/library/hoare/","text":"The hoare module The hoare module implements support for Hoare-style monitors and condition variables. Method Description Monitor() return a monitor mutex enter(m) enter a monitor. m points to a monitor mutex exit(m) exit a monitor Condition() return a condition variable wait(c, m) wait on condition variable pointed to be c in monitor pointed to by m signal(c, m) signal a condition variable","title":"hoare"},{"location":"reference/library/hoare/#the-hoare-module","text":"The hoare module implements support for Hoare-style monitors and condition variables. Method Description Monitor() return a monitor mutex enter(m) enter a monitor. m points to a monitor mutex exit(m) exit a monitor Condition() return a condition variable wait(c, m) wait on condition variable pointed to be c in monitor pointed to by m signal(c, m) signal a condition variable","title":"The hoare module"},{"location":"reference/library/list/","text":"The list module The list module has various useful methods that operate on lists or tuples: Method Description subseq(t,b,f) return a slice of list t starting at index b and ending just before f append(t,e) append e to list t head(t) return the first element of list t tail(t) return all but the first element of list t reversed(t) reverse a list sorted(t) sorted set or list set(t) convert values of a dict or list into a set list(t) convert set into a list values(t) convert values of a dict into a list sorted by key items(t) convert dict into (key, value) list sorted by key enumerate(t) like Python enumerate sum(t) return the sum of all elements int qsort(t) sort list t using quicksort","title":"list"},{"location":"reference/library/list/#the-list-module","text":"The list module has various useful methods that operate on lists or tuples: Method Description subseq(t,b,f) return a slice of list t starting at index b and ending just before f append(t,e) append e to list t head(t) return the first element of list t tail(t) return all but the first element of list t reversed(t) reverse a list sorted(t) sorted set or list set(t) convert values of a dict or list into a set list(t) convert set into a list values(t) convert values of a dict into a list sorted by key items(t) convert dict into (key, value) list sorted by key enumerate(t) like Python enumerate sum(t) return the sum of all elements int qsort(t) sort list t using quicksort","title":"The list module"},{"location":"reference/library/overview/","text":"Overview While The Harmony Language Reference describes the exact syntax and semantics of the Harmony language, this library reference manual describes the standard library that is distributed with Harmony. These modules provide additional functionality and common structures that are often used in concurrent programming. alloc bag hoare list set synch","title":"Overview"},{"location":"reference/library/overview/#overview","text":"While The Harmony Language Reference describes the exact syntax and semantics of the Harmony language, this library reference manual describes the standard library that is distributed with Harmony. These modules provide additional functionality and common structures that are often used in concurrent programming. alloc bag hoare list set synch","title":"Overview"},{"location":"reference/library/set/","text":"The set module The set module implements the following methods: Method Description issubset(s, t) returns whether s is a subset of t issuperset(s, t) returns whether s is a superset of t For Python programmers: note thats <= t does not check if s is a subset of t when s and t are sets, as \u201c<=\u201d implements a total order on all Harmony values including sets.","title":"set"},{"location":"reference/library/set/#the-set-module","text":"The set module implements the following methods: Method Description issubset(s, t) returns whether s is a subset of t issuperset(s, t) returns whether s is a superset of t For Python programmers: note thats <= t does not check if s is a subset of t when s and t are sets, as \u201c<=\u201d implements a total order on all Harmony values including sets.","title":"The set module"},{"location":"reference/library/synch/","text":"The synch module The synch module provides the following methods: Method Description tas(lk) test-and-set on !lk BinSem(v) return a binary semaphore initialized to v Lock() return a binary semaphore initialized to False acquire(bs) acquire binary semaphore !bs release(bs) release binary semaphore !bs Condition() return a condition variable wait(c, lk) wait on condition variable !c and lock lk notify(c) notify a thread waiting on condition variable !c notifyAll(c) notify all threads waiting on condition variable !c Semaphore(cnt) return a counting semaphore initialized to cnt P(sema) procure !sema V(sema) vacate !sema Queue() return a synchronized queue object get(q) return next element of q , blocking if empty put(q, item) add item to a","title":"synch"},{"location":"reference/library/synch/#the-synch-module","text":"The synch module provides the following methods: Method Description tas(lk) test-and-set on !lk BinSem(v) return a binary semaphore initialized to v Lock() return a binary semaphore initialized to False acquire(bs) acquire binary semaphore !bs release(bs) release binary semaphore !bs Condition() return a condition variable wait(c, lk) wait on condition variable !c and lock lk notify(c) notify a thread waiting on condition variable !c notifyAll(c) notify all threads waiting on condition variable !c Semaphore(cnt) return a counting semaphore initialized to cnt P(sema) procure !sema V(sema) vacate !sema Queue() return a synchronized queue object get(q) return next element of q , blocking if empty put(q, item) add item to a","title":"The synch module"}]}
{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Harmony Our online documentation is still a work in progress. For more complete documentation see the textbook . Overview Quick Start - Get started with Harmony. Language Reference - Language features and syntax. Library Reference - Built in modules and libraries. Changelog - What's new in Harmony 1.0.","title":"Overview"},{"location":"#harmony","text":"Our online documentation is still a work in progress. For more complete documentation see the textbook .","title":"Harmony"},{"location":"#overview","text":"Quick Start - Get started with Harmony. Language Reference - Language features and syntax. Library Reference - Built in modules and libraries. Changelog - What's new in Harmony 1.0.","title":"Overview"},{"location":"changelog/","text":"Changelog v1.1 Now detects busy waiting and data races New sequential keyword to tag sequentially consistent variables v1.0 Rewrote model checker in C for much faster performance Removed semicolons as a syntax requirement Updated imports syntax Requires Python3 and GCC in path to run v0.9 Initial release of the Harmony Language Model checker for concurrent programs HTML output with steps and shortest path to failure Required Python3 to run","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v11","text":"Now detects busy waiting and data races New sequential keyword to tag sequentially consistent variables","title":"v1.1"},{"location":"changelog/#v10","text":"Rewrote model checker in C for much faster performance Removed semicolons as a syntax requirement Updated imports syntax Requires Python3 and GCC in path to run","title":"v1.0"},{"location":"changelog/#v09","text":"Initial release of the Harmony Language Model checker for concurrent programs HTML output with steps and shortest path to failure Required Python3 to run","title":"v0.9"},{"location":"guides/installation/","text":"Installation Requirements The Harmony compiler requires both Python 3 and the GCC compiler. Both must be on your PATH environment variable for Harmony to function. The Harmony team also offers remote compilation and analysis solutions that do not require any downloads. Try out the online IDE here: https://harmony.cs.cornell.edu/ide/ MacOS and Linux Download and install Python 3 Open terminal and verify that the python3 command works If not, add export PATH=/usr/local/share/python:$PATH to your ~/.bash_profile and/or ~/.zshrc Open terminal and verify that the gcc command works If not, install GCC, either through Homebrew on Mac ( brew install gcc ) or apt-get on Ubuntu and other distros ( sudo apt-get install build-essential ) Windows Download and install Python 3 Open terminal and verify that the python3 command works If not, add your python install directory to your PATH Install GCC (http://mingw-w64.org/doku.php). At the Settings window, make sure you select the x86-64 architecture (instead of the default i686) during installation After installation is complete, add {installation path}\\mingw64\\bin to your PATH environment variable Open CMD and verify that the gcc command works Compiler Only Download and unzip the Harmony compiler Add harmony's directory to your PATH environment variable see http://www.linux-migration.org/ch02s06.html If you run harmony in the harmony directory, you may have to run \"./harmony [args ...]\" instead of just \"harmony [args ...]\" HarmonyLang - VSCode Extension Download and Install Visual Studio Code Install the HarmonyLang extension from the Extension Marketplace","title":"Installation"},{"location":"guides/installation/#installation","text":"","title":"Installation"},{"location":"guides/installation/#requirements","text":"The Harmony compiler requires both Python 3 and the GCC compiler. Both must be on your PATH environment variable for Harmony to function. The Harmony team also offers remote compilation and analysis solutions that do not require any downloads. Try out the online IDE here: https://harmony.cs.cornell.edu/ide/","title":"Requirements"},{"location":"guides/installation/#macos-and-linux","text":"Download and install Python 3 Open terminal and verify that the python3 command works If not, add export PATH=/usr/local/share/python:$PATH to your ~/.bash_profile and/or ~/.zshrc Open terminal and verify that the gcc command works If not, install GCC, either through Homebrew on Mac ( brew install gcc ) or apt-get on Ubuntu and other distros ( sudo apt-get install build-essential )","title":"MacOS and Linux"},{"location":"guides/installation/#windows","text":"Download and install Python 3 Open terminal and verify that the python3 command works If not, add your python install directory to your PATH Install GCC (http://mingw-w64.org/doku.php). At the Settings window, make sure you select the x86-64 architecture (instead of the default i686) during installation After installation is complete, add {installation path}\\mingw64\\bin to your PATH environment variable Open CMD and verify that the gcc command works","title":"Windows"},{"location":"guides/installation/#compiler-only","text":"Download and unzip the Harmony compiler Add harmony's directory to your PATH environment variable see http://www.linux-migration.org/ch02s06.html If you run harmony in the harmony directory, you may have to run \"./harmony [args ...]\" instead of just \"harmony [args ...]\"","title":"Compiler Only"},{"location":"guides/installation/#harmonylang-vscode-extension","text":"Download and Install Visual Studio Code Install the HarmonyLang extension from the Extension Marketplace","title":"HarmonyLang - VSCode Extension"},{"location":"guides/introduction/","text":"Introduction Harmony is a Python-like programming language for testing and experimenting with concurrent programs. Instead of \"running\" code, Harmony programs are model-checked so that all corner cases are explored. If there is a problem, Harmony provides a short but detailed example of an execution that leads to the problem. Here is Peterson's Algorithm in Harmony, along with code to verify mutual exclusion: sequential flags, turn flags = [ False, False ] turn = choose({0, 1}) def thread(self): while choose({ False, True }): # Enter critical section flags[self] = True turn = 1 - self await (not flags[1 - self]) or (turn == self) # critical section is here @cs: assert atLabel(cs) == { (thread, self): 1 } # Leave critical section flags[self] = False spawn thread(0) spawn thread(1) Try out the algorithm above in the IDE! Harmony allows two sources of non-determinism: interleaving of concurrent process executions and choose(S) expressions that select some element from set S. Running Harmony finds that no interleaving and no possible choices lead to the assertion being violated. Moreover, Harmony also finds that processes do not get stuck, indefinitely waiting to enter the critical section. Learning programming in Harmony should be straightforward to those familiar with Python or similar languages. Harmony is described in a free book with many programming examples. Although in PDF format, the book has many hyperlinks to simplify navigation.","title":"Introduction"},{"location":"guides/introduction/#introduction","text":"Harmony is a Python-like programming language for testing and experimenting with concurrent programs. Instead of \"running\" code, Harmony programs are model-checked so that all corner cases are explored. If there is a problem, Harmony provides a short but detailed example of an execution that leads to the problem. Here is Peterson's Algorithm in Harmony, along with code to verify mutual exclusion: sequential flags, turn flags = [ False, False ] turn = choose({0, 1}) def thread(self): while choose({ False, True }): # Enter critical section flags[self] = True turn = 1 - self await (not flags[1 - self]) or (turn == self) # critical section is here @cs: assert atLabel(cs) == { (thread, self): 1 } # Leave critical section flags[self] = False spawn thread(0) spawn thread(1) Try out the algorithm above in the IDE! Harmony allows two sources of non-determinism: interleaving of concurrent process executions and choose(S) expressions that select some element from set S. Running Harmony finds that no interleaving and no possible choices lead to the assertion being violated. Moreover, Harmony also finds that processes do not get stuck, indefinitely waiting to enter the critical section. Learning programming in Harmony should be straightforward to those familiar with Python or similar languages. Harmony is described in a free book with many programming examples. Although in PDF format, the book has many hyperlinks to simplify navigation.","title":"Introduction"},{"location":"guides/running-harmony/","text":"Running your first Harmony program Harmony is a programming language that borrows much of Python's syntax. Like Python, Harmony is an imperative, dynamically typed, and garbage collected programming language. There are also some important differences : - Harmony only supports basic operator precedence or associativity. Use parentheses liberally to remove ambiguity. Harmony does not (currently) support floating point, iterators, or I/O; Harmony does support for loops and various \"comprehensions.\" Python is object-oriented, supporting classes with methods and inheritance; Harmony has objects but does not support classes. On the other hand, Harmony supports pointers to objects and methods. There are also less important ones that you will discover as you get more familiar with programming in Harmony. The code below shows a simple example of a Harmony program. const N = 10 def triangle(n): # computes the n'th triangle number result = 0 for i in {1..n}: # for each integer from 1 to n inclusive result += i # add i to result x = choose({0..N}) # select an x between 0 and N inclusive assert triangle(x) == ((x * (x + 1)) / 2) Try out the algorithm above in the IDE! The example is sequential and has a method triangle that takes an integer number as argument. Each method has a variable called result that eventually contains the result of the method (there is no return statement in Harmony). The method also has a variable called n containing the value of the argument. The { x..y } notation generates a set containing the numbers from x to y (inclusive). (Harmony does not have iterators and in particular does not have a range operator.) The last two lines in the program are the most interesting. The first assigns to x some unspecified value in the range 0..N and the second verifies that triangle( x ) equals x ( x + 1) / 2. \"Running\" this Harmony program will try all possible executions, which includes all possible values for x . Try it out (here $ represents a shell prompt): Essentially, the choose(S) operator provides the input to the program by selecting some value from the set S , while the assert statement checks that the output is correct. If the program is correct, the output of Harmony is the size of the \"state graph\" (13 states in this case). If not, Harmony also reports what went wrong, typically by displaying a summary of an execution in which something went wrong. Play around! See what happens if, instead of initializing result to 0, you initialize it to 1. Write a Harmony program that computes squares by repeated adding. So the program should compute the square of x by adding x to an initial value of 0 x times.","title":"Running a program"},{"location":"guides/running-harmony/#running-your-first-harmony-program","text":"Harmony is a programming language that borrows much of Python's syntax. Like Python, Harmony is an imperative, dynamically typed, and garbage collected programming language. There are also some important differences : - Harmony only supports basic operator precedence or associativity. Use parentheses liberally to remove ambiguity. Harmony does not (currently) support floating point, iterators, or I/O; Harmony does support for loops and various \"comprehensions.\" Python is object-oriented, supporting classes with methods and inheritance; Harmony has objects but does not support classes. On the other hand, Harmony supports pointers to objects and methods. There are also less important ones that you will discover as you get more familiar with programming in Harmony. The code below shows a simple example of a Harmony program. const N = 10 def triangle(n): # computes the n'th triangle number result = 0 for i in {1..n}: # for each integer from 1 to n inclusive result += i # add i to result x = choose({0..N}) # select an x between 0 and N inclusive assert triangle(x) == ((x * (x + 1)) / 2) Try out the algorithm above in the IDE! The example is sequential and has a method triangle that takes an integer number as argument. Each method has a variable called result that eventually contains the result of the method (there is no return statement in Harmony). The method also has a variable called n containing the value of the argument. The { x..y } notation generates a set containing the numbers from x to y (inclusive). (Harmony does not have iterators and in particular does not have a range operator.) The last two lines in the program are the most interesting. The first assigns to x some unspecified value in the range 0..N and the second verifies that triangle( x ) equals x ( x + 1) / 2. \"Running\" this Harmony program will try all possible executions, which includes all possible values for x . Try it out (here $ represents a shell prompt): Essentially, the choose(S) operator provides the input to the program by selecting some value from the set S , while the assert statement checks that the output is correct. If the program is correct, the output of Harmony is the size of the \"state graph\" (13 states in this case). If not, Harmony also reports what went wrong, typically by displaying a summary of an execution in which something went wrong.","title":"Running your first Harmony program"},{"location":"guides/running-harmony/#play-around","text":"See what happens if, instead of initializing result to 0, you initialize it to 1. Write a Harmony program that computes squares by repeated adding. So the program should compute the square of x by adding x to an initial value of 0 x times.","title":"Play around!"},{"location":"reference/textbook/","text":"Textbook The Harmony textbook, written by Prof. Robbert Van Renesse at Cornell University, remains the primary source of documentation for the Harmony language. It contains the documentation for the language and built-in libraries, along with a full course on concurrent programming. Download the latest version: - PDF: Link The Harmony Textbook is licenced under the terms of the Creative Commons Attribution NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) at http://creativecommons.org/licenses/by-nc-sa/4.0 .","title":"Textbook"},{"location":"reference/textbook/#textbook","text":"The Harmony textbook, written by Prof. Robbert Van Renesse at Cornell University, remains the primary source of documentation for the Harmony language. It contains the documentation for the language and built-in libraries, along with a full course on concurrent programming. Download the latest version: - PDF: Link The Harmony Textbook is licenced under the terms of the Creative Commons Attribution NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) at http://creativecommons.org/licenses/by-nc-sa/4.0 .","title":"Textbook"},{"location":"reference/language/contexts-threads/","text":"Contexts and Threads A context captures the state of a thread. Each time the thread executes an instruction, it goes from one context to another. All instructions update the program counter ( Jump instructions are not allowed to jump to their own locations), and so no instruction leaves the context the same. There may be multiple threads with the same state at the same time. A context consists of the following: Variable Description name the name of the main method that the thread is executing argument the argument given to the main method program counter an integer value pointing into the code frame pointer an integer value pointing into the stack atomic if non-zero, the thread is in atomic mode readonly if non-zero, the thread is in read-only mode stack a list of Harmony values method variables a dictionary mapping atoms (names of method variables) to values thread-local variables a dictionary mapping atoms (names of thread-local variables) to values stopped a boolean indicating if the context is stopped failure if not None, string that describes how the thread failed Details The frame pointer points to the current stack frame , which consists of the caller's frame pointer and variables, the argument to the method, an \"invocation type atom\" ( normal , interrupt , or thread ), and the return address (in case of normal ). A thread terminates when it reaches the Return instruction of the top-level method (when the stack frame is of type thread ) or when it hits an exception. Exceptions include divide by zero, reading a non-existent key in a dictionary, accessing a non-existent variable, as well as when an assertion fails; The execution of a thread in atomic mode does not get interleaved with that of other threads. The execution of a thread in read-only mode is not allowed to update shared variables of spawn threads. The register of a thread always contains a dictionary, mapping atoms to arbitrary values. The atoms correspond to the variable names in a Harmony program.","title":"Contexts and Threads"},{"location":"reference/language/contexts-threads/#contexts-and-threads","text":"A context captures the state of a thread. Each time the thread executes an instruction, it goes from one context to another. All instructions update the program counter ( Jump instructions are not allowed to jump to their own locations), and so no instruction leaves the context the same. There may be multiple threads with the same state at the same time. A context consists of the following: Variable Description name the name of the main method that the thread is executing argument the argument given to the main method program counter an integer value pointing into the code frame pointer an integer value pointing into the stack atomic if non-zero, the thread is in atomic mode readonly if non-zero, the thread is in read-only mode stack a list of Harmony values method variables a dictionary mapping atoms (names of method variables) to values thread-local variables a dictionary mapping atoms (names of thread-local variables) to values stopped a boolean indicating if the context is stopped failure if not None, string that describes how the thread failed","title":"Contexts and Threads"},{"location":"reference/language/contexts-threads/#details","text":"The frame pointer points to the current stack frame , which consists of the caller's frame pointer and variables, the argument to the method, an \"invocation type atom\" ( normal , interrupt , or thread ), and the return address (in case of normal ). A thread terminates when it reaches the Return instruction of the top-level method (when the stack frame is of type thread ) or when it hits an exception. Exceptions include divide by zero, reading a non-existent key in a dictionary, accessing a non-existent variable, as well as when an assertion fails; The execution of a thread in atomic mode does not get interleaved with that of other threads. The execution of a thread in read-only mode is not allowed to update shared variables of spawn threads. The register of a thread always contains a dictionary, mapping atoms to arbitrary values. The atoms correspond to the variable names in a Harmony program.","title":"Details"},{"location":"reference/language/harmony-vm/","text":"The Harmony Virtual Machine The Harmony Virtual Machine (HVM) has the following state: State Description code a list of HVM machine instructions labels a dictionary of atoms to program counters variables a dictionary mapping atoms to values ctxbag a bag of runnable contexts stopbag a bag of stopped contexts choosing if not None, indicates a context that is choosing There is initially a single context with name __init__/() and program counter 0. It starts executing in atomic mode until it finishes executing the last Return instruction. Other threads, created through spawn statements, do not start executing until then. A step is the execution of a single HVM machine instruction by a context. Each step generates a new state. When there are multiple contexts, the HVM can interleave them. However, trying to interleave every step would be needlessly expensive, as many steps involve changes to a context that are invisible to other contexts. A stride can involve multiple steps. The following instructions start a new stride: Load , Store , AtomicInc , and Continue . The HVM interleaves stides, not steps. Like steps, each stride involves a single context. Unlike a step, a stride can leave the state unchanged (because its steps lead back to where the stride started). Executing a Harmony program results in a graph where the nodes are Harmony states and the edges are strides. When a state is choosing , the edges from that state are by a single context, one for each choice. If not, the edges from the state are one per context. Consecutive strides by the same thread are called a turn . Each state maintains the shortest path to it from the initial state in terms of turns. The diameter of the graph is the length of the longest path found in terms of turns. If some states have a problem, the state with the shortest path is reported. Problematic states include states that experienced exceptions. If there are no exceptions, Harmony computes the strongly connected components (SCCs) of the graph (the number of such components are printed as part of the output). The sink SCCs should each consist of a terminal state without any threads. If not, again the state with the shortest path is reported. If there are no problematic states, Harmony reports \"no issues found\" and outputs in the HTML file the state with the longest path.","title":"The Harmony VM"},{"location":"reference/language/harmony-vm/#the-harmony-virtual-machine","text":"The Harmony Virtual Machine (HVM) has the following state: State Description code a list of HVM machine instructions labels a dictionary of atoms to program counters variables a dictionary mapping atoms to values ctxbag a bag of runnable contexts stopbag a bag of stopped contexts choosing if not None, indicates a context that is choosing There is initially a single context with name __init__/() and program counter 0. It starts executing in atomic mode until it finishes executing the last Return instruction. Other threads, created through spawn statements, do not start executing until then. A step is the execution of a single HVM machine instruction by a context. Each step generates a new state. When there are multiple contexts, the HVM can interleave them. However, trying to interleave every step would be needlessly expensive, as many steps involve changes to a context that are invisible to other contexts. A stride can involve multiple steps. The following instructions start a new stride: Load , Store , AtomicInc , and Continue . The HVM interleaves stides, not steps. Like steps, each stride involves a single context. Unlike a step, a stride can leave the state unchanged (because its steps lead back to where the stride started). Executing a Harmony program results in a graph where the nodes are Harmony states and the edges are strides. When a state is choosing , the edges from that state are by a single context, one for each choice. If not, the edges from the state are one per context. Consecutive strides by the same thread are called a turn . Each state maintains the shortest path to it from the initial state in terms of turns. The diameter of the graph is the length of the longest path found in terms of turns. If some states have a problem, the state with the shortest path is reported. Problematic states include states that experienced exceptions. If there are no exceptions, Harmony computes the strongly connected components (SCCs) of the graph (the number of such components are printed as part of the output). The sink SCCs should each consist of a terminal state without any threads. If not, again the state with the shortest path is reported. If there are no problematic states, Harmony reports \"no issues found\" and outputs in the HTML file the state with the longest path.","title":"The Harmony Virtual Machine"},{"location":"reference/language/machine-instructions/","text":"List of Machine Instructions Instruction Description Address compute address from two components Apply pop m and i and apply i to m , pushing a value Assert, Assert2 pop b and check that it is True. Assert2 also pops value to print AtomicInc/Dec increment/decrement the atomic counter of this context Continue no-op (but causes a context switch) Choose choose an element from the set on top of the stack Cut cut a set into its smallest element and the remainder Del [v] delete shared variable v DelVar [v] delete thread variable v Dup duplicate the top element of the stack Frame m a start method m with arguments a , initializing variables. Go pop context and value, push value on context's stack, and add to context bag IncVar v increment thread variable v Jump p set program counter to p JumpCond e p pop expression and, if equal to e , set program counter to p Load [v] push the value of a shared variable onto the stack LoadVar [v] push the value of a thread variable onto the stack Move i move stack element at offset i to top of the stack n-ary op apply n -ary operator op to the top n elements on the stack Pop pop a value of the stack and discard it Push c push constant c onto the stack ReadonlyInc/Dec increment/decrement the read-only counter of this context Return pop return address, push result, and restore program counter Sequential pop an address of a variable that has sequential consistency SetIntLevel pop e , set interrupt level to e , and push old interrupt level Spawn pop initial thread-local state, argument, and method and spawn a new context Split pop tuple and push its elements Stop [v] save context into shared variable v and remove from context bag Store [v] pop a value from the stack and store it in a shared variable StoreVar [v] pop a value from the stack and store it in a thread variable Trap pop interrupt argument and method Clarifications The Address instruction expects two values on the stack. The top value must be an address value, representing a dictionary The other value must be a key into the dictionary. The instruction then computes the address of the given key. Even though Harmony code does not allow taking addresses of thread variables, both shared and thread variables can have addresses. The Load , LoadVar , Del , DelVar , and Stop instructions have an optional variable name: if omitted the top of the stack must contain the address of the variable. Store and StoreVar instructions have an optional variable name. In both cases the value to be assigned is on the top of the stack. If the name is omitted, the address is underneath that value on the stack. The effect of the Apply instructions depends much on m . If m is a dictionary, then Apply finds i in the dictionary and pushes the value. If m is a program counter, then Apply invokes method m by pushing the current program counter and setting the program counter to m . m is supposed to leave the result on the stack. The Frame instruction pushes the value of the thread register ( i.e. , the values of the thread variables) onto the stack. It initializes the result variable to the empty dictionary. The Return instruction restores the thread register by popping its value of the stack. All method calls have exactly one argument, although it sometimes appears otherwise: m() invokes method m with the empty dictionary () as argument m(a) invokes method m with argument a m(a, b, c) invokes method m with tuple ( a , b , c ) as argument The Frame instruction unpacks the argument to the method and places them into thread variables by the given names. Every Stop instruction must immediately be followed by a Continue instruction.","title":"Machine Instructions"},{"location":"reference/language/machine-instructions/#list-of-machine-instructions","text":"Instruction Description Address compute address from two components Apply pop m and i and apply i to m , pushing a value Assert, Assert2 pop b and check that it is True. Assert2 also pops value to print AtomicInc/Dec increment/decrement the atomic counter of this context Continue no-op (but causes a context switch) Choose choose an element from the set on top of the stack Cut cut a set into its smallest element and the remainder Del [v] delete shared variable v DelVar [v] delete thread variable v Dup duplicate the top element of the stack Frame m a start method m with arguments a , initializing variables. Go pop context and value, push value on context's stack, and add to context bag IncVar v increment thread variable v Jump p set program counter to p JumpCond e p pop expression and, if equal to e , set program counter to p Load [v] push the value of a shared variable onto the stack LoadVar [v] push the value of a thread variable onto the stack Move i move stack element at offset i to top of the stack n-ary op apply n -ary operator op to the top n elements on the stack Pop pop a value of the stack and discard it Push c push constant c onto the stack ReadonlyInc/Dec increment/decrement the read-only counter of this context Return pop return address, push result, and restore program counter Sequential pop an address of a variable that has sequential consistency SetIntLevel pop e , set interrupt level to e , and push old interrupt level Spawn pop initial thread-local state, argument, and method and spawn a new context Split pop tuple and push its elements Stop [v] save context into shared variable v and remove from context bag Store [v] pop a value from the stack and store it in a shared variable StoreVar [v] pop a value from the stack and store it in a thread variable Trap pop interrupt argument and method","title":"List of Machine Instructions"},{"location":"reference/language/machine-instructions/#clarifications","text":"The Address instruction expects two values on the stack. The top value must be an address value, representing a dictionary The other value must be a key into the dictionary. The instruction then computes the address of the given key. Even though Harmony code does not allow taking addresses of thread variables, both shared and thread variables can have addresses. The Load , LoadVar , Del , DelVar , and Stop instructions have an optional variable name: if omitted the top of the stack must contain the address of the variable. Store and StoreVar instructions have an optional variable name. In both cases the value to be assigned is on the top of the stack. If the name is omitted, the address is underneath that value on the stack. The effect of the Apply instructions depends much on m . If m is a dictionary, then Apply finds i in the dictionary and pushes the value. If m is a program counter, then Apply invokes method m by pushing the current program counter and setting the program counter to m . m is supposed to leave the result on the stack. The Frame instruction pushes the value of the thread register ( i.e. , the values of the thread variables) onto the stack. It initializes the result variable to the empty dictionary. The Return instruction restores the thread register by popping its value of the stack. All method calls have exactly one argument, although it sometimes appears otherwise: m() invokes method m with the empty dictionary () as argument m(a) invokes method m with argument a m(a, b, c) invokes method m with tuple ( a , b , c ) as argument The Frame instruction unpacks the argument to the method and places them into thread variables by the given names. Every Stop instruction must immediately be followed by a Continue instruction.","title":"Clarifications"},{"location":"reference/language/overview/","text":"Overview This reference manual describes the syntax and \u201ccore semantics\u201d of the language. It is terse, but attempts to be exact and complete. For an informal introduction to the language, see the tutorial . Value Types 1.1. Boolean 1.2. Integer 1.3. Atom 1.4. Set 1.5. Dictionary 1.6. List or Tuple 1.7. String 1.8. Bag or Multiset 1.9. Program Counter 1.10. Address 1.11. Context Statements Machine Instructions Contexts & Threads The Harmony VM Harmony Language Details The Harmony language borrows heavily from Python. However, there are some important differences that we will describe below. Harmony is not object-oriented Python is object-oriented, but Harmony is not. This can lead to some unexpected differences. For example, consider the following code: x = y = [ 1, 2 ] x[0] = 3 assert y[0] == 1 In Python, lists are objects. Thus x and y point to the same list, and the assertion would fail if executed by Python. In Harmony, lists are values. So when x is updated in Line 2, it does not affect the value of y . The assertion succeeds. Harmony supports references to values, allowing programs to implement shared objects. Because Harmony does not have objects, it also does not have object methods. However, Harmony methods and lambdas are program counter constants. These constants can be added to dictionaries. For example, in PetersonMethod.hny you can add the P enter and P exit methods to the { .turn: 0, .flags: [ False, False ], .enter: P_enter, .exit: P_exit } That would allow you to simulate object methods. There are at least two reasons why Harmony is not object-oriented. First, object-orientation often adds layers of indirection that would make it harder to model check and also to interpret the results. Consider, for example, a lock. In Python, a lock is an object. A lock variable would contain a reference to a lock object. In Harmony, a lock variable contains the value of the lock itself. Thus, the following statement means something quite different in Python and Harmony: x = y = Lock(); In Python, this creates two variables x and y referring to the same lock. In Harmony, the two variables will be two different locks. If you want two variables referring to the same lock in Harmony, you would write: x = y = malloc(Lock()); The second reason for Harmony not being object-oriented is that many concurrency solutions in the literature are expressed in C or some other low-level language that does not support objectorientation, but instead use malloc and free. Constants, Global and Local Variables Each (non-reserved) identifier in a Harmony program refers to either a constant, a global variable, or a local variable. Constants are declared using const statements. Those constants are computed at compile-time. Local variables all declared. They can be declared in def statements (i.e., arguments), let statements, and in for loops. Also, each method has an implicitly declared result variable. Local variables are tightly scoped and cannot be shared between threads. While in theory one method can be declared within another, they cannot share variables either. All other variables are global and must be initialized before any threads are spawned. While arguments to a method and variables in for loops can be modified, we discourage it for improved code readability. Operator Precedence In Harmony, there is no syntactic difference between applying an argument to a function or an index to a dictionary. Both use the syntax a b c ... . We call this application , and application is left-associative. So a b c is interpreted as ( a b ) c : b is applied to a , and then c is applied to the result. For readability, it may help to write a ( b ) for function application and a [ b ] for indexing. In case b is an atom, you can also write a.b for indexing. There are three classes of precedence. Application has the highest precedence. So ! a b is interpreted as !( a b ) and a b + c d is interpreted as ( a b ) + ( c d ). Unary operators have the next highest precedence, and the remaining operators have the lowest precedence. So -2 + 3 evaluates to 1, not -5. Associative operators (+, \u2217, |, &, \u02c6, and , or ) are interpreted as general n -ary operators, and you are allowed to write a + b + c . However, a - b - c is illegal, as is any combination of operators with an arity larger than one, such as a + b < c . In such cases you have to add parentheses or brackets to indicate what the intended evaluation order is, such as ( a + b ) < c . In almost all expressions, subexpressions are evaluated left to right. So a [ b ] + c first evaluates a , then b (and then applies b to a ), and then c . The one exception is the expression a if c else b , where c is evaluated first. In that expression, only a or b is evaluated depending on the value of c . In the expression a and b and ... , evaluation is left to right but stops once one of the subexpressions evaluates to False . Similarly for or , where evaluation stops once one of the subexpressions evaluates to True. A sequence of comparison operations, such as a < b < c , is evaluated left to right but stops as soon as one of the comparisons fails. As an aside: the expression a not in b is equivalent to not ( a in b ). Harmony generalizes this construct for any pair of a unary (except '-') and a binary operator. In particular, a not and b is the same as not ( a and b ). For those familiar with logic gates, not and is the equivalent of NAND. Similarly, not = > is non-implication. Tuples, Lists, and Pattern Matching Harmony's tuples and, equivalently, lists, are just special cases of dictionaries. They can be bracketed either by '(' and ')' or by '[' and ']', but the brackets are often optional. Importantly, with a singleton list, the one element must be followed by a comma. So the statement x = 1,; assigns a singleton tuple (or list) to x . Because tuples and lists are dictionaries, the del statement is different from Python. For example, if x = [.a, .b, .c], then del x [1] results in x = { 0:.a, 2:.c }, not x = [.a, .c]. Harmony also does not support special slicing syntax like Python. To modify lists, use the subseq method in the list module . Harmony allows pattern matching against nested tuples in various language constructs. The following are the same in Python and Harmony: x, = 1,: assigns 1 to x ; x , y = 1, (2, 3): assigns 1 to x and (2, 3) to y ; x , ( y , z ) = 1, (2, 3): assigns 1 to x , 2 to y , and 3 to z ; x , ( y , z ) = 1, 2; generates an runtime error because 2 cannot be matched with ( y , z ); x [0], x [1] = x [1], x [0]; swaps the first two elements of list x . As in Python, pattern matching can also be used in for statements. For example: for key, value in [ (1, 2), (3, 4) ]: ... Harmony (but not Python) also allows pattern matching in defining and invoking methods. For example, you can write: def f[a, (b, c)]: ... and then call f[1, (2, 3)]. Note that the more familiar: def g( a ) defines a method g with a single argument a . Invoking g(1, 2) would assign the tuple (1, 2) to a . This is not consistent with Python syntax. For single argument methods, you may want to declare as follows: def g( a, ). Calling g(1,) assigns 1 to a , while calling g(1, 2) would result in a runtime error as (1, 2) cannot be matched with ( a ,). Pattern matching can also be used in const and let statements. from stack import Stack, push, pop teststack = Stack() push(?teststack, 1) push(?teststack, 2) v = pop(?teststack) assert v == 2 push(?teststack, 3) v = pop(?teststack) assert v == 3 v = pop(?teststack) assert v == 1 Try out the stack implementation above in the IDE! For Loops and Comprehensions While Harmony does not support general iterators such as Python does, Harmony allows iterating over sets and dictionaries (and thus lists and tuples). The details are a little different from Python: When iterating over a set, the set is always traversed in order ; In case of a dictionary, the iteration is over the values of the dictionary, but in the order of the keys. In the case of lists, this works much the same as in Python, but in the case of general dictionaries, Python iterates over the keys rather than the values; If you want to iterate over the keys of a dictionary d , use for k inkeys d ; The list module provides methods values(), items(), enumerate(), and reversed() for other types of iteration supported by Python. Harmony supports nesting and filtering in for loops. For example: for i in { 1..10 } for j in { 1..10 } where i < j: ... Harmony also supports set, list, and dictionary comprehensions. Comprehensions are similar to Python, except that filtering uses the keyword where instead of if. Dynamic Allocation Harmony supports various options for dynamic allocation. By way of example, consider a stack. The code below presents a test program for a stack. We present four different stack implementations to illustrate options for dynamic allocation: from stack import Stack, push, pop teststack = Stack() push(?teststack, 1) push(?teststack, 2) v = pop(?teststack) assert v == 2 push(?teststack, 3) v = pop(?teststack) assert v == 3 v = pop(?teststack) assert v == 1 Try out the stack implementation above in the IDE! Dynamically Updated List The code below uses a single list to represent the stack. It is updated to perform push and pop operations. def Stack(): result = [ ] def push(st, v): (!st)[len(!st)] = v def pop(st): let n = len(!st) \u2013 1: result = (!st)[n] del (!st)[n] Try out the stack implementation above in the IDE! Static List The code below also uses a list but, instead of updating the list, it replaces the list with a new one for each operation. import list def Stack(): result = [] def push(st, v): !st += [v,] def pop(st): let n = len(!st) - 1: result = (!st)[n] !st = list.subseq(!st, 0, n) Try out the stack implementation above in the IDE! Recursive Tuple The code below represents a stack as a recursively nested tuple ( v,f ), where v is the element on top of the stack and r is a stack that is the remainder. def Stack(): result = () def push(st, v): (!st) = (v, !st) def pop(st): let (top, rest) = !st: result = top !st = rest Try out the stack implementation above in the IDE! Linked List The code below implements a stack as a linked list with nodes allocated using the alloc module. from alloc import malloc, free def Stack(): result = None def push(st, v): !st = malloc({ .value: v, .rest: !st }) def pop(st): let node = !st: result = node->value !st = node->rest free(node) Try out the stack implementation above in the IDE! While the last option is the most versatile (it allows cyclic data structures), Harmony does not support garbage collection for memory allocated this way and so allocated memory that is no longer in use must be explicitly released using free. Comments Harmony supports the same commenting conventions as Python. In addition, Harmony supports nested multi-line comments of the form (* comment *) .","title":"Overview"},{"location":"reference/language/overview/#overview","text":"This reference manual describes the syntax and \u201ccore semantics\u201d of the language. It is terse, but attempts to be exact and complete. For an informal introduction to the language, see the tutorial . Value Types 1.1. Boolean 1.2. Integer 1.3. Atom 1.4. Set 1.5. Dictionary 1.6. List or Tuple 1.7. String 1.8. Bag or Multiset 1.9. Program Counter 1.10. Address 1.11. Context Statements Machine Instructions Contexts & Threads The Harmony VM","title":"Overview"},{"location":"reference/language/overview/#harmony-language-details","text":"The Harmony language borrows heavily from Python. However, there are some important differences that we will describe below.","title":"Harmony Language Details"},{"location":"reference/language/overview/#harmony-is-not-object-oriented","text":"Python is object-oriented, but Harmony is not. This can lead to some unexpected differences. For example, consider the following code: x = y = [ 1, 2 ] x[0] = 3 assert y[0] == 1 In Python, lists are objects. Thus x and y point to the same list, and the assertion would fail if executed by Python. In Harmony, lists are values. So when x is updated in Line 2, it does not affect the value of y . The assertion succeeds. Harmony supports references to values, allowing programs to implement shared objects. Because Harmony does not have objects, it also does not have object methods. However, Harmony methods and lambdas are program counter constants. These constants can be added to dictionaries. For example, in PetersonMethod.hny you can add the P enter and P exit methods to the { .turn: 0, .flags: [ False, False ], .enter: P_enter, .exit: P_exit } That would allow you to simulate object methods. There are at least two reasons why Harmony is not object-oriented. First, object-orientation often adds layers of indirection that would make it harder to model check and also to interpret the results. Consider, for example, a lock. In Python, a lock is an object. A lock variable would contain a reference to a lock object. In Harmony, a lock variable contains the value of the lock itself. Thus, the following statement means something quite different in Python and Harmony: x = y = Lock(); In Python, this creates two variables x and y referring to the same lock. In Harmony, the two variables will be two different locks. If you want two variables referring to the same lock in Harmony, you would write: x = y = malloc(Lock()); The second reason for Harmony not being object-oriented is that many concurrency solutions in the literature are expressed in C or some other low-level language that does not support objectorientation, but instead use malloc and free.","title":"Harmony is not object-oriented"},{"location":"reference/language/overview/#constants-global-and-local-variables","text":"Each (non-reserved) identifier in a Harmony program refers to either a constant, a global variable, or a local variable. Constants are declared using const statements. Those constants are computed at compile-time. Local variables all declared. They can be declared in def statements (i.e., arguments), let statements, and in for loops. Also, each method has an implicitly declared result variable. Local variables are tightly scoped and cannot be shared between threads. While in theory one method can be declared within another, they cannot share variables either. All other variables are global and must be initialized before any threads are spawned. While arguments to a method and variables in for loops can be modified, we discourage it for improved code readability.","title":"Constants, Global and Local Variables"},{"location":"reference/language/overview/#operator-precedence","text":"In Harmony, there is no syntactic difference between applying an argument to a function or an index to a dictionary. Both use the syntax a b c ... . We call this application , and application is left-associative. So a b c is interpreted as ( a b ) c : b is applied to a , and then c is applied to the result. For readability, it may help to write a ( b ) for function application and a [ b ] for indexing. In case b is an atom, you can also write a.b for indexing. There are three classes of precedence. Application has the highest precedence. So ! a b is interpreted as !( a b ) and a b + c d is interpreted as ( a b ) + ( c d ). Unary operators have the next highest precedence, and the remaining operators have the lowest precedence. So -2 + 3 evaluates to 1, not -5. Associative operators (+, \u2217, |, &, \u02c6, and , or ) are interpreted as general n -ary operators, and you are allowed to write a + b + c . However, a - b - c is illegal, as is any combination of operators with an arity larger than one, such as a + b < c . In such cases you have to add parentheses or brackets to indicate what the intended evaluation order is, such as ( a + b ) < c . In almost all expressions, subexpressions are evaluated left to right. So a [ b ] + c first evaluates a , then b (and then applies b to a ), and then c . The one exception is the expression a if c else b , where c is evaluated first. In that expression, only a or b is evaluated depending on the value of c . In the expression a and b and ... , evaluation is left to right but stops once one of the subexpressions evaluates to False . Similarly for or , where evaluation stops once one of the subexpressions evaluates to True. A sequence of comparison operations, such as a < b < c , is evaluated left to right but stops as soon as one of the comparisons fails. As an aside: the expression a not in b is equivalent to not ( a in b ). Harmony generalizes this construct for any pair of a unary (except '-') and a binary operator. In particular, a not and b is the same as not ( a and b ). For those familiar with logic gates, not and is the equivalent of NAND. Similarly, not = > is non-implication.","title":"Operator Precedence"},{"location":"reference/language/overview/#tuples-lists-and-pattern-matching","text":"Harmony's tuples and, equivalently, lists, are just special cases of dictionaries. They can be bracketed either by '(' and ')' or by '[' and ']', but the brackets are often optional. Importantly, with a singleton list, the one element must be followed by a comma. So the statement x = 1,; assigns a singleton tuple (or list) to x . Because tuples and lists are dictionaries, the del statement is different from Python. For example, if x = [.a, .b, .c], then del x [1] results in x = { 0:.a, 2:.c }, not x = [.a, .c]. Harmony also does not support special slicing syntax like Python. To modify lists, use the subseq method in the list module . Harmony allows pattern matching against nested tuples in various language constructs. The following are the same in Python and Harmony: x, = 1,: assigns 1 to x ; x , y = 1, (2, 3): assigns 1 to x and (2, 3) to y ; x , ( y , z ) = 1, (2, 3): assigns 1 to x , 2 to y , and 3 to z ; x , ( y , z ) = 1, 2; generates an runtime error because 2 cannot be matched with ( y , z ); x [0], x [1] = x [1], x [0]; swaps the first two elements of list x . As in Python, pattern matching can also be used in for statements. For example: for key, value in [ (1, 2), (3, 4) ]: ... Harmony (but not Python) also allows pattern matching in defining and invoking methods. For example, you can write: def f[a, (b, c)]: ... and then call f[1, (2, 3)]. Note that the more familiar: def g( a ) defines a method g with a single argument a . Invoking g(1, 2) would assign the tuple (1, 2) to a . This is not consistent with Python syntax. For single argument methods, you may want to declare as follows: def g( a, ). Calling g(1,) assigns 1 to a , while calling g(1, 2) would result in a runtime error as (1, 2) cannot be matched with ( a ,). Pattern matching can also be used in const and let statements. from stack import Stack, push, pop teststack = Stack() push(?teststack, 1) push(?teststack, 2) v = pop(?teststack) assert v == 2 push(?teststack, 3) v = pop(?teststack) assert v == 3 v = pop(?teststack) assert v == 1 Try out the stack implementation above in the IDE!","title":"Tuples, Lists, and Pattern Matching"},{"location":"reference/language/overview/#for-loops-and-comprehensions","text":"While Harmony does not support general iterators such as Python does, Harmony allows iterating over sets and dictionaries (and thus lists and tuples). The details are a little different from Python: When iterating over a set, the set is always traversed in order ; In case of a dictionary, the iteration is over the values of the dictionary, but in the order of the keys. In the case of lists, this works much the same as in Python, but in the case of general dictionaries, Python iterates over the keys rather than the values; If you want to iterate over the keys of a dictionary d , use for k inkeys d ; The list module provides methods values(), items(), enumerate(), and reversed() for other types of iteration supported by Python. Harmony supports nesting and filtering in for loops. For example: for i in { 1..10 } for j in { 1..10 } where i < j: ... Harmony also supports set, list, and dictionary comprehensions. Comprehensions are similar to Python, except that filtering uses the keyword where instead of if.","title":"For Loops and Comprehensions"},{"location":"reference/language/overview/#dynamic-allocation","text":"Harmony supports various options for dynamic allocation. By way of example, consider a stack. The code below presents a test program for a stack. We present four different stack implementations to illustrate options for dynamic allocation: from stack import Stack, push, pop teststack = Stack() push(?teststack, 1) push(?teststack, 2) v = pop(?teststack) assert v == 2 push(?teststack, 3) v = pop(?teststack) assert v == 3 v = pop(?teststack) assert v == 1 Try out the stack implementation above in the IDE!","title":"Dynamic Allocation"},{"location":"reference/language/overview/#dynamically-updated-list","text":"The code below uses a single list to represent the stack. It is updated to perform push and pop operations. def Stack(): result = [ ] def push(st, v): (!st)[len(!st)] = v def pop(st): let n = len(!st) \u2013 1: result = (!st)[n] del (!st)[n] Try out the stack implementation above in the IDE!","title":"Dynamically Updated List"},{"location":"reference/language/overview/#static-list","text":"The code below also uses a list but, instead of updating the list, it replaces the list with a new one for each operation. import list def Stack(): result = [] def push(st, v): !st += [v,] def pop(st): let n = len(!st) - 1: result = (!st)[n] !st = list.subseq(!st, 0, n) Try out the stack implementation above in the IDE!","title":"Static List"},{"location":"reference/language/overview/#recursive-tuple","text":"The code below represents a stack as a recursively nested tuple ( v,f ), where v is the element on top of the stack and r is a stack that is the remainder. def Stack(): result = () def push(st, v): (!st) = (v, !st) def pop(st): let (top, rest) = !st: result = top !st = rest Try out the stack implementation above in the IDE!","title":"Recursive Tuple"},{"location":"reference/language/overview/#linked-list","text":"The code below implements a stack as a linked list with nodes allocated using the alloc module. from alloc import malloc, free def Stack(): result = None def push(st, v): !st = malloc({ .value: v, .rest: !st }) def pop(st): let node = !st: result = node->value !st = node->rest free(node) Try out the stack implementation above in the IDE! While the last option is the most versatile (it allows cyclic data structures), Harmony does not support garbage collection for memory allocated this way and so allocated memory that is no longer in use must be explicitly released using free.","title":"Linked List"},{"location":"reference/language/overview/#comments","text":"Harmony supports the same commenting conventions as Python. In addition, Harmony supports nested multi-line comments of the form (* comment *) .","title":"Comments"},{"location":"reference/language/statements/","text":"Statements Harmony currently supports the following statements: Statement Description lv = [lv =]... e lv is an lvalue and e is an expression lv [op] = e op is one of + , - , * , / , // , % , & , | , ^ , and , and or assert b [, e] b is a boolean. Optionally report value of expression e atomic: S S a list of statements await b b is a boolean const a = e a is a bounded variable, e is a constant expression def m a: S m is an identifier, a a bounded variable del lv delete for a[:b] in e [where c]: S a and b are a bounded variables, e is a set or dictionary from m import ... m identifies a module go c e c is a context, e is an expression if b: S else: S b is a boolean, S is a list of statements import m, ... m identifies a module invariant e e is an invariant let a = e [let ...]: S a is a bounded variable, e is an expression pass do nothing possibly b [, b, ...] each b is a boolean select a in e: S a is a bounded variable, e is a set, S a list of statements sequential v, ... v has sequential consistency spawn [eternal] m e [, t] m is a method, e is an expression, t is the thread-local state trap m e m is a method and e is an expression while b: S b is a boolean, S a list of statements B.1 Single expression evaluation Any expression by itself can be used as a statement. The most common form of this is a function application, for example:f(). This statement evaluates f() but ignores its result. It is equivalent to the assignment statement -= f(). B.2 Assignment The statement x = 3 changes the state by assigning 3 to variable x (assuming x was not already 3). x may be a local variable or a shared variable. The statement x = y = 3 first updates y, then x. The statement x[f()] = y[g()] = h() first computes the address of x[f()], then computes the address of y[g()], then evaluates h(), then assigns the resulting value to y[g()] (using its previously computed address), and finally assigns the same value to x[f()] (again using its previously computed address). The statement a, b = c assumes that c is a tuple with two values. It first evaluates the addresses of a and b and first assigns to the latter and then the former. If c is not a tuple with two values, then Harmony will report an error. Assigning to evaluates the righthand side expression but is otherwise a no-op. The statement x += 3 loads x, adds 3, and then stores the results in x. In this case, it is equivalent to x = x + 3. However, in general this is not so. For example, x[f()] += 3 only evaluates f() once. Unlike Python, however, x += [3,] is equivalent to x = x + [3,] in Harmony. (In Python, the following two compound statements lead to different results fory: x = y = []; x += [3] and x = y = []; x = x + [3].) B.3 assert The statement assert b evaluates b and reports an error if b is false. It should be considered a no-op \u2014 it is part of the specification, not part of the implementation of the algorithm. In particular, it specifies an invariant: whenever the program counter is at the location where the assert statement is, then b is always true. If b is an expression, then it is evaluated atomically. Moreover, the expression is not allowed to change the state. If it does change the state, Harmony will report an error as well. As in Python, you can specify an additional expression: assert b, e. The value of e will be reported as part of the error should b evaluate to false. B.4 atomic The statement atomic S 1 ; S 2 ; ... evaluates statements S 1 , S 2 , ... atomically in that no other threads can run while this atomic block is executing. Typically an atomic block runs to completion before any other thread can run. The only exception to this is if the atomic block executes a stop expression. In this case, another thread can run. When the original thread is resumed (using a go statement), it is once again atomically executing. The atomic statement is useful for implementing synchronization primitives such as test-and-set. It is also useful for testing. It is not a replacement for lock/unlock, and should not generally be used for synchronization otherwise. Lock/unlock does allow other threads to run concurrently \u2014 just not in the same critical section. B.5 await The statement await b is equivalent to while !b: pass. It is intended to improve readability of your code. B.6 const The expression const N = 3 introduces a new constant N with the value 3. Evaluating N does not lead to loading from a memory location. The assignment can be overridden with the -c flag: harmony -c N = 4 executes the model checker with 4 assigned to N instead of 3. Harmony also supports const N, M = 3, 4, which assigns 3 to N and 4 to M. Harmony has limited support for constant folding. For example, const N = 3 + 4 assigns value 7 to constant N. B.7 def The statement def m a: S 1 ; S 2 : ... defines a new program counter constant m referring to a method that takes an argument a and executes the statements S 1 , S 2 , .... The argument a can be a tuple pattern similar to those used in let and for statements. Examples include (), (x,), (x, y), and (x,(y, z)). The given local variable names variable names are assigned upon application. It is allowed, but discouraged, to updates those local variables in statements S 1 , S 2 , .... Each method has a predefined local variable result , initialized to None, that is returned by the method. Harmony does not support a return statement that breaks out of the code before executing the last statement. B.8 del The statement del x removes variable x from the state. x can be either a local or a shared variable. For example, the statement del x.age removes the .age field from dictionary x. Harmony automatically removes top-level local variables that are no longer in use from the state in order to attempt to reduce the number of states that are evaluated during model checking. Because Harmony lists are dictionaries, deleting from lists is different from Python: x = [.a, .b]; del x[0] results in x having value {1 : .b} rather than [.b] (which is {0 :b}). B.9 for in [...where] The statement for x in y: S 1 ; S 2 ; ... iterates over y and executes for each element the statements S 1 , S 2 , .... y must be a set or a dictionary. y is evaluated only once at the beginning of the evaluation of this statement. In case of a set, the result is sorted (using Harmony\u2019s global order on all values). In case of a dictionary, the statement iterates over the values of the dictionary in the order of the keys. This makes iterating over lists intuitive and identical to Python. For each element, the statements S 1 , S 2 , ...are executed with local variable y having the value of the element. x can be a pattern such as (a) or (a,(b, c)). If the pattern cannot be matched, Harmony detects and error. It is allowed, but discouraged, to assign different values to x within statements S 1 , S 2 , .... If y is a dictionary, Harmony also supports the form for k : v in y: S 1 ; S 2 ; .... This works similar, except that k is bound to the key and v is bound to the value. The statement also supports nesting and filtering. Nesting is of the form for x 1 in y 1 for x 2 in y 2 : S 1 ; S 2 ; ..., which is equivalent to the statement for x 1 in y 1 : for x 2 in y 2 : S 1 ; S 2 ; .... Filtering is of the form for x in y where z : S 1 ; S 2 ; .... For example, for x in {1 .. 10} where (x%2) == 0 : S 1 ; S 2 ; ... only evaluates statements S 1 , S 2 , ... for even x, that is, 2, 4, 6, 8, and 10. Harmony does not support break or continue statements. B.10 from import The statement from x import a, b, ... imports module x and makes its constants a, b, ... also constants in the current module. If a module is imported more than once, its code is only included the first time. The constants will typically be the names of methods (program counter constants) within the module. You can import all constants from a module m (including program counter constants) using the statement from m import *. This, however, excludes constants whose names start with the character : those are considered private to the module. B.11 go The statement go c e starts a thread with context c that has executed a stop expression. The stop expression returns value e. The same context can be started multiple times, allowing threads to fork. B.12 if [elif ...]* [else] Harmony supports if statements. In its most basic form, if c: S 1 ; S 2 ; ...evaluatescand executes statements S 1 , S 2 , ... if and only if boolean expression c evaluated to true. Harmony checks that c is either False or True \u2014 if neither is the case, Harmony reports an error. The statement if c: S 1 , S 2 , ... else: T 1 ; T 2 ; ... is similar, but executes statements T 1 , T 2 , ... if and only if c evaluated to false. You can think of elif c: as shorthand for else: if c:. B.13 import The statement import m 1 , m 2 , ... imports modules m 1 , m 2 , ... in that order. If a module is imported more than once, its code is only included the first time. The constants (including method constants) and shared variables declared in that module can subsequently be referenced by prepending m. . For example, method f() in imported module m is invoked by calling m.f() . If you would prefer to invoke it simply as f(), then you have to import using the statement from m import f. B.14 invariant The statement invariant c declares that boolean expression c is an invariant. c is only allowed to read shared variables and is evaluated atomically after every state change. If it ever evaluates to False, Harmony reports an error. Harmony also reports an error if the expression evaluates to a value other than False or True. B.15 let You can introduce new local variables in a method using the let expression. The statement let a = b: S 1 ; S 2 , ... evaluates b, assigns the result to local variable a, and evaluates statements S 1 , S 2 , .... let supports pattern matching, so you can write let x,(y, z) = b: S 1 ; S 2 , .... This will only work if b is a tuple with two elements, the second of which also being a tuple with two elements \u2014 if not, Harmony will report an error. The variables may be updates in statements S 1 , S 2 , .... let statements may be nested, such as let a 1 = b 1 let a 2 = b 2 : S 1 ; S 2 ; .... Doing so can improve readability by reducing indentation compared to writing them as separate statements. Compare the following two examples: let a = y: let b = z: let a = y let b = z: ... B.16 pass The pass statement does nothing. B.17 possibly The statement possibly b 1 , b 2 , ... atomically evaluates all predicates b i . At completion, Harmony reports which of the predicates never held. B.18 select in The statement select x in y: S 1 ; S 2 ; ... requires that y evaluates to a set value. The statement does the following three things atomically: it waits until y is non-empty; it selects one element of y non-deterministically (using a choose expression); it executes statements S 1 , S 2 , ... with the selected element assigned to local variable x. x may be a pattern, like in let , for and def statements. Harmony reports an error if y evaluates to a value that is not a set. If waiting is an unused local variable, then select x in y: S 1 ; S 2 ; ...is equivalent to let waiting = True: while waiting: atomic: if y != {}: let x = choose(y): S1 S2 ... waiting = False The statement is particularly useful in programming network protocols when having to wait for one or more messages and executing a set of actions atomically after the desired messages have arrived. B.19 sequential In Harmony, shared variable Load and Store operations are atomic and havesequential consistency. However, Harmony does check for data races. A data race occurs when two or more threads simultaneously access the same shared variable, with at least one of the accesses being a Store operation outside of an atomic block. If so, Harmony will report an error. This error can be suppressed by declaring the shared variable as sequential. In particular, the statement sequential x, y, ... specifies that the algorithm assumes that the given variables have sequential consistency. Note that few modern processors support sequentially consistent memory by default, as doing so would lead to high overhead. B.20 spawn The statement spawn m a starts a new thread that executes method m with argument a. m must be a program counter constant, and a is typically a tuple containing zero or more parameters to be passed to the method. The default thread-local state of the thread, called self, is the empty dictionary by default. It can be specified by adding a parameter: spawn m a, e specifies that e should be the initial value of the thread-local state. Harmony normally checks that all threads eventually terminate. If a thread may never terminate, you should spawn it with spawn eternal m a to suppress those checks. B.21 trap The statementtrapm aspecifies that the current thread should execute method m with argument a and some future unspecified time. It models a timer interrupt or any kind of asynchronous event to be handled by the thread. Such interrupts can be disabled by setting the interrupt level of the thread to True using the setintlevel operator. B.22 while The statement while c: S 1 ; S 2 ; ...executes statements S 1 , S 2 , ...repeatedly as long as c evaluates to True. Harmony does not support break or continue statements.","title":"Statements"},{"location":"reference/language/statements/#statements","text":"Harmony currently supports the following statements: Statement Description lv = [lv =]... e lv is an lvalue and e is an expression lv [op] = e op is one of + , - , * , / , // , % , & , | , ^ , and , and or assert b [, e] b is a boolean. Optionally report value of expression e atomic: S S a list of statements await b b is a boolean const a = e a is a bounded variable, e is a constant expression def m a: S m is an identifier, a a bounded variable del lv delete for a[:b] in e [where c]: S a and b are a bounded variables, e is a set or dictionary from m import ... m identifies a module go c e c is a context, e is an expression if b: S else: S b is a boolean, S is a list of statements import m, ... m identifies a module invariant e e is an invariant let a = e [let ...]: S a is a bounded variable, e is an expression pass do nothing possibly b [, b, ...] each b is a boolean select a in e: S a is a bounded variable, e is a set, S a list of statements sequential v, ... v has sequential consistency spawn [eternal] m e [, t] m is a method, e is an expression, t is the thread-local state trap m e m is a method and e is an expression while b: S b is a boolean, S a list of statements","title":"Statements"},{"location":"reference/language/statements/#b1-single-expression-evaluation","text":"Any expression by itself can be used as a statement. The most common form of this is a function application, for example:f(). This statement evaluates f() but ignores its result. It is equivalent to the assignment statement -= f().","title":"B.1 Single expression evaluation"},{"location":"reference/language/statements/#b2-assignment","text":"The statement x = 3 changes the state by assigning 3 to variable x (assuming x was not already 3). x may be a local variable or a shared variable. The statement x = y = 3 first updates y, then x. The statement x[f()] = y[g()] = h() first computes the address of x[f()], then computes the address of y[g()], then evaluates h(), then assigns the resulting value to y[g()] (using its previously computed address), and finally assigns the same value to x[f()] (again using its previously computed address). The statement a, b = c assumes that c is a tuple with two values. It first evaluates the addresses of a and b and first assigns to the latter and then the former. If c is not a tuple with two values, then Harmony will report an error. Assigning to evaluates the righthand side expression but is otherwise a no-op. The statement x += 3 loads x, adds 3, and then stores the results in x. In this case, it is equivalent to x = x + 3. However, in general this is not so. For example, x[f()] += 3 only evaluates f() once. Unlike Python, however, x += [3,] is equivalent to x = x + [3,] in Harmony. (In Python, the following two compound statements lead to different results fory: x = y = []; x += [3] and x = y = []; x = x + [3].)","title":"B.2 Assignment"},{"location":"reference/language/statements/#b3-assert","text":"The statement assert b evaluates b and reports an error if b is false. It should be considered a no-op \u2014 it is part of the specification, not part of the implementation of the algorithm. In particular, it specifies an invariant: whenever the program counter is at the location where the assert statement is, then b is always true. If b is an expression, then it is evaluated atomically. Moreover, the expression is not allowed to change the state. If it does change the state, Harmony will report an error as well. As in Python, you can specify an additional expression: assert b, e. The value of e will be reported as part of the error should b evaluate to false.","title":"B.3 assert"},{"location":"reference/language/statements/#b4-atomic","text":"The statement atomic S 1 ; S 2 ; ... evaluates statements S 1 , S 2 , ... atomically in that no other threads can run while this atomic block is executing. Typically an atomic block runs to completion before any other thread can run. The only exception to this is if the atomic block executes a stop expression. In this case, another thread can run. When the original thread is resumed (using a go statement), it is once again atomically executing. The atomic statement is useful for implementing synchronization primitives such as test-and-set. It is also useful for testing. It is not a replacement for lock/unlock, and should not generally be used for synchronization otherwise. Lock/unlock does allow other threads to run concurrently \u2014 just not in the same critical section.","title":"B.4 atomic"},{"location":"reference/language/statements/#b5-await","text":"The statement await b is equivalent to while !b: pass. It is intended to improve readability of your code.","title":"B.5 await"},{"location":"reference/language/statements/#b6-const","text":"The expression const N = 3 introduces a new constant N with the value 3. Evaluating N does not lead to loading from a memory location. The assignment can be overridden with the -c flag: harmony -c N = 4 executes the model checker with 4 assigned to N instead of 3. Harmony also supports const N, M = 3, 4, which assigns 3 to N and 4 to M. Harmony has limited support for constant folding. For example, const N = 3 + 4 assigns value 7 to constant N.","title":"B.6 const"},{"location":"reference/language/statements/#b7-def","text":"The statement def m a: S 1 ; S 2 : ... defines a new program counter constant m referring to a method that takes an argument a and executes the statements S 1 , S 2 , .... The argument a can be a tuple pattern similar to those used in let and for statements. Examples include (), (x,), (x, y), and (x,(y, z)). The given local variable names variable names are assigned upon application. It is allowed, but discouraged, to updates those local variables in statements S 1 , S 2 , .... Each method has a predefined local variable result , initialized to None, that is returned by the method. Harmony does not support a return statement that breaks out of the code before executing the last statement.","title":"B.7 def"},{"location":"reference/language/statements/#b8-del","text":"The statement del x removes variable x from the state. x can be either a local or a shared variable. For example, the statement del x.age removes the .age field from dictionary x. Harmony automatically removes top-level local variables that are no longer in use from the state in order to attempt to reduce the number of states that are evaluated during model checking. Because Harmony lists are dictionaries, deleting from lists is different from Python: x = [.a, .b]; del x[0] results in x having value {1 : .b} rather than [.b] (which is {0 :b}).","title":"B.8 del"},{"location":"reference/language/statements/#b9-for-in-where","text":"The statement for x in y: S 1 ; S 2 ; ... iterates over y and executes for each element the statements S 1 , S 2 , .... y must be a set or a dictionary. y is evaluated only once at the beginning of the evaluation of this statement. In case of a set, the result is sorted (using Harmony\u2019s global order on all values). In case of a dictionary, the statement iterates over the values of the dictionary in the order of the keys. This makes iterating over lists intuitive and identical to Python. For each element, the statements S 1 , S 2 , ...are executed with local variable y having the value of the element. x can be a pattern such as (a) or (a,(b, c)). If the pattern cannot be matched, Harmony detects and error. It is allowed, but discouraged, to assign different values to x within statements S 1 , S 2 , .... If y is a dictionary, Harmony also supports the form for k : v in y: S 1 ; S 2 ; .... This works similar, except that k is bound to the key and v is bound to the value. The statement also supports nesting and filtering. Nesting is of the form for x 1 in y 1 for x 2 in y 2 : S 1 ; S 2 ; ..., which is equivalent to the statement for x 1 in y 1 : for x 2 in y 2 : S 1 ; S 2 ; .... Filtering is of the form for x in y where z : S 1 ; S 2 ; .... For example, for x in {1 .. 10} where (x%2) == 0 : S 1 ; S 2 ; ... only evaluates statements S 1 , S 2 , ... for even x, that is, 2, 4, 6, 8, and 10. Harmony does not support break or continue statements.","title":"B.9 for in [...where]"},{"location":"reference/language/statements/#b10-from-import","text":"The statement from x import a, b, ... imports module x and makes its constants a, b, ... also constants in the current module. If a module is imported more than once, its code is only included the first time. The constants will typically be the names of methods (program counter constants) within the module. You can import all constants from a module m (including program counter constants) using the statement from m import *. This, however, excludes constants whose names start with the character : those are considered private to the module.","title":"B.10 from import"},{"location":"reference/language/statements/#b11-go","text":"The statement go c e starts a thread with context c that has executed a stop expression. The stop expression returns value e. The same context can be started multiple times, allowing threads to fork.","title":"B.11 go"},{"location":"reference/language/statements/#b12-if-elif-else","text":"Harmony supports if statements. In its most basic form, if c: S 1 ; S 2 ; ...evaluatescand executes statements S 1 , S 2 , ... if and only if boolean expression c evaluated to true. Harmony checks that c is either False or True \u2014 if neither is the case, Harmony reports an error. The statement if c: S 1 , S 2 , ... else: T 1 ; T 2 ; ... is similar, but executes statements T 1 , T 2 , ... if and only if c evaluated to false. You can think of elif c: as shorthand for else: if c:.","title":"B.12 if [elif ...]* [else]"},{"location":"reference/language/statements/#b13-import","text":"The statement import m 1 , m 2 , ... imports modules m 1 , m 2 , ... in that order. If a module is imported more than once, its code is only included the first time. The constants (including method constants) and shared variables declared in that module can subsequently be referenced by prepending m. . For example, method f() in imported module m is invoked by calling m.f() . If you would prefer to invoke it simply as f(), then you have to import using the statement from m import f.","title":"B.13 import"},{"location":"reference/language/statements/#b14-invariant","text":"The statement invariant c declares that boolean expression c is an invariant. c is only allowed to read shared variables and is evaluated atomically after every state change. If it ever evaluates to False, Harmony reports an error. Harmony also reports an error if the expression evaluates to a value other than False or True.","title":"B.14 invariant"},{"location":"reference/language/statements/#b15-let","text":"You can introduce new local variables in a method using the let expression. The statement let a = b: S 1 ; S 2 , ... evaluates b, assigns the result to local variable a, and evaluates statements S 1 , S 2 , .... let supports pattern matching, so you can write let x,(y, z) = b: S 1 ; S 2 , .... This will only work if b is a tuple with two elements, the second of which also being a tuple with two elements \u2014 if not, Harmony will report an error. The variables may be updates in statements S 1 , S 2 , .... let statements may be nested, such as let a 1 = b 1 let a 2 = b 2 : S 1 ; S 2 ; .... Doing so can improve readability by reducing indentation compared to writing them as separate statements. Compare the following two examples: let a = y: let b = z: let a = y let b = z: ...","title":"B.15 let"},{"location":"reference/language/statements/#b16-pass","text":"The pass statement does nothing.","title":"B.16 pass"},{"location":"reference/language/statements/#b17-possibly","text":"The statement possibly b 1 , b 2 , ... atomically evaluates all predicates b i . At completion, Harmony reports which of the predicates never held.","title":"B.17 possibly"},{"location":"reference/language/statements/#b18-select-in","text":"The statement select x in y: S 1 ; S 2 ; ... requires that y evaluates to a set value. The statement does the following three things atomically: it waits until y is non-empty; it selects one element of y non-deterministically (using a choose expression); it executes statements S 1 , S 2 , ... with the selected element assigned to local variable x. x may be a pattern, like in let , for and def statements. Harmony reports an error if y evaluates to a value that is not a set. If waiting is an unused local variable, then select x in y: S 1 ; S 2 ; ...is equivalent to let waiting = True: while waiting: atomic: if y != {}: let x = choose(y): S1 S2 ... waiting = False The statement is particularly useful in programming network protocols when having to wait for one or more messages and executing a set of actions atomically after the desired messages have arrived.","title":"B.18 select in"},{"location":"reference/language/statements/#b19-sequential","text":"In Harmony, shared variable Load and Store operations are atomic and havesequential consistency. However, Harmony does check for data races. A data race occurs when two or more threads simultaneously access the same shared variable, with at least one of the accesses being a Store operation outside of an atomic block. If so, Harmony will report an error. This error can be suppressed by declaring the shared variable as sequential. In particular, the statement sequential x, y, ... specifies that the algorithm assumes that the given variables have sequential consistency. Note that few modern processors support sequentially consistent memory by default, as doing so would lead to high overhead.","title":"B.19 sequential"},{"location":"reference/language/statements/#b20-spawn","text":"The statement spawn m a starts a new thread that executes method m with argument a. m must be a program counter constant, and a is typically a tuple containing zero or more parameters to be passed to the method. The default thread-local state of the thread, called self, is the empty dictionary by default. It can be specified by adding a parameter: spawn m a, e specifies that e should be the initial value of the thread-local state. Harmony normally checks that all threads eventually terminate. If a thread may never terminate, you should spawn it with spawn eternal m a to suppress those checks.","title":"B.20 spawn"},{"location":"reference/language/statements/#b21-trap","text":"The statementtrapm aspecifies that the current thread should execute method m with argument a and some future unspecified time. It models a timer interrupt or any kind of asynchronous event to be handled by the thread. Such interrupts can be disabled by setting the interrupt level of the thread to True using the setintlevel operator.","title":"B.21 trap"},{"location":"reference/language/statements/#b22-while","text":"The statement while c: S 1 ; S 2 ; ...executes statements S 1 , S 2 , ...repeatedly as long as c evaluates to True. Harmony does not support break or continue statements.","title":"B.22 while"},{"location":"reference/language/value-types/","text":"Value Types Chapter 4 provides an introduction to Harmony values. Below is a complete list of Harmony value types with examples: Type Example Boolean False, True Integer -inf, ..., -2, -1, 0, 1, 2, ..., inf Atom .example, .test1, .0x4A Program Counter (method names are program counter constants) Dictionary {.account: 12345, .valid: False } Set {}, {1, 2, 3}, { False, .id, 3} Address ?lock, ?flags[2], None Context (generated by stop expression) Tuples, lists, strings, and bags are all special cases of dictionaries. Both tuples and lists map indexes (starting at 0) to Harmony values. Their format is either (e,e, ...,e,) or [e,e, ..., e,] . If the tuple or list has two or more elements, then the final comma is optional. A string is represented as a tuple of its characters. Characters are one-character atoms, which can be expressed in hexadecimal unicode using the syntax .0xXX . A bag or multiset is a dictionary that maps a value to how many times it occurs in the bag. All Harmony values are ordered with respect to one another. First they are ordered by type according to the table above. So, for example, True < 0 < .xyz < { 0 }) . Within types, the following rules apply: False < True ; integers are ordered in the natural way; atoms are lexicographically ordered; program counters are ordered by their integer values; dictionaries are first converted into a list of ordered (key, value) pairs. Then two dictionaries are lexicographically ordered by this representation; a set is first converted into an ordered list, then lexicographically ordered; an address is a list of atoms. None is the empty list of atoms. Addresses are lexicographically ordered accordingly; contexts (Appendix E) are ordered first by name, then by program counter, then by the remaining content. Generic operators on Harmony values include: e == e equivalence e != e inequivalence e < e, e <= e, e > e, e >= e comparison 1.1 Boolean The Boolean type has only two possible values: False and True . Unlike in Python, in Harmony booleans are distinct from integers, and in particular False < 0 . In statements and expressions where booleans are expected, it is not possible to substibute values of other types. Operations on booleans include: e and e and ... conjuction e or e or ... disjunction e => e, e not => e implication not e negation v if e else v\u2032 v or v\u2032 depending one anys, alls disjunction / conjunction for set or lists 1.2 Integer The integer type supports any whole number, as well as \u2212inf and inf . In the Python-based model checker, integers are infinite precision. In the C-based model checker, integers are implemented by two\u2019s complement 61-bit words, and \u2212inf is represented by the minimal integer and inf is represented by the maximal integer. Operations on integers include: -e negation abs(e) absolute value e + e + ... sum e - e difference e * e * e ... product e / e, e // e integer division e % e, e mod e integer division remainder e ** e power ~e binary inversion e & e & ... binary and e \\| e \\| ... binary or e ^ e ^ ... binary exclusive or e << e binary shift left e >> e binary shift right {e..e\u2032} set of integers from e to e\u2032 inclusive 1.3 Atom Atoms are essentially names and consist of one or more unicode characters. If they do not contain special characters and do not start with a digit, then an atom can be represented by a \u201c.\u201d followed by the characters. For example, .hello is a representation of the atom \u201chello\u201d. A special character can be represented by .0xXX , where XX is the hexidecimal unicode for the character. Atoms should not be confused with strings. There are no special operations on atoms. (In the future, operators may be introduced that convert between strings and atoms.) 1.4 Set In Harmony you can create a set of any collection of Harmony values. Its syntax is { v 0 , v 1 , ... }. Python users: note that in Harmony the empty set is denoted as {} . The set module (Section C.5) contains various convenient routines that operate on sets. Native operations on sets include: lens cardinality s - s set difference s & s & ... intersection s \\| s \\| ... union s ^ s ^ ... inclusion/exclusion (elements in odd number of sets) choose s select an element (Harmony will try all) mins minimum element maxs maximum element anys True if any value is True alls True if all values are True Harmony also supports set comprehension. In its simplest form, { f(v) for v in s } returns a set that is constructed by applying f to all elements in s (where s is a set or a list). This is known as mapping. But set comprehension is much more powerful and can include joining multiple sets (using nested for loops) and filtering (using the where keyword). For example: { x + y for x in s for y in s such that (x * y ) == 4 } returns a set that is constructed by summing pairs of elements from s that, when multiplied, have the value 4 . 1.5 Dictionary A dictionary maps a set of values (known as keys ) to another set of values. The generic syntax of a dictionary is { k 0 : v 0 , k 1 : v 1 , ... }. Different from Python, the empty dictionary is either () or [] (because {} is the empty set in Harmony). If there are duplicate keys in the list, then only the one with the maximum value survives. Therefore the order of the keys in the dictionary does not matter. Dictionaries support comprehension. The basic form is: { f(k) : g(k) fork in s }. There are various special cases of dictionaries, including lists, tuples, strings, and bags (multi-sets) that are individually described below. Operations on dictionaries include the following: d k indexing len d the number of keys in d keys d the set of keys in d v [not] in keys d check if v is a key in d v [not] in d check if v is a value in d min d the minimum value in d max d the maximum value in d any d True if any value is True all d True if all values are True d & d & ... dictionary intersection d \\| d \\| ... dictionary union Because in Harmony brackets are used for parsing purposes only, you can write d[k] (or d(k) ) instead of d k . However, if k is an atom, like .id , then you might prefer the notation k.id . Python users beware: the Harmony v in d operator checks if there is some key k such that d[k] = v . In Python, the same syntax checks if v is a key in d . The difference exists because in Harmony a list is a special case of a dictionary. Dictionary intersection and dictionary union are defined so that they work well with bags. With disjoint dictionaries, intersection and union work as expected. If there is a key in the intersection, then dictionary intersection retains the minimum value while dictionary union retains the maximum value. Unlike Python, Harmony dictionary intersection and union are commutative and associative. 1.6 List or Tuple In Harmony, there is no distinction between a list or a tuple. Both are a special case of dictionary. In particular, a list of n values is represented by a dictionary that maps the integers 0, ..., n\u22121 to those values. Hence, if t is a list or tuple, then the notation t[0] returns the first element of the list. You can denote a list by a sequence of values, each value terminated by a comma. As per usual, you can use brackets or parentheses at your discretion. For Python users, the important thing to note is that a singleton list in Harmony must contain a comma. For example [1,] is a list containing the value 1, while [1] is simply the value 1. The list module contains various convenient routines that operate on lists or tuples. Native operations on lists or tuples include the following: t k indexing t + t + ... concatenation t * n n copies of t concatenated v [not] in t check if v is a value in t len t the length of t min t the minimum value in t max t the maximum value in t any t True if any value is True all t True if all values are True t & t & ... pairwise list minimum t | t | ... pairwise list maximum Lists and tuples support comprehension as well. In their most basic form: f(v) for v in s . For example, to check if any element in a list t is even, you can write: any((x%2) == 0 for x in t) . 1.7 String In Harmony, a string is a list of single-character atoms. The Python string notations mostly work in Harmony as well. For example, \u2019abc\u2019 is a three-character string consisting of the atoms .a , .b , and .c . \"abc\" is the same three-character string. Various special characters (including quotes, newlines, etc.) can be escaped using a backslash. Multi-line strings can be terminated by triple quotes or triple double-quotes. Native operations on strings include the following: s k indexing s + s + ... concatenation s * n n copies of s concatenated c[not] in s check if c (a one-character atom) is in s len s the length of s 1.8 Bag or Multiset A bag is represented by a dictionary that maps each element to its multiplicity, for example: { 10:2, 12:1 }. The bag module contains various convenient routines that operate on lists or tuples. Native operations on bags include the following: v[not] in keys b check if v is in b t & t & ... bag intersection t \\| t \\| ... bag union 1.9 Program Counter A program counter is an integer that can be used to index into Harmony bytecode. When you define a method, a lambda function, or a label, you are creating a constant of the program counter type. Operations on program counters include the following: | m a | invoke method with program counter m and argument `a | | atLabel l | return a bag of (method, argument) pairs of threads executing at label l | You can create lambda functions similarly to Python. For example: lambda(x, y): x + y . 1.10 Address In Harmony, each shared variable has an address, which is essentially a list of Harmony values. For example, the address of variable d . v[3] consists of the list .d , .v , and 3 . The only way to construct an address in Harmony is using the ? operator. ?d.v[3] returns the address of variable d.v[3] . An address can be dereferenced to return the value of the variable. If a is an address, then !a returns the value. Like C, Harmony supports the shorthand a->v for the expression (!a).v . 1.11 Context A context value captures the state of a thread. A context is itself composed over various Harmony values. Some of these values can be extracted. In particular, if c is a context, then: c.name returns the name of the thread\u2019s main method c.entry returns the program counter of the thread\u2019s main method c.arg returns the argument value of the thread\u2019s main method c.this returns the thread-local state c.mode returns themodeof the context The possible modes of a context are as follows: normal context of a executing thread stopped context of a stopped thread terminated context of a terminated thread failed context of a failed thread A thread can call getcontext() to retrieve its current context. Also, the function contexts() returns a bag of all contexts (including terminated ones). Both these functions should only be called in atomic mode and used for checking invariants.","title":"Values"},{"location":"reference/language/value-types/#value-types","text":"Chapter 4 provides an introduction to Harmony values. Below is a complete list of Harmony value types with examples: Type Example Boolean False, True Integer -inf, ..., -2, -1, 0, 1, 2, ..., inf Atom .example, .test1, .0x4A Program Counter (method names are program counter constants) Dictionary {.account: 12345, .valid: False } Set {}, {1, 2, 3}, { False, .id, 3} Address ?lock, ?flags[2], None Context (generated by stop expression) Tuples, lists, strings, and bags are all special cases of dictionaries. Both tuples and lists map indexes (starting at 0) to Harmony values. Their format is either (e,e, ...,e,) or [e,e, ..., e,] . If the tuple or list has two or more elements, then the final comma is optional. A string is represented as a tuple of its characters. Characters are one-character atoms, which can be expressed in hexadecimal unicode using the syntax .0xXX . A bag or multiset is a dictionary that maps a value to how many times it occurs in the bag. All Harmony values are ordered with respect to one another. First they are ordered by type according to the table above. So, for example, True < 0 < .xyz < { 0 }) . Within types, the following rules apply: False < True ; integers are ordered in the natural way; atoms are lexicographically ordered; program counters are ordered by their integer values; dictionaries are first converted into a list of ordered (key, value) pairs. Then two dictionaries are lexicographically ordered by this representation; a set is first converted into an ordered list, then lexicographically ordered; an address is a list of atoms. None is the empty list of atoms. Addresses are lexicographically ordered accordingly; contexts (Appendix E) are ordered first by name, then by program counter, then by the remaining content. Generic operators on Harmony values include: e == e equivalence e != e inequivalence e < e, e <= e, e > e, e >= e comparison","title":"Value Types"},{"location":"reference/language/value-types/#11-boolean","text":"The Boolean type has only two possible values: False and True . Unlike in Python, in Harmony booleans are distinct from integers, and in particular False < 0 . In statements and expressions where booleans are expected, it is not possible to substibute values of other types. Operations on booleans include: e and e and ... conjuction e or e or ... disjunction e => e, e not => e implication not e negation v if e else v\u2032 v or v\u2032 depending one anys, alls disjunction / conjunction for set or lists","title":"1.1 Boolean"},{"location":"reference/language/value-types/#12-integer","text":"The integer type supports any whole number, as well as \u2212inf and inf . In the Python-based model checker, integers are infinite precision. In the C-based model checker, integers are implemented by two\u2019s complement 61-bit words, and \u2212inf is represented by the minimal integer and inf is represented by the maximal integer. Operations on integers include: -e negation abs(e) absolute value e + e + ... sum e - e difference e * e * e ... product e / e, e // e integer division e % e, e mod e integer division remainder e ** e power ~e binary inversion e & e & ... binary and e \\| e \\| ... binary or e ^ e ^ ... binary exclusive or e << e binary shift left e >> e binary shift right {e..e\u2032} set of integers from e to e\u2032 inclusive","title":"1.2 Integer"},{"location":"reference/language/value-types/#13-atom","text":"Atoms are essentially names and consist of one or more unicode characters. If they do not contain special characters and do not start with a digit, then an atom can be represented by a \u201c.\u201d followed by the characters. For example, .hello is a representation of the atom \u201chello\u201d. A special character can be represented by .0xXX , where XX is the hexidecimal unicode for the character. Atoms should not be confused with strings. There are no special operations on atoms. (In the future, operators may be introduced that convert between strings and atoms.)","title":"1.3 Atom"},{"location":"reference/language/value-types/#14-set","text":"In Harmony you can create a set of any collection of Harmony values. Its syntax is { v 0 , v 1 , ... }. Python users: note that in Harmony the empty set is denoted as {} . The set module (Section C.5) contains various convenient routines that operate on sets. Native operations on sets include: lens cardinality s - s set difference s & s & ... intersection s \\| s \\| ... union s ^ s ^ ... inclusion/exclusion (elements in odd number of sets) choose s select an element (Harmony will try all) mins minimum element maxs maximum element anys True if any value is True alls True if all values are True Harmony also supports set comprehension. In its simplest form, { f(v) for v in s } returns a set that is constructed by applying f to all elements in s (where s is a set or a list). This is known as mapping. But set comprehension is much more powerful and can include joining multiple sets (using nested for loops) and filtering (using the where keyword). For example: { x + y for x in s for y in s such that (x * y ) == 4 } returns a set that is constructed by summing pairs of elements from s that, when multiplied, have the value 4 .","title":"1.4 Set"},{"location":"reference/language/value-types/#15-dictionary","text":"A dictionary maps a set of values (known as keys ) to another set of values. The generic syntax of a dictionary is { k 0 : v 0 , k 1 : v 1 , ... }. Different from Python, the empty dictionary is either () or [] (because {} is the empty set in Harmony). If there are duplicate keys in the list, then only the one with the maximum value survives. Therefore the order of the keys in the dictionary does not matter. Dictionaries support comprehension. The basic form is: { f(k) : g(k) fork in s }. There are various special cases of dictionaries, including lists, tuples, strings, and bags (multi-sets) that are individually described below. Operations on dictionaries include the following: d k indexing len d the number of keys in d keys d the set of keys in d v [not] in keys d check if v is a key in d v [not] in d check if v is a value in d min d the minimum value in d max d the maximum value in d any d True if any value is True all d True if all values are True d & d & ... dictionary intersection d \\| d \\| ... dictionary union Because in Harmony brackets are used for parsing purposes only, you can write d[k] (or d(k) ) instead of d k . However, if k is an atom, like .id , then you might prefer the notation k.id . Python users beware: the Harmony v in d operator checks if there is some key k such that d[k] = v . In Python, the same syntax checks if v is a key in d . The difference exists because in Harmony a list is a special case of a dictionary. Dictionary intersection and dictionary union are defined so that they work well with bags. With disjoint dictionaries, intersection and union work as expected. If there is a key in the intersection, then dictionary intersection retains the minimum value while dictionary union retains the maximum value. Unlike Python, Harmony dictionary intersection and union are commutative and associative.","title":"1.5 Dictionary"},{"location":"reference/language/value-types/#16-list-or-tuple","text":"In Harmony, there is no distinction between a list or a tuple. Both are a special case of dictionary. In particular, a list of n values is represented by a dictionary that maps the integers 0, ..., n\u22121 to those values. Hence, if t is a list or tuple, then the notation t[0] returns the first element of the list. You can denote a list by a sequence of values, each value terminated by a comma. As per usual, you can use brackets or parentheses at your discretion. For Python users, the important thing to note is that a singleton list in Harmony must contain a comma. For example [1,] is a list containing the value 1, while [1] is simply the value 1. The list module contains various convenient routines that operate on lists or tuples. Native operations on lists or tuples include the following: t k indexing t + t + ... concatenation t * n n copies of t concatenated v [not] in t check if v is a value in t len t the length of t min t the minimum value in t max t the maximum value in t any t True if any value is True all t True if all values are True t & t & ... pairwise list minimum t | t | ... pairwise list maximum Lists and tuples support comprehension as well. In their most basic form: f(v) for v in s . For example, to check if any element in a list t is even, you can write: any((x%2) == 0 for x in t) .","title":"1.6 List or Tuple"},{"location":"reference/language/value-types/#17-string","text":"In Harmony, a string is a list of single-character atoms. The Python string notations mostly work in Harmony as well. For example, \u2019abc\u2019 is a three-character string consisting of the atoms .a , .b , and .c . \"abc\" is the same three-character string. Various special characters (including quotes, newlines, etc.) can be escaped using a backslash. Multi-line strings can be terminated by triple quotes or triple double-quotes. Native operations on strings include the following: s k indexing s + s + ... concatenation s * n n copies of s concatenated c[not] in s check if c (a one-character atom) is in s len s the length of s","title":"1.7 String"},{"location":"reference/language/value-types/#18-bag-or-multiset","text":"A bag is represented by a dictionary that maps each element to its multiplicity, for example: { 10:2, 12:1 }. The bag module contains various convenient routines that operate on lists or tuples. Native operations on bags include the following: v[not] in keys b check if v is in b t & t & ... bag intersection t \\| t \\| ... bag union","title":"1.8 Bag or Multiset"},{"location":"reference/language/value-types/#19-program-counter","text":"A program counter is an integer that can be used to index into Harmony bytecode. When you define a method, a lambda function, or a label, you are creating a constant of the program counter type. Operations on program counters include the following: | m a | invoke method with program counter m and argument `a | | atLabel l | return a bag of (method, argument) pairs of threads executing at label l | You can create lambda functions similarly to Python. For example: lambda(x, y): x + y .","title":"1.9 Program Counter"},{"location":"reference/language/value-types/#110-address","text":"In Harmony, each shared variable has an address, which is essentially a list of Harmony values. For example, the address of variable d . v[3] consists of the list .d , .v , and 3 . The only way to construct an address in Harmony is using the ? operator. ?d.v[3] returns the address of variable d.v[3] . An address can be dereferenced to return the value of the variable. If a is an address, then !a returns the value. Like C, Harmony supports the shorthand a->v for the expression (!a).v .","title":"1.10 Address"},{"location":"reference/language/value-types/#111-context","text":"A context value captures the state of a thread. A context is itself composed over various Harmony values. Some of these values can be extracted. In particular, if c is a context, then: c.name returns the name of the thread\u2019s main method c.entry returns the program counter of the thread\u2019s main method c.arg returns the argument value of the thread\u2019s main method c.this returns the thread-local state c.mode returns themodeof the context The possible modes of a context are as follows: normal context of a executing thread stopped context of a stopped thread terminated context of a terminated thread failed context of a failed thread A thread can call getcontext() to retrieve its current context. Also, the function contexts() returns a bag of all contexts (including terminated ones). Both these functions should only be called in atomic mode and used for checking invariants.","title":"1.11 Context"},{"location":"reference/library/alloc/","text":"The alloc module The alloc module supports thread-safe (but not interrupt-safe) dynamic allocation of shared memory locations. There are just two methods: Method Description malloc(v) return a pointer to a memory location initialized to v free(p) free an allocated memory location p The usage is similar to malloc and free in C.malloc() is specified to return None when running out of memory, although this is an impossible outcome in the current implementation of the module.","title":"alloc"},{"location":"reference/library/alloc/#the-alloc-module","text":"The alloc module supports thread-safe (but not interrupt-safe) dynamic allocation of shared memory locations. There are just two methods: Method Description malloc(v) return a pointer to a memory location initialized to v free(p) free an allocated memory location p The usage is similar to malloc and free in C.malloc() is specified to return None when running out of memory, although this is an impossible outcome in the current implementation of the module.","title":"The alloc module"},{"location":"reference/library/bag/","text":"The bag module The bag module has various useful methods that operate on bags or multisets: Method Description empty() returns an empty bag fromSet(s) create a bag from sets fromList(t) convert list t into a bag count(b, e) count how many times e occurs in bag b bchoose(b) like choose(s) , but applied to a bag add(pb, e) add one copy of e to bag !pb remove(pb, e) remove one copy of e from bag !pb combinations(b, k) return set of all subbags of size k","title":"bag"},{"location":"reference/library/bag/#the-bag-module","text":"The bag module has various useful methods that operate on bags or multisets: Method Description empty() returns an empty bag fromSet(s) create a bag from sets fromList(t) convert list t into a bag count(b, e) count how many times e occurs in bag b bchoose(b) like choose(s) , but applied to a bag add(pb, e) add one copy of e to bag !pb remove(pb, e) remove one copy of e from bag !pb combinations(b, k) return set of all subbags of size k","title":"The bag module"},{"location":"reference/library/hoare/","text":"The hoare module The hoare module implements support for Hoare-style monitors and condition variables. Method Description Monitor() return a monitor mutex enter(m) enter a monitor. m points to a monitor mutex exit(m) exit a monitor Condition() return a condition variable wait(c, m) wait on condition variable pointed to be c in monitor pointed to by m signal(c, m) signal a condition variable","title":"hoare"},{"location":"reference/library/hoare/#the-hoare-module","text":"The hoare module implements support for Hoare-style monitors and condition variables. Method Description Monitor() return a monitor mutex enter(m) enter a monitor. m points to a monitor mutex exit(m) exit a monitor Condition() return a condition variable wait(c, m) wait on condition variable pointed to be c in monitor pointed to by m signal(c, m) signal a condition variable","title":"The hoare module"},{"location":"reference/library/list/","text":"The list module The list module has various useful methods that operate on lists or tuples: Method Description subseq(t,b,f) return a slice of list t starting at index b and ending just before f append(t,e) append e to list t head(t) return the first element of list t tail(t) return all but the first element of list t reversed(t) reverse a list sorted(t) sorted set or list set(t) convert values of a dict or list into a set list(t) convert set into a list values(t) convert values of a dict into a list sorted by key items(t) convert dict into (key, value) list sorted by key enumerate(t) like Python enumerate sum(t) return the sum of all elements int qsort(t) sort list t using quicksort","title":"list"},{"location":"reference/library/list/#the-list-module","text":"The list module has various useful methods that operate on lists or tuples: Method Description subseq(t,b,f) return a slice of list t starting at index b and ending just before f append(t,e) append e to list t head(t) return the first element of list t tail(t) return all but the first element of list t reversed(t) reverse a list sorted(t) sorted set or list set(t) convert values of a dict or list into a set list(t) convert set into a list values(t) convert values of a dict into a list sorted by key items(t) convert dict into (key, value) list sorted by key enumerate(t) like Python enumerate sum(t) return the sum of all elements int qsort(t) sort list t using quicksort","title":"The list module"},{"location":"reference/library/overview/","text":"Overview While The Harmony Language Reference describes the exact syntax and semantics of the Harmony language, this library reference manual describes the standard library that is distributed with Harmony. These modules provide additional functionality and common structures that are often used in concurrent programming. alloc bag hoare list set synch","title":"Overview"},{"location":"reference/library/overview/#overview","text":"While The Harmony Language Reference describes the exact syntax and semantics of the Harmony language, this library reference manual describes the standard library that is distributed with Harmony. These modules provide additional functionality and common structures that are often used in concurrent programming. alloc bag hoare list set synch","title":"Overview"},{"location":"reference/library/set/","text":"The set module The set module implements the following methods: Method Description issubset(s, t) returns whether s is a subset of t issuperset(s, t) returns whether s is a superset of t add(s, e) returns s \u222a {e} remove(s, e) returns s \u2212 {e} combinations(b, k) returns set of all subsets of size k For Python programmers: note that s <= t does not check if s is a subset of t when s and t are sets, as \u201c<=\u201d implements a total order on all Harmony values including sets.","title":"set"},{"location":"reference/library/set/#the-set-module","text":"The set module implements the following methods: Method Description issubset(s, t) returns whether s is a subset of t issuperset(s, t) returns whether s is a superset of t add(s, e) returns s \u222a {e} remove(s, e) returns s \u2212 {e} combinations(b, k) returns set of all subsets of size k For Python programmers: note that s <= t does not check if s is a subset of t when s and t are sets, as \u201c<=\u201d implements a total order on all Harmony values including sets.","title":"The set module"},{"location":"reference/library/synch/","text":"The synch module The synch module provides the following methods: Method Description tas(lk) test-and-set on !lk cas(ptr, old, new) compare-and-swap on !ptr BinSem(v) return a binary semaphore initialized to v Lock() return a binary semaphore initialized to False acquire(bs) acquire binary semaphore !bs release(bs) release binary semaphore !bs Condition() return a condition variable wait(c, lk) wait on condition variable !c and lock lk notify(c) notify a thread waiting on condition variable !c notifyAll(c) notify all threads waiting on condition variable !c Semaphore(cnt) return a counting semaphore initialized to cnt P(sema) procure !sema V(sema) vacate !sema Queue() return a synchronized queue object get(q) return next element of q , blocking if empty put(q, item) add item to a","title":"synch"},{"location":"reference/library/synch/#the-synch-module","text":"The synch module provides the following methods: Method Description tas(lk) test-and-set on !lk cas(ptr, old, new) compare-and-swap on !ptr BinSem(v) return a binary semaphore initialized to v Lock() return a binary semaphore initialized to False acquire(bs) acquire binary semaphore !bs release(bs) release binary semaphore !bs Condition() return a condition variable wait(c, lk) wait on condition variable !c and lock lk notify(c) notify a thread waiting on condition variable !c notifyAll(c) notify all threads waiting on condition variable !c Semaphore(cnt) return a counting semaphore initialized to cnt P(sema) procure !sema V(sema) vacate !sema Queue() return a synchronized queue object get(q) return next element of q , blocking if empty put(q, item) add item to a","title":"The synch module"}]}
# Value Types

Chapter 4 provides an introduction to Harmony values. Below is a complete list of Harmony value
types with examples:

| Type    | Example      |
| ------- | ------------ |
| Boolean | `False,True` |
| Integer | `-inf, ..., -2, -1, 0, 1, 2, ..., inf` |
| Atom    | `.example,.test1,.0x4A` |
| Program Counter | `(method names are program counter constants)` |
| Dictionary | `{.account: 12345, .valid: False }` |
| Set     | `{1, 2, 3},{ False, .id, 3}` |
| Address | `?lock, ?flags[2], None` |
| Context | `(generated bystopexpression)` |

<br />

Tuples, lists, strings, and bags are all special cases of dictionaries. Both tuples and lists map
indexes (starting at 0) to Harmony values. Their format is either `(e,e, ...,e,)` or `[e,e, ..., e,]`. If the tuple or list has two or more elements, then the final comma is optional. A string is
represented as a tuple of its characters. Characters are one-character atoms, which can be expressed
in hexadecimal unicode using the syntax `.0xXX`. A bag or multiset is a dictionary that maps a value to how many times it occurs in the bag.
All Harmony values are ordered with respect to one another. First they are ordered by type
according to the table above. So, for example, `True < 0 < .xyz < { 0 })`. Within types, the
following rules apply:

- `False < True`;
- integers are ordered in the natural way;
- atoms are lexicographically ordered;
- program counters are ordered by their integer values;
- dictionaries are first converted into a list of ordered (key, value) pairs. Then two dictionaries
    are lexicographically ordered by this representation;
- a set is first converted into an ordered list, then lexicographically ordered;


- an address is a list of atoms. `None` is the empty list of atoms. Addresses are lexicographically ordered accordingly;
- contexts (Appendix E) are ordered first by name, then by program counter, then by the remaining content.


Generic operators on Harmony values include:

|        |             |
| ------ | ----------- |
| `e == e` | equivalence |
| `e != e` | inequivalence |
| `e < e, e <=e, e > e, e >= e` | comparison |

<br />

## A.1 Boolean

The Boolean type has only two possible values: `False` and `True`. Unlike in Python, in Harmony
booleans are distinct from integers, and in particular `False < 0`. In statements and expressions
where booleans are expected, it is not possible to substibute values of other types.
Operations on booleans include:

|        |         |
| ------ | ------- |
| `e and e and ...` | conjuction |
| `e or e or ...` | disjunction |
| `e => e, e not => e` | implication |
| `not e` | negation |
| `v if e else v′ v or v′` | depending one |
| `anys, alls` | disjunction / conjunction for set or lists |

<br />

## A.2 Integer

The integer type supports any whole number, as well as `−inf` and `inf`. In the Python-based model checker, integers are infinite precision. In the C-based model checker, integers are implemented
by two’s complement 61-bit words, and `−inf` is represented by the minimal integer and `inf` is represented by the maximal integer.
Operations on integers include:

|        |         |
| ------ | ------- |
| `-e` | negation |
| `abs(e)` | absolute value |
| `e + e + ...` | sum |
| `e - e` | difference |
| `e * e * e ...` | product |
| `e / e, e // e` | integer division |
| `e % e, e mod e` | integer division remainder |
| `e ** e` | power |
| `~e` | binary inversion |
| `e & e & ...` | binary and |
| `e \| e \| ...` | binary or |
| `e ^ e ^ ...` | binary exclusive or |
| `e << e` | binary shift left |
| `e >> e` | binary shift right |
| `{e..e′}` | set of integers from e to e′ inclusive |

<br />

## A.3 Atom

Atoms are essentially names and consist of one or more unicode characters. If they do not contain
special characters and do not start with a digit, then an atom can be represented by a “.” followed
by the characters. For example, `.hello` is a representation of the atom “hello”. A special character
can be represented by `.0xXX`, where `XX` is the hexidecimal unicode for the character. Atoms should
not be confused with strings. There are no special operations on atoms. (In the future, operators
may be introduced that convert between strings and atoms.)

## A.4 Set

In Harmony you can create a set of any collection of Harmony values. Its syntax is { v<sub>0</sub>, v<sub>1</sub>, ... }.
Python users: note that in Harmony the empty set is denoted as `{}`.
The `set` module (Section C.5) contains various convenient routines that operate on sets. Native operations on sets include:

|        |         |
| ------ | ------- |
| `lens` | cardinality |
| `s - s` | set difference |
| `s & s & ...` | intersection |
| `s \| s \| ...` | union |
| `s ^ s ^ ...` | inclusion/exclusion (elements in odd number of sets) |
| `choose s` | select an element (Harmony will try all) |
| `mins` | minimum element |
| `maxs` | maximum element |
| `anys True` | if any value is True |
| `alls True` | if all values are True |

<br />
Harmony also supports set comprehension. In its simplest form, { f(v) for v in s } returns
a set that is constructed by applying `f` to all elements in `s` (where `s` is a set or a list). This is known as mapping. But set comprehension is much more powerful and can include joining multiple sets
(using nested for loops) and filtering (using the `where` keyword).
For example: { x + y for x in s for y in s such that (x * y ) == 4 } returns a set that is constructed by summing pairs of elements from `s` that, when multiplied, have the value `4`.

## A.5 Dictionary

A dictionary maps a set of values (known as `keys`) to another set of values. The generic syntax
of a dictionary is { k<sub>0</sub> : v<sub>0</sub> , k<sub>1</sub> : v<sub>1</sub>, ... }. Different from Python, the empty dictionary is either `()` or `[]` (because `{}` is the empty set in Harmony). If there are duplicate keys in the list, then only the
one with the maximum value survives. Therefore the order of the keys in the dictionary does not matter. Dictionaries support comprehension. The basic form is: { f(k) : g(k) fork in s }.
There are various special cases of dictionaries, including lists, tuples, strings, and bags (multi-sets) that are individually described below.
Operations on dictionaries include the following:

|        |         |
| ------ | ------- |
| `d k` | indexing |
| `len d` | the number of keys in d |
| `keys d` | the set of keys in d |
| `v [not] in keys d` | check if v is a key in d |
| `v [not] in d` | check if v is a value in d |
| `min d` | the minimum value in d |
| `max d` | the maximum value in d |
| `any d` | True if any value is True |
| `all d` | True if all values are True |
| `d & d & ...` | dictionary intersection |
| `d \| d \| ...` | dictionary union |

<br />
Because in Harmony brackets are used for parsing purposes only, you can write `d[k]` (or `d(k)`) instead of `d k`. However, if `k` is an atom, like `.id`, then you might prefer the notation `k.id`.
Python users beware: the Harmony `v in d` operator checks if there is some key `k` such that
`d[k] = v`. In Python, the same syntax checks if `v` is a key in `d`. The difference exists because in
Harmony a list is a special case of a dictionary.
Dictionary intersection and dictionary union are defined so that they work well with bags. With
disjoint dictionaries, intersection and union work as expected. If there is a key in the intersection,
then dictionary intersection retains the minimum value while dictionary union retains the maximum
value. Unlike Python, Harmony dictionary intersection and union are commutative and associative.

## A.6 List or Tuple

In Harmony, there is no distinction between a list or a tuple. Both are a special case of dictionary.
In particular, a list of n values is represented by a dictionary that maps the integers `0, ..., n−1` to
those values. Hence, if `t` is a list or tuple, then the notation `t[0]` returns the first element of the list.


You can denote a list by a sequence of values, each value terminated by a comma. As per usual,
you can use brackets or parentheses at your discretion. For Python users, the important thing to
note is that a singleton list in Harmony must contain a comma. For example [1,] is a list containing
the value 1, while [1] is simply the value 1.
The [`list` module](../library/list.md) contains various convenient routines that operate on lists or
tuples. Native operations on lists or tuples include the following:

|        |         |
| ------ | ------- |
| `t k` | indexing |
| `t + t + ...` | concatenation |
| `t * n n copies of t` | concatenated |
| `v [not] in t` | check if v is a value in t |
| `len t` | the length of t |
| `min t` | the minimum value in t |
| `max t` | the maximum value in t |
| `any t` | True if any value is True |
| `all t` | True if all values are True |
| `t & t & ...` | pairwise list minimum |
| t \| t \| ... | pairwise list maximum |

<br />
Lists and tuples support comprehension as well. In their most basic form: `f(v) for v in s`.
For example, to check if any element in a list t is even, you can write: `any((x%2) == 0 for x in t)`.

## A.7 String

In Harmony, a string is a list of single-character atoms. The Python string notations mostly work
in Harmony as well. For example, `’abc’` is a three-character string consisting of the atoms `.a`,
`.b`, and `.c`. `"abc"` is the same three-character string. Various special characters (including quotes,
newlines, etc.) can be escaped using a backslash. Multi-line strings can be terminated by triple
quotes or triple double-quotes.
Native operations on strings include the following:

|        |         |
| ------ | ------- |
| `s k` | indexing |
| `s + s + ...` | concatenation |
| `s * n` | n copies of s concatenated |
| `c[not] in s` | check if `c` (a one-character atom) is in `s` |
| `len s` | the length of `s` |

<br />

## A.8 Bag or Multiset

A bag is represented by a dictionary that maps each element to its multiplicity, for example: { 10:2,
12:1 }. The [`bag` module](../library/bag.md) contains various convenient routines that operate on lists or
tuples. Native operations on bags include the following:

|        |         |
| ------ | ------- |
| `v[not] in keys b` | check if v is in b |
| `t & t & ...` | bag intersection |
| `t \| t \| ...` | bag union |

<br />

## A.9 Program Counter

A program counter is an integer that can be used to index into Harmony bytecode. When you
define a method, a lambda function, or a label, you are creating a constant of the program counter
type.
Operations on program counters include the following:

| `m a` | invoke method with program counter `m` and argument ``a` |
| `atLabel l` | return a bag of (method, argument) pairs of threads executing at label `l` |
<br />

You can create lambda functions similarly to Python. For example: `lambda(x, y): x + y`.

## A.10 Address

In Harmony, each shared variable has an address, which is essentially a list of Harmony values.
For example, the address of variable `d`. `v[3]` consists of the list `.d`, `.v`, and `3`. The only way to construct an address in Harmony is using the `?` operator. `?d.v[3]` returns the address of variable
`d.v[3]`. An address can be dereferenced to return the value of the variable. If `a` is an address, then
`!a` returns the value. Like C, Harmony supports the shorthand `a->v` for the expression `(!a).v`.

## A.11 Context

A context value captures the state of a thread. A context is itself composed over various Harmony
values. Some of these values can be extracted. In particular, if `c` is a context, then:

|        |         |
| ------ | ------- |
| `c.name` | returns the name of the thread’s main method |
| `c.entry` | returns the program counter of the thread’s main method |
| `c.arg` | returns the argument value of the thread’s main method |
| `c.this` | returns the thread-local state |
| `c.mode` | returns themodeof the context |

<br />

The possible modes of a context are as follows:

|        |         |
| ------ | ------- |
| `normal` | context of a executing thread |
| `stopped` | context of a stopped thread |
| `terminated` | context of a terminated thread |
| `failed` | context of a failed thread |

<br />

A thread can call `getcontext()` to retrieve its current context. Also, the function `contexts()`
returns a bag of all contexts (including terminated ones). Both these functions should only be
called in `atomic` mode and used for checking invariants.
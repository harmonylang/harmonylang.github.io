{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Harmony","text":""},{"location":"#overview","title":"Overview","text":"<ul> <li>Quick Start - Get started with Harmony</li> <li>Online Textbook - Learn about concurrent programming</li> <li>Language Reference - Language features and syntax</li> <li>Library Reference - Built in modules and libraries</li> <li>Changelog - What's new in Harmony?</li> </ul> <p>For complete documentation in a downloadable form, please see the PDF version of the textbook.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v122769","title":"v1.2.2769","text":"<ul> <li>Added direct run option</li> <li>Added detail to output and output files</li> <li>Improved operator explainations</li> <li>Improved browser visualizations</li> <li>Updated modules with additional built-ins</li> <li>Renamed <code>name</code> to <code>entry</code></li> <li>Removed <code>atLabel</code> entirely</li> <li>Greatly improved performance</li> <li>Added documentation</li> <li>Bug fixes</li> </ul>"},{"location":"changelog/#v122376","title":"v1.2.2376","text":"<ul> <li>Added print statements</li> <li>Added DFA output graphs</li> <li>Removed the <code>@</code> tag from labeled statements</li> <li>Bug fixes</li> </ul>"},{"location":"changelog/#v120","title":"v1.2.0","text":"<ul> <li>Added <code>let-when</code> statements</li> <li>Renamed <code>once</code> to <code>when</code></li> <li>Added <code>possibly</code> statement</li> <li>Added <code>atomically</code></li> <li>Added \"-i\" flag</li> <li>All labels within a module are now global</li> <li>Replaced all non-constant \"let\" with \"var</li> <li>Atomic blocks / assertion checking now \"lazy\"</li> <li>Improved error reporting</li> <li>Improved parsing and robustness</li> <li>Bug fixes</li> </ul>"},{"location":"changelog/#v11","title":"v1.1","text":"<ul> <li>Now detects busy waiting and data races</li> <li>New <code>sequential</code> keyword to tag sequentially consistent variables </li> <li>Removed \"interlock\" term</li> <li>Improved error reporting</li> <li>Improved parsing and robustness</li> <li>Bug fixes</li> </ul>"},{"location":"changelog/#v10","title":"v1.0","text":"<ul> <li>Rewrote model checker in C for much faster performance</li> <li>Removed semicolons as a syntax requirement</li> <li>Updated imports syntax</li> <li>Requires Python3 and GCC in path to run</li> </ul>"},{"location":"changelog/#v09","title":"v0.9","text":"<ul> <li>Initial release of the Harmony Language</li> <li>Model checker for concurrent programs</li> <li>HTML output with steps and shortest path to failure</li> <li>Required Python3 to run</li> </ul>"},{"location":"guides/introduction/","title":"Introduction","text":"<p>Harmony is a Python-like programming language for testing and experimenting with concurrent programs. Instead of \"running\" code, Harmony programs are model-checked so that all corner cases are explored. If there is a problem, Harmony provides a short but detailed example of an execution that leads to the problem.</p> <p>Here is Peterson's Algorithm in Harmony, along with code to verify mutual exclusion:</p> peterson.hny<pre><code>sequential flags, turn\n\nflags = [ False, False ]\nturn = choose({0, 1})\n\ndef thread(self):\n    while choose({ False, True }):\n        # Enter critical section\n        flags[self] = True\n        turn = 1 - self\n        await (not flags[1 - self]) or (turn == self)\n\n        # Critical section is here\n        cs: assert countLabel(cs) == 1\n\n        # Leave critical section\n        flags[self] = False\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> <p>Harmony allows two sources of non-determinism: interleaving of concurrent process executions and choose(S) expressions that select some element from set S. Running Harmony finds that no interleaving and no possible choices lead to the assertion being violated. Moreover, Harmony also finds that processes do not get stuck, indefinitely waiting to enter the critical section.</p>"},{"location":"guides/introduction/#get-started","title":"Get Started","text":"<p>Learning programming in Harmony should be straightforward to those familiar with Python or similar languages.</p> <p>On Concurrent Programming in Harmony, written by Prof. Robbert Van Renesse at Cornell University, remains the primary source of documentation for the Harmony language. It contains the documentation for the language and built-in libraries, along with a full course on concurrent programming.</p> <p>Read it online or download the latest version!</p> <p>On Concurrent Programming in Harmony is licenced under the terms of the Creative Commons Attribution NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) at http://creativecommons.org/licenses/by-nc-sa/4.0.</p>"},{"location":"textbook/","title":"On Concurrent Programming in Harmony  by Robbert van Renesse","text":"<p>On Concurrent Programming in Harmony is licenced under the terms of the Creative Commons Attribution NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) at http://creativecommons.org/licenses/by-nc-sa/4.0.</p> <p>Programming with concurrency is hard. On the one hand concurrency can make programs faster than sequential ones, but having multiple threads read and update shared variables concurrently and synchronize with one another makes programs more complicated than programs where only one thing happens at a time. Why are concurrent programs more complicated than sequential ones? There are, at least, two reasons:</p> <ul> <li> <p>The execution of a sequential program is mostly deterministic. If     you run it twice with the same input, the same output will be     produced. Bugs are typically easily reproducible and easy to track     down, for example by instrumenting the program. On the other hand,     the output of running concurrent programs depends on how the     execution of the various threads are interleaved. Some bugs may     occur only occasionally and may never occur when the program is     instrumented to find them (so-called Heisenbugs---overhead caused     by instrumentation leads to timing changes that makes such bugs less     likely to occur).</p> </li> <li> <p>In a sequential program, each statement and each function can be     thought of as happening atomically (indivisibly) because there is     no other activity interfering with their execution. Even though a     statement or function may be compiled into multiple machine     instructions, they are executed back-to-back until completion. Not     so with a concurrent program, where other threads may update memory     locations while a statement or function is being executed.</p> </li> </ul> <p>The lack of determinism and atomicity in concurrent programs make them not only hard to reason about, but also hard to test. Running the same test of concurrent code twice is likely to produce two different results. More problematically, a test may trigger a bug only for certain \"lucky\" executions. Due to the probabilistic nature of concurrent code, some bugs may be highly unlikely to get triggered even when running a test millions of times. And even if a bug does get triggered, the source of the bug may be hard to find because it is hard to reproduce.</p> <p>This book is intended to help people with understanding and developing concurrent code, which includes programs for distributed systems. In particular, it uses a tool called Harmony that helps with testing concurrent code. The approach is based on model checking: instead of relying on luck, Harmony will run all possible executions of a particular test program. So, even if a bug is unlikely to occur, if the test can expose the bug it will. Moreover, if the bug is found, the model checker precisely shows how to trigger the bug in the smallest number of steps.</p> <p>Model checking is not a replacement for formal verification. Formal verification proves that a program is correct. Model checking only verifies that a program is correct for some model. Think of a model as a test program. Because model checking tries every possible execution, the test program needs to be simple---otherwise it may take longer than we care to wait for or run out of memory. In particular, the model needs to have a relatively small number of reachable states.</p> <p>If model checking does not prove a program correct, why is it useful? To answer that question, consider a sorting algorithm. Suppose we create a test program, a model, that tries sorting all lists of up to five numbers chosen from the set { 1, 2, 3, 4, 5 }. Model checking proves that for those particular scenarios the sorting algorithm works: the output is a sorted permutation of the input. In some sense it is an excellent test: it will have considered all corner cases, including lists where all numbers are the same, lists that are already sorted or reversely sorted, etc. If there is a bug in the sorting algorithm, most likely it would be triggered and the model checker would produce a scenario that would make it easy to find the source of the bug.</p> <p>However, if the model checker does not find any bugs, we do not know for sure that the algorithm works for lists of more than five numbers or for lists that have values other than the numbers 1 through 5. Still, we would expect that the likelihood that there are bugs remaining in the sorting algorithm is small. That said, it would be easy to write a program that sorts all lists of up to five numbers correctly but fails to do so for a list of 6 numbers. (Hint: simply use an if statement.)</p> <p>While model checking does not in general prove an algorithm correct, it can help with proving an algorithm correct. The reason is that many correctness properties can be proved using invariants: predicates that must hold for every state in the execution of a program. A model checker can find violations of proposed invariants when evaluating a model and provide valuable early feedback to somebody who is trying to construct a proof, even an informal one. We will include examples of such invariants as they often provide excellent insight into why a particular algorithm works.</p> <p>So, what is Harmony? Harmony is a concurrent programming language. It was designed to teach the basics of concurrent and distributed programming, but it is also useful for testing new concurrent algorithms or even sequential and distributed algorithms. Harmony programs are not intended to be \"run\" like programs in most other programming languages---instead Harmony programs are model checked to test that the program has certain desirable properties and does not suffer from bugs.</p> <p>The syntax and semantics of Harmony is similar to that of Python. Python is familiar to many programmers and is easy to learn and use. We will assume that the reader is familiar with the basics of Python programming. We also will assume that the reader understands some basics of machine architecture and how programs are executed. For example, we assume that the reader is familiar with the concepts of CPU, memory, register, stack, and machine instructions.</p> <p>Harmony is heavily influenced by Leslie Lamport's work on TLA+, TLC, and PlusCal, Gerard Holzmann's work on Promela and SPIN, and University of Washington's DSLabs system. Some of the examples in this book are derived from those sources. Harmony is designed to have a lower learning curve than those systems, but is not as powerful. When you finish this book and want to learn more, we strongly encourage checking those out. Another excellent resource is Fred Schneider's book \"On Concurrent Programming\". (This chapter is named after that book.)</p> <p>The book proceeds as follows:</p> <ul> <li> <p>Chapter 2 introduces the Harmony programming language, as     it provides the language for presenting synchronization problems and     solutions.</p> </li> <li> <p>Chapter 3 illustrates the problem of concurrent programming     through a simple example in which two threads are concurrently     incrementing a counter.</p> </li> <li> <p>Chapter 4 presents the Harmony virtual machine to     understand the problem underlying concurrency better.</p> </li> <li> <p>Chapter 5 introduces the concept of a critical section and     presents various flawed implementations of critical sections to     demonstrate that implementing a critical section is not trivial.</p> </li> <li> <p>Chapter 6 introduces Peterson's Algorithm, an elegant     (although not very efficient or practical) solution to     implementating a critical section.</p> </li> <li> <p>Chapter 7 gives some more details on the Harmony language needed     for the rest of the book.</p> </li> <li> <p>Chapter 8 talks about how Harmony can be used as a     specification language. It introduces how to specify atomic     constructs.</p> </li> <li> <p>Chapter 9 introduces atomic locks for implemented critical     sections.</p> </li> <li> <p>Chapter 10 looks at various ways in which the lock specification     in Chapter 8 can be implemented.</p> </li> <li> <p>Chapter 11 gives an introduction to building concurrent data     structures.</p> </li> <li> <p>Chapter 12 gives an example of fine-grained locking methods     that allow more concurrency than coarse-grained approaches..</p> </li> <li> <p>Chapter 13 discusses approaches to testing concurrent code in     Harmony.</p> </li> <li> <p>Chapter 14 instead goes into how to find a bug in concurrent     code using the Harmony output.</p> </li> <li> <p>Chapter 15 talks about threads having to wait for certain     conditions. As examples, it presents the reader/writer lock problem     and the bounded buffer problem.</p> </li> <li> <p>Chapter 16 presents Split Binary Semaphores, a general technique     for solving synchronization problems.</p> </li> <li> <p>Chapter 17 talks about starvation: the problem that in some     synchronization approaches threads may not be able to get access to     a resource they need.</p> </li> <li> <p>Chapter 18 presents monitors and condition variables,     another approach to thread synchronication.</p> </li> <li> <p>Chapter 19 describes deadlock where a set of threads are     indefinitely waiting for one another to release a resource.</p> </li> <li> <p>Chapter 20 presents the actor model and message passing as an     approach to synchronization.</p> </li> <li> <p>Chapter 21 describes barrier synchronization, useful in     high-performance computing applications such as parallel     simulations.</p> </li> <li> <p>Chapter 22 discusses how to handle interrupts, a problem     closely related to---but not the same as---synchronizing threads.</p> </li> <li> <p>Chapter 23 introduces non-blocking or wait-free     synchronization algorithms, which prevent threads waiting for one     another more than a bounded number of steps.</p> </li> <li> <p>Chapter 24 presents a problem and a solution to the distributed     systems problem of having two threads communicate reliably over an     unreliable network.</p> </li> <li> <p>Chapter 25 presents a protocol for electing a leader on a ring of     processors, where each processor is uniquely identified and only     knows its successor on the ring.</p> </li> <li> <p>Chapter 26 describes atomic database transactions and the two-phase     commit protocol used to implement them.</p> </li> <li> <p>Chapter 27 describes state machine replication and the chain     replication protocol to support replication.</p> </li> <li> <p>Chapter 28 describes an alternative way to write concurrent and distributed      specifications in Harmony, using chain replication as an example.</p> </li> <li> <p>Chapter 29 presents a protocol for a fault-tolerant replicated     object that supports only read and write operations.</p> </li> <li> <p>Chapter 30 demonstrates a fault-tolerant distributed consensus     algorithm (aka protocol) expressed in Harmony.</p> </li> <li> <p>Chapter 31 shows how one can specify and check the well-known     Paxos consensus protocol.</p> </li> <li> <p>Chapter 32 demonstrates using Harmony to find a (known) bug in the     original Needham-Schroeder authentication protocol.</p> </li> </ul> <p>If you already know about concurrent and distributed programming and are just interested in a \"speed course\" on Harmony, I would recommend reading Chapter 2, Chapter 4, Chapter 7, Chapter 8, and Chapter 11. The appendices contain various details about Harmony itself, including an appendix on convenient Harmony modules, and an appendix that explains how Harmony works.</p>"},{"location":"textbook/2pc/","title":"Transactions and Two Phase Commit","text":"<p>Modern databases support multiple clients concurrently accessing the data. They store data on disk, but we will ignore that in this book. (If you want to model a disk, this is probably best done as a separate thread that maintains the contents of the disk.) The complication we address here is that databases may be sharded, where different parts of the data are stored on different servers. The different servers may even be under different authoritive domains, such as multiple banks maintaining the accounts of their clients.</p> <p>In database terminology, a transaction is an operation on a database. The operation can be quite complex, and the execution of a transaction should have the following two properties:</p> <ul> <li> <p>all-or-nothing: a transaction should either complete, or it should     be a no-op. It should never partially execute and then give up     because of some kind of error or something. Database people call     this atomicity, but it is not the same kind of atomicity that we     have been discussing in this book.</p> </li> <li> <p>serialized: any two concurrent transactions should appear to     execute in some order. Database people call this isolation: one     transaction should not be able to witness the intermediate state of     another transaction in execution.</p> </li> </ul> <p>We will use as an example a distributed database that maintains bank accounts. For simplicity, we will model this as a collection of banks, each maintaining a single account. There are two kinds of transactions: transfer (similar to Exercise 19.2) and check. In this example, a transfer is a transaction that moves some funds between two accounts. A check is a transaction over all accounts and checks that the sum of the balances across the accounts remains the same.</p> <p>Executing such transactions must be done with care. Consider what would happen if transactions are not all-or-nothing or are not serialized. A transfer consists of two operations: withdrawing funds from one account and depositing the same amount of funds in the other. These two operations can be done concurrently, but if the withdrawal fails (for example, because there are not sufficient funds in the source account) then the whole transaction should fail and become a no-op. Even if this is not the case, a concurrent check transaction may accidentally witness a state in which either the withdrawal or the deposit happened, but not both. And matters get more complicated with multiple concurrent transfers.</p> 2pc.hny<pre><code>network = {}\n\ndef send(msg):\n    atomically network |= { msg }\n\ndef bank(self, _balance):\n    var balance = _balance\n    var status, received = (), {}\n    while True:\n        atomically when exists req in network - received when req.dst == self:\n            received |= { req }\n            if req.request == \"withdraw\":\n                if (status != ()) or (req.amount &gt; balance):\n                    send({ .dst: req.src, .src: self, .response: \"no\" })\n                else:\n                    status = balance\n                    balance -= req.amount\n                    send({ .dst: req.src, .src: self, .response: \"yes\", .funds: balance })\n            elif req.request == \"deposit\":\n                if status != ():\n                    send({ .dst: req.src, .src: self, .response: \"no\" })\n                else:\n                    status = balance\n                    balance += req.amount\n                    send({ .dst: req.src, .src: self, .response: \"yes\", .funds: balance })\n            elif req.request == \"commit\":\n                assert status != ()\n                status = ()\n            else:\n                assert (status != ()) and (req.request == \"abort\")\n                balance, status = status, ()\n</code></pre> Figure 26.1 (code/2pc.hny):  Two Phase Commit protocol: code for banks  <p>The Two-Phase Commit protocol is a protocol that can be used to implement transactions across multiple database servers---banks in this case. Each transaction has a coordinator that sends a <code>PREPARE</code> message to each of the servers involved in the transaction, asking them to prepare to commit to their part in a particular transaction. A server can either respond with <code>YES</code> if it is ready to commit and will avoid doing anything that might jeopardize this (like committing a conflicting transaction), or with <code>NO</code> if it does not want to participate in the transaction. If all servers respond with <code>YES</code>, then the coordinator can decide to commit the transaction. Otherwise the coordinator must decide to abort the transaction. In the second phase, the servers that responded with <code>YES</code> (if any) must be notified to inform them of the coordinator's decision.</p> <p>Different transactions can have different coordinators. In our implementation, each bank and each coordinator is a thread. Figure 26.1 shows the code for a bank. The state of a bank consists of the following local variables:</p> <ul> <li> <p>self: the bank's identifier;</p> </li> <li> <p>balance: the current balance in the account;</p> </li> <li> <p>status: either contains () if the bank is not involved in an     ongoing transaction or contains the balance just before the     transaction started;</p> </li> <li> <p>received: the set of messages received and handled so far.</p> </li> </ul> <p>Messages sent to a bank are dictionaries with the following fields:</p> <ul> <li> <p>.dst: identifier of the bank;</p> </li> <li> <p>.src: identifier of the coordinator that sent the message;</p> </li> <li> <p>.request: request type, which is either .withdraw, .deposit,     .commit, or .abort;</p> </li> <li> <p>.amount: amount to withdraw or deposit.</p> </li> </ul> <p>A bank waits for a message destined to itself that it has not yet received. In case of a withdrawal when the bank is idle and there are sufficient funds, the bank saves the current balance in status to indicate an ongoing transaction and what its original balance was. The bank then responds with a .yes message to the coordinator, including the new balance. Otherwise, the bank responds with a .no message. Deposits are similar, except that it is not necessary to check for sufficient funds. In case of a .commit message, the bank changes its status to (), indicating that there is no ongoing transaction. In case of a .abort message, the bank restores balance first.</p> 2pc.hny<pre><code>import list\n\ndef transfer(self, b1, b2, amt):\n    send({ .dst: b1, .src: self, .request: \"withdraw\", .amount: amt })\n    send({ .dst: b2, .src: self, .request: \"deposit\", .amount: amt })\n    atomically let msgs = { m for m in network where m.dst == self }\n    when { m.src for m in msgs } == { b1, b2 }:\n        if all(m.response == \"yes\" for m in msgs):\n            for m in msgs where m.response == \"yes\":\n                send({ .dst: m.src, .src: self, .request: \"commit\" })\n        else:\n            for m in msgs where m.response == \"yes\":\n                send({ .dst: m.src, .src: self, .request: \"abort\" })\n\ndef check(self, total):\n    let allbanks = { (.bank, i) for i in { 1 .. NBANKS } }:\n        for bank in allbanks:\n            send({ .dst: bank, .src: self, .request: \"withdraw\", .amount: 0 })\n        atomically let msgs = { m for m in network where m.dst == self }\n        when { m.src for m in msgs } == allbanks:\n            assert all(m.response == \"yes\" for m in msgs) =&gt;\n                        (list.sum(m.funds for m in msgs) == total)\n            for m in msgs where m.response == \"yes\":\n                send({ .dst: m.src, .src: self, .request: \"abort\" })\n\nlet balances = { i:choose({ 0 .. MAX_BALANCE }) for i in { 1 .. NBANKS } }:\n    for i in { 1 .. NBANKS }:\n        spawn eternal bank((.bank, i), balances[i])\n    for i in { 1 .. NCOORDS }:\n        if choose({ \"transfer\", \"check\" }) == .transfer:\n            let b1 = choose({ (.bank, j) for j in { 1 .. NBANKS }})\n            let b2 = choose({ (.bank, j) for j in { 1 .. NBANKS }} - { b1 }):\n                spawn transfer((.coord, i), b1, b2, 1)\n        else:\n            spawn check((.coord, i), list.sum(balances))\n</code></pre> Figure 26.2 (code/2pc.hny):  Two Phase Commit protocol: code for transaction coordinators  <p>Figure 26.2 contains the code for transfers and inquiries, as well as tests. The <code>receive</code>() method is used by coordinators in an atomically when exists statement to wait for a response from each bank involved in a transaction. Argument <code>self</code> is the identifier of the coordinator and <code>sources</code> is the set of banks. It returns the empty set if there not yet responses from all banks. Otherwise it returns a singleton set containing the set of responses, one for each source.</p> <p>The <code>transfer</code>() method contains the code for the transfer transaction. Argument self is the identifier of the coordinator, b1 is the source bank, b2 is the destination bank, and amt is the amount to transfer. The coordinator sends a <code>PREPARE</code> message containing a .withdraw request to b1 and a <code>PREPARE</code> message containing a .deposit request to b2. It then waits for responses from each. If both responses are .yes, then it commits the transaction, otherwise it aborts the transaction.</p> <p>The <code>check</code>() method checks if the sum of the balances equals <code>total</code>, the sum of the initial balances. The code is similar to <code>transfer</code>, except that it always aborts the transaction---there is no need to ever commit it. As a code-saving hack: the balance inquiry is done by withdrawing $0.</p> <p>As for testing, the initial balances are picked arbitrarily between 0 and <code>MAX_BALANCE</code> (and Harmony as always will try every possible set of choices). Each coordinator chooses whether to do a transfer or a check. In case of a transfer, it also chooses the source bank and the destination bank.</p> <p>While the protocol perhaps seems simple enough, there are a lot of if statements in the code, making it hard to reason about correctness. Model checking is useful to see if there are corner cases where the code does not work. While confidence increases by increasing the number of banks or the number of coordinators, doing so quickly increases the number of possible states so that model checking may become infeasible.</p>"},{"location":"textbook/2pc/#exercises","title":"Exercises","text":"<p>26.1 In Exercise 19.2 the code ran into a deadlock. Can the code in this chapter run into a deadlock? Explain.</p> <p>26.2 Transactions can fail for two reasons: a transfer transaction can fail because of insufficient funds, but in general transaction can fail if there is a conflict with another transaction. The latter can be fixed by retrying the transaction until it commits. Implement this.</p> <p>26.3 One way to reduce the number of conflicts between transactions is to distinguish read and write operations. Two read operations (in our case, operations that withdraw $0) do not conflict, so a bank could have multiple ongoing read operations for different transactions. Implement this.</p> <p>26.4 Two-phase commit can tolerate servers failing. If a server does not respond within some reasonable amount of time, the coordinator can abort the transaction. Implement this.</p>"},{"location":"textbook/abd/","title":"Replicated Atomic Read/Write Register","text":"register.hny<pre><code>reg = None\n\ndef init():\n    pass\n\ndef read(uid) returns contents:\n    atomically contents = reg\n\ndef write(uid, v):\n    atomically reg = v\n</code></pre> Figure 29.1 (code/register.hny):  An atomic read/write register  <p>A register is an object that you can read or write. In a distributed system, examples include a shared file system (each file is a register) or a key/value store (each key corresponds to a register). A simple shared register implementation would have its value maintained by a server, and clients can read or write the shared register by exchanging messages with the server. We call two operations such that one does not finish before the other starts concurrent. Since messages are delivered one at a time to the server, concurrent operations on the shared register appear atomic. In particular, we have the following three desirable properties:</p> <ol> <li> <p>All write operations are ordered;</p> </li> <li> <p>A read operation returns either the last value written or the value     of a concurrent write operation.</p> </li> <li> <p>If read operation \\(r_1\\) finishes before read operation \\(r_2\\) starts,     then \\(r_2\\) cannot return a value that is older than the value     returned by \\(r_1\\).</p> </li> </ol> <p></p> abdtest.hny<pre><code>import register\n\nconst NREADERS = 2\nconst NWRITERS = 1\n\ndef reader(i):\n    print(i, \"reads\")\n    let v = register.read(i):\n        print(i, \"read\", v)\n\ndef writer(i):\n    print(i, \"writes\")\n    register.write(i, i)\n    print(i, \"wrote\")\n\nregister.init()\nfor i in { 1 .. NREADERS }:\n    spawn reader(i)\nfor i in { 1 .. NWRITERS }:\n    spawn writer(-i)\n</code></pre> Figure 29.2 (code/abdtest.hny):  Behavioral test for atomic read/write registers and the output for the case that `NREADERS` = `NWRITERS` = 1  <p>It is instructive to look at the test program and its output in Figure 29.2. This is for the case when there is only a single reader thread (identified as \"1\") and a single writer thread (identified as \"\\(-1\\)\"), but already there are many cases to consider. Each thread prints information just before and just after doing their single operation. The output shows all possible interleavings in the form of a DFA. Note that if the read operation starts after the write operation has completed, then the read operaion must return the new value. However, if the two operations interleave in some way, then the read operation can return either the old or the new value.</p> <p>Unfortunately, a server is a single point of failure: if it fails, all its clients suffer. We would therefore like to find a solution that can survive the crash of a server. While we could use Chain Replication to replicate the register, in this chapter we will use a solution that does not assume that crashes can be accurately detected.</p> <p>We will again replicate the register object: maintain multiple copies, but we will not use the replicated state machine approach. One could, for example, imagine that clients write to all copies and read from any single one. While this solves the single-point-of-failure problem, we lose all the nice properties above. For one, it is not guaranteed that all servers receive and process all write operations in the same order.</p> <p>We present a protocol preserving these properties that is based on the work by Hagit Attiya, Amotz Bar-Noy, and Danny Dolev. In order to tolerate <code>F</code> failures, it uses <code>N</code> = 2<code>F</code> + 1 servers. In other words, the register survives as long as a strict majority of its copies survive. All write operation will be ordered by a unique logical timestamp (see also Chapter 13). Each server maintains not only the value of the object, but also the timestamp of its corresponding write operation.</p> <p>Each read and write operation consists of two phases. In a phase, a client broadcasts a request to all servers and waits for responses from a majority (<code>N</code> -- <code>F</code> or equivalently <code>F</code> + 1 servers). Note that because we are assuming that no more than <code>F</code> servers can fail, doing so is safe, in that a client cannot indefinitely block as long as that assumption holds.</p> <p>In the first phase, a client asks each server for its current timestamp and value. After receiving <code>N</code> -- <code>F</code> responses, the client determines the response with the highest timestamp. In case of a write operation, the client then computes a new unique timestamp that is strictly higher than the highest it has seen. To make this work, timestamps are actually lexicographically ordered tuples consisting of an integer and the unique identifier of the client that writes the value. So, if \\((t, c)\\) is the highest timestamp observed by client \\(c'\\), and \\(c'\\) needs to create a new timestamp, it can select \\((t + 1, c')\\). After all \\((t + 1, c') &gt; (t, u)\\) and no other client will create the same timestamp.</p> <p>Suppose client \\(c'\\) is trying to write a value v. In phase 2, client \\(c'\\) broadcasts a request containing timestamp \\((t+1, c')\\) and v. Each server that receives the request compares \\((t+1, c')\\) against its current timestamp. If \\((t+1, c')\\) is larger than its current timestamp, it adopts the new timestamp and its corresponding value v. In either case, the server responds to the client. Upon \\(c'\\) receiving a response from <code>N</code> -- <code>F</code> servers, the write operation completes. In case of a read operation, client \\(c'\\) simply writes back the highest timestamp it saw in the first phase along with its corresponding value.</p> abd.hny<pre><code>import bag\n\nconst F = 1\nconst N = (2 * F) + 1\n\nnetwork = bag.empty()\n\ndef send(m): atomically network = bag.add(network, m)\n\ndef server():\n    var t, v, received = (0, None), None, {}\n    while True:\n        atomically when exists m in { m for m in keys network - received\n                            where m.type in {\"read\", \"write\"} }:\n            received |= { m }\n            if (m.type == \"write\") and (m.value[0] &gt; t):\n                t, v = m.value\n            send({ .type: .response, .dst: m.src, .value: (t, v) })\n\ndef init():\n    for i in { 1 .. N }: spawn eternal server()\n\ndef receive(uid, phase) returns quorums:\n    let msgs = { m:c for m:c in network\n                where (m.type == .response) and (m.dst == (uid, phase)) }:\n        quorums = bag.combinations(msgs, N - F)\n\ndef read(uid) returns contents:\n    send({ .type: \"read\", .src: (uid, 1) })\n    atomically when exists msgs in receive(uid, 1):\n        let (t, v) = max(m.value for m in keys msgs):\n            send({ .type: \"write\", .src: (uid, 2), .value: (t, v) })\n            contents = v\n    atomically when exists msgs in receive(uid, 2):\n        pass\n\ndef write(uid, v):\n    send({ .type: \"read\", .src: (uid, 1) })\n    atomically when exists msgs in receive(uid, 1):\n        let (t, _) = max(m.value for m in keys msgs)\n        let nt = (t[0] + 1, uid):\n            send({ .type: \"write\", .src: (uid, 2), .value: (nt, v) })\n    atomically when exists msgs in receive(uid, 2):\n        pass\n</code></pre> Figure 29.3 (code/abd.hny):  An implementation of a replicated atomic read/write register  <p>Figure 29.3 contains the code for a server, as well as the code for read and write operations. For efficiency of model checking, the servers are anonymous---otherwise we would have to consider every permutation of states of those servers. Because the servers are anonymous, they may end up sending the same exact message, but clients are waiting for a particular number of messages. Because of this, we will model the network as a bag of messages.</p> <p>A server initializes its timestamp t to \\((0, \\mathtt{None})\\) and its value to <code>None</code>. Each server also keeps track of all the requests its already received so it doesn't handle the same request twice. The rest of the code is fairly straightforward.</p> <p>Read and write operations are both invoked with a unique identifier uid. Both start by broadcasting a .<code>read</code> request to all servers and then waiting for a response from <code>N</code> -- <code>F</code> servers. The <code>receive</code>() function uses the <code>bag</code>.combinations method to find all combinations of subsets of responses of size <code>N</code> -- <code>F</code>. The second phase of each operation is similar.</p> <p>Figure 29.2 can be used to test this protocol, although you will notice that the model checker cannot deal with cases involving more than three client threads. Three is just enough to check the third property listed above (using one writer and two readers). Doing so illustrates the importance of the second phase of the <code>read</code> operation. You can comment out Lines\u00a034, 36, and\u00a037 in Figure 29.3 and to elide the second phase and see what goes wrong.</p> <p>One may wonder how failures can occur in this model. They are not explicitly modeled, but Harmony tries every possible execution. This includes executions in which the clients terminate before <code>F</code> of the servers start executing. To the clients, this is indistinguishable from executions in which those servers have failed.</p>"},{"location":"textbook/abp/","title":"Alternating Bit Protocol","text":"<p>A distributed system is a concurrent system in which a collection of threads communicate by message passing, much the same as in the actor model. The most important difference between distributed and concurrent systems is that the former takes failures into account, including failures of threads and failures of shared memory. In this chapter, we will consider two actors, Alice and Bob. Alice wants to send a sequence of application messages to Bob, but the underlying network may lose messages. The network does not re-order messages: when sending messages \\(m_1\\) and \\(m_2\\) in that order, then if both messages are received, \\(m_1\\) is received before \\(m_2\\). Also, the network does not create messages out of nothing: if message m is received, then message m was sent.</p> <p>It is useful to create an abstract network that reliably sends messages between threads, much like the FIFO queue in the <code>synch</code> module. For this, we need a network protocol that Alice and Bob can run. In particular, it has to be the case that if Alice sends application messages \\(m_1, ..., m_n\\) in that order, then if Bob receives an application message m, then \\(m = m_i\\) for some i and, unless \\(m\\) is the very first message, Bob will already have received application messages \\(m_1, ..., m_{i-1}\\) (safety). Also, if the network is fair and Alice sends application message m, then eventually Bob should deliver m (liveness).</p> abp.hny<pre><code>sequential s_chan, r_chan\n\ns_chan = r_chan = ()\ns_seq = r_seq = 0\n\ndef net_send(pchan, msg, reliable):\n    !pchan = msg if (reliable or choose({ False, True })) else ()\n\ndef net_recv(pchan) returns msg:\n    msg = !pchan\n\ndef app_send(payload):\n    s_seq = 1 - s_seq\n    let m = { .seq: s_seq, .payload: payload }:\n        var blocked = True\n        while blocked:\n            net_send(?s_chan, m, False)\n            let response = net_recv(?r_chan):\n                blocked = (response == ()) or (response.ack != s_seq)\n\ndef app_recv(reliable) returns payload:\n    r_seq = 1 - r_seq\n    var blocked = True\n    while blocked:\n        let m = net_recv(?s_chan):\n            if m != ():\n                net_send(?r_chan, { .ack: m.seq }, reliable)\n                if m.seq == r_seq:\n                    payload = m.payload\n                    blocked = False\n</code></pre> Figure 24.1 (code/abp.hny):  Alternating Bit Protocol  <p>The Alternating Bit Protocol is suitable for our purposes. We assume that there are two unreliable network channels: one from Alice to Bob and one from Bob to Alice. Alice and Bob each maintain a zero-initialized sequence number, s_seq and r_seq resp. Alice sends a network message to Bob containing an application message as payload and Alice's sequence number as header. When Bob receives such a network message, Bob returns an acknowledgment to Alice, which is a network message containing the same sequence number as in the message that Bob received.</p> <p>In the protocol, Alice keeps sending the same network message until she receives an acknowledgment with the same sequence number. This is called retransmission. When she receives the desired sequence number, Alice increments her sequence number. She is now ready to send the next message she wants to send to Bob. Bob, on the other hand, waits until he receives a message matching Bob's sequence number. If so, Bob delivers the payload in the message and increments his sequence number. Because of the network properties, a one-bit sequence number suffices.</p> <p>We can model each channel as a variable that either contains a network message or nothing (we use () in the model). Let s_chan be the channel from Alice to Bob and r_chan the channel from Bob to Alice. <code>net_send</code>(pchan, m, reliable) models sending a message m to !pchan, where pchan is either ?s_chan or ?r_chan. The method places either m (to model a successful send) or () (to model loss) in !pchan. The use of the reliable flag will be explained later. <code>net_recv</code>(pchan) models checking !pchan for the next message.</p> abptest.hny<pre><code>import abp\n\nconst NMSGS = 5\n\ndef sender():\n    for i in {1..NMSGS}:\n        abp.app_send(i)\n\ndef receiver():\n    for i in {1..NMSGS}:\n        let payload = abp.app_recv(i == NMSGS):\n            assert payload == i\n\nspawn sender()\nspawn receiver()\n</code></pre> Figure 24.2 (code/abptest.hny):  Test code for alternating bit protocol  <p>Method <code>app_send</code>(m) retransmits m until an acknowledgment is received. Method <code>app_recv</code>(reliable) returns the next successfully received message. Figure 24.2 shows how the methods may be used to send and receive a stream of <code>NMSGS</code> messages reliably. It has to be bounded, because model checking requires a finite model.</p> <p>Only the last invocation of <code>app_recv</code>(reliable) is invoked with reliable = <code>True</code>. It causes the last acknowledgment to be sent reliably. It allows the receiver (Bob) to stop, as well as the sender (Alice) once the last acknowledgment has been received. Without something like this, either the sender may be left hanging waiting for the last acknowledgment, or the receiver waiting for the last message.</p>"},{"location":"textbook/abp/#exercises","title":"Exercises","text":"<p>24.1 Chapter 20 explored the client/server model. It is popular in distributed systems as well. Develop a protocol for a single client and server using the same network model as for the ABP protocol. Hint: the response to a request can contain the same sequence number as the request.</p> <p>24.2 Generalize the solution in the previous exercise to multiple clients. Each client is uniquely identified. You may either use separate channel pairs for each client, or solve the problem using a single pair of channels.</p>"},{"location":"textbook/acknowledgments/","title":"Acknowledgments","text":"<p>I received considerable help and inspiration from various people while writing this book.</p> <p>First and foremost I would like to thank my student Haobin Ni with whom I've had numerous discussions about the initial design of Harmony. Haobin even contributed some code to the Harmony compiler. Many thanks are also due to William Ma who refactored the Harmony code to make it easier to maintain. He also wrote the first version of the behavior automaton generator and created the first graphs using the graphviz tool. I have had lots of discussions with him about a wide range of improvements to the Harmony language, many of which came to fruition. I also want to thank Ariel Kellison with whom I discussed approaches to formally specify the Harmony virtual machine in TLA+.</p> <p>Kevin Sun and Anthony Yang built a beautiful VSCode extension for Harmony called HarmonyLang and proceeded to build an animator for Harmony executions and two cloud-based Harmony offerings, which you can learn about at http://harmony.cs.cornell.edu. They also developed much of that web site and made valuable suggestions for improvements to the Harmony language.  Later they were joined by Shi Chong Zhao and Robin Li, who also made significant contributions.  Kevin and Anthony continue to make great contributions to the Harmony distribution.</p> <p>Most of what I know about concurrent programming I learned from my colleague Fred Schneider. He suggested I write this book after demonstrating Harmony to him. Being a foremost security expert, he also assisted significantly with the chapter on the Needham-Schroeder protocol.</p> <p>Leslie Lamport introduced me to using model checking to test properties of a concurrent system. My experimentation with using TLC on Peterson's Algorithm became an aha moment for me. I have learned so much from his papers.</p> <p>I first demonstrated Harmony to the students in my CS6480 class on systems and formal verification and received valuable feedback from them.</p> <p>The following people contributed by making comments on or finding bugs in early drafts of the book: Alex Chang, Anneke van Renesse, Brendon Nguyen, Harshul Sahni, Hartek Sabharwal, Heather Zheng, Jack Rehmann, Jacob Brugh, Liam Arzola, Lorenzo Alvisi, Maria Martucci, Nalu Concepcion, Phillip O'Reggio, Saleh Hassen, Sunwook Kim, Terryn Jung, Trishita Tiwari, Xiangyu Zhang, Yidan Wang, Zhuoyu Xu, and Zoltan Csaki.</p> <p>Finally, I would like to thank my family who had to suffer as I obsessed over writing the code and the book, at home, during the turbulent months of May and June 2020.</p>"},{"location":"textbook/acknowledgments/#bibliography","title":"Bibliography","text":"<p>Agha, Gul. 1986. Actors: A Model of Concurrent Computation in Distributed Systems (Doctoral Dissertation). Cambridge, MA, USA: MIT Press.</p> <p>Andrews, Tony, Shaz Qadeer, Sriram K. Rajamani, Jakob Rehof, and Yichen Xie. 2004. \u201cZing: A Model Checker for Concurrent Software.\u201d In International Conference on Computer Aided Verification (CAV).</p> <p>Attiya, Hagit, Amotz Bar-Noy, and Danny Dolev. 1995. \u201cSharing Memory Robustly in Message-Passing Systems.\u201d J. ACM 42 (1): 124\u201342. https://doi.org/10.1145/200836.200869.</p> <p>B\u00e9l\u00e1dy, L\u00e1szl\u00f3 A., R. A. Nelson, and G. S. Shedler. 1969. \u201cAn Anomaly in Space-Time Characteristics of Certain Programs Running in a Paging Machine.\u201d Communications of the ACM 12 (6): 349\u201353.</p> <p>Ben-Or, Michael. 1983. \u201cAnother Advantage of Free Choice (Extended Abstract): Completely Asynchronous Agreement Protocols.\u201d In Proceedings of the 2nd Annual ACM Symposium on Principles of Distributed Computing, 27\u201330. PODC\u201983. New York, NY, USA: ACM. https://doi.org/10.1145/800221.806707.</p> <p>Birrell, Andrew D. 1989. \u201cAn Introduction to Programming with Threads.\u201d SRC report 35. Palo Alto, CA, USA: Digital Systems Research Center.</p> <p>Brinch Hansen, Per. 1973. Operating System Principles. USA: Prentice-Hall, Inc.</p> <p>Chang, Ernest, and Rosemary Roberts. 1979. \u201cAn Improved Algorithm for Decentralized Extrema-Finding in Circular Configurations of Processes.\u201d Commun. ACM 22 (5): 281\u201383. https://doi.org/10.1145/359104.359108.</p> <p>Clarke, Edmund M., E. Allen Emerson, and A. Prasad Sistla. 1986. \u201cAutomatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications.\u201d ACM Trans. Program. Lang. Syst. 8 (2): 244\u201363. https://doi.org/10.1145/5397.5399.</p> <p>Coffman, Edward G., Melanie Elphick, and Arie Shoshani. 1971. \u201cSystem Deadlocks.\u201d ACM Comput. Surv. 3 (2): 67\u201378. https://doi.org/10.1145/356586.356588.</p> <p>Corbat\u00f3, Fernando J. 1969. \u201cA Paging Experiment with the Multics System.\u201d In In Honor of Philip m. Morse, 217\u201328.</p> <p>Cordeiro, Lucas, Pascal Kesseli, Daniel Kroening, Peter Schrammel, and Marek Trtik. 2018. \u201cJBMC: A Bounded Model Checking Tool for Verifying Java Bytecode.\u201d In Computer Aided Verification (CAV), 10981:183\u201390. LNCS. Springer.</p> <p>Courtois, Pierre-Jacques, Frans Heymans, and David L. Parnas. 1971. \u201cConcurrent Control with \u2018Readers\u2019 and \u2018Writers\u2019.\u201d Commun. ACM 14 (10): 667\u201368. https://doi.org/10.1145/362759.362813.</p> <p>Diffie, Whitfield., and Martin E. Hellman. 1976. \u201cNew Directions in Cryptography.\u201d IEEE Transactions on Information Theory 22 (6): 644\u201354. https://doi.org/10.1109/TIT.1976.1055638.</p> <p>Dijkstra, Edsger W. approx. 1964. \u201cEWD-108: Een Algorithme Ter Voorkoming van de Dodelijke Omarming.\u201d http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD108.PDF.</p> <p>\u2014\u2014\u2014. approx. 1962. \u201cEWD-35: Over de Sequentialiteit van Procesbeschrijvingen.\u201d http://www.cs.utexas.edu/users/EWD/ewd00xx/EWD35.PDF.</p> <p>\u2014\u2014\u2014. 1965. \u201cEWD-123: Cooperating Sequential Processes.\u201d</p> <p>\u2014\u2014\u2014. 1972. \u201cEWD-329 Information Streams Sharing a Finite Buffer.\u201d http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD329.PDF.</p> <p>\u2014\u2014\u2014. 1979. \u201cEWD-703: A Tutorial on the Split Binary Semaphore.\u201d http://www.cs.utexas.edu/users/EWD/ewd07xx/EWD703.PDF.</p> <p>Downey, Allen B. 2009. The Little Book of Semaphores. Green Tea Press. http://greenteapress.com/semaphores/LittleBookOfSemaphores.pdf.</p> <p>Gray, Jim N. 1978. \u201cNotes on Data Base Operating Systems.\u201d In Operating Systems: An Advanced Course, edited by R. Bayer, R. M. Graham, and G. Seegm\u00fcller, 393\u2013481. Berlin, Heidelberg: Springer Berlin Heidelberg. https://doi.org/10.1007/3-540-08755-9_9.</p> <p>Havelund, Klaus, and Thomas Pressburger. 2000. \u201cModel Checking Java Programs Using Java PathFinder.\u201d International Journal on Software Tools for Technology Transfer 2: 366\u201381.</p> <p>Havender, James W. 1968. \u201cAvoiding Deadlock in Multitasking Systems.\u201d IBM Syst. J. 7 (2): 74\u201384. https://doi.org/10.1147/sj.72.0074.</p> <p>Herlihy, Maurice P., and Jeannette M. Wing. 1987. \u201cAxioms for Concurrent Objects.\u201d In Proceedings of the 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, 13\u201326. POPL \u201987. New York, NY, USA: Association for Computing Machinery. https://doi.org/10.1145/41625.41627.</p> <p>\u2014\u2014\u2014. 1990. \u201cLinearizability: A Correctness Condition for Concurrent Objects.\u201d ACM Trans. Program. Lang. Syst. 12 (3): 463\u201392. https://doi.org/10.1145/78969.78972.</p> <p>Hewitt, Carl, Peter Bishop, and Richard Steiger. 1973. \u201cA Universal Modular ACTOR Formalism for Artificial Intelligence.\u201d In Proceedings of the 3rd International Joint Conference on Artificial Intelligence, 235\u201345. IJCAI\u201973. San Francisco, CA, USA: Morgan Kaufmann Publishers Inc.</p> <p>Hoare, C. A. R. 1973. \u201cTowards a Theory of Parallel Programming.\u201d In Operating Systems Techniques, edited by C. A. R. Hoare and R. H. Perrott. New York, NY: Academic Press.</p> <p>\u2014\u2014\u2014. 1974. \u201cMonitors: An Operating System Structuring Concept.\u201d Commun. ACM 17 (10): 549\u201357. https://doi.org/10.1145/355620.361161.</p> <p>Holzmann, Gerard. 2011. The SPIN Model Checker: Primer and Reference Manual. 1st ed. Addison-Wesley Professional.</p> <p>Kripke, Saul A. 1963. \u201cSemantical Considerations on Modal Logic.\u201d Acta Philosophica Fennica 16: 83\u201394.</p> <p>Lamport, Leslie. 1978. \u201cTime, Clocks, and the Ordering of Events in a Distributed System.\u201d Comm. Of the ACM 21 (7): 558\u201365.</p> <p>\u2014\u2014\u2014. 1998. \u201cThe Part-Time Parliament.\u201d Tocs 16 (2): 133\u201369.</p> <p>\u2014\u2014\u2014. 2002. Specifying Systems: The TLA+ Language and Tools for Hardware and Software Engineers. USA: Addison-Wesley Longman Publishing Co., Inc.</p> <p>\u2014\u2014\u2014. 2009. \u201cThe PlusCal Algorithm Language.\u201d In Theoretical Aspects of Computing - ICTAC 2009, edited by Martin Leucker and Carroll Morgan, 36\u201360. Berlin, Heidelberg: Springer Berlin Heidelberg.</p> <p>Lampson, Butler W., and David D. Redell. 1980. \u201cExperience with Processes and Monitors in Mesa.\u201d Commun. ACM 23 (2): 105\u201317. https://doi.org/10.1145/358818.358824.</p> <p>Lipton, Richard J. 1975. \u201cReduction: A Method of Proving Properties of Parallel Programs.\u201d Commun. ACM 18 (12): 717\u201321. https://doi.org/10.1145/361227.361234.</p> <p>Liu, Yanhong A., and Scott D. Stoller. 2020. \u201cAssurance of Distributed Algorithms and Systems: Runtime Checking of Safety and Liveness.\u201d In Proceedings of the 20th International Conference on Runtime Verification (RV 2020). https://doi.org/10.1007/978-3-030-60508-7_3.</p> <p>Liu, Yanhong A., Scott D. Stoller, and Bo Lin. 2017. \u201cFrom Clarity to Efficiency for Distributed Algorithms.\u201d ACM Trans. Program. Lang. Syst. 39 (3). https://doi.org/10.1145/2994595.</p> <p>Lowe, Gavin. 1995. \u201cAn Attack on the Needham-Schroeder Public-Key Authentication Protocol.\u201d Inf. Process. Lett. 56 (3): 131\u201333. https://doi.org/10.1016/0020-0190(95)00144-2.</p> <p>\u2014\u2014\u2014. 1996. \u201cBreaking and Fixing the Needham-Schroeder Public-Key Protocol Using FDR.\u201d In Tools and Algorithms for the Construction and Analysis of Systems, edited by Tiziana Margaria and Bernhard Steffen, 147\u201366. Berlin, Heidelberg: Springer Berlin Heidelberg.</p> <p>Michael, Ellis, Doug Woos, Thomas Anderson, Michael D. Ernst, and Zachary Tatlock. 2019. \u201cTeaching Rigorous Distributed Systems with Efficient Model Checking.\u201d In Proceedings of the Fourteenth EuroSys Conference 2019. EuroSys \u201919. New York, NY, USA: Association for Computing Machinery. https://doi.org/10.1145/3302424.3303947.</p> <p>Michael, Maged M., and Michael L. Scott. 1996. \u201cSimple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms.\u201d In Proceedings of the 15th Annual ACM Symposium on Principles of Distributed Computing (PODC).</p> <p>\u2014\u2014\u2014. 1998. \u201cNon-Blocking Algorithms and Preemption-Safe Locking on Multiprogrammed Shared Memory Multiprocessors.\u201d Journal of Parallel and Distributed Computing 51 (1): 1\u201326.</p> <p>Needham, Roger M., and Michael D. Schroeder. 1978. \u201cUsing Encryption for Authentication in Large Networks of Computers.\u201d Commun. ACM 21 (12): 993\u201399. https://doi.org/10.1145/359657.359659.</p> <p>Owicki, Susan S. 1975. \u201cAxiomatic Proof Techniques for Parallel Programs.\u201d PhD thesis.</p> <p>Peterson, Gary L. 1981. \u201cMyths about the Mutual Exclusion Problem.\u201d Information Processing Letters 12 (3): 115\u201316. https://doi.org/https://doi.org/10.1016/0020-0190(81)90106-X.</p> <p>Renesse, Robbert van, and Fred B. Schneider. 2004. \u201cChain Replication for Supporting High Throughput and Availability.\u201d In 6th Symposium on Operating System Design and Implementation (OSDI 2004), San Francisco, California, USA, December 6-8, 2004, edited by Eric A. Brewer and Peter Chen, 91\u2013104. USENIX Association. http://www.usenix.org/events/osdi04/tech/renesse.html.</p> <p>Schlichting, Richard D., and Fred B. Schneider. 1983. \u201cFail-Stop Processors: An Approach to Designing Fault-Tolerant Computing Systems.\u201d Tocs 1 (3): 222\u201338. https://doi.org/10.1145/357369.357371.</p> <p>Schneider, Fred B. 1990. \u201cImplementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial.\u201d Compsurv 22 (4): 299\u2013319.</p> <p>\u2014\u2014\u2014. 1997. On Concurrent Programming. Berlin, Heidelberg: Springer-Verlag.</p> <p>Valmari, Antti. 1991. \u201cStubborn Sets for Reduced State Space Generation.\u201d In Proceedings of the 10th International Conference on Applications and Theory of Petri Nets: Advances in Petri Nets 1990, 491\u2013515. Berlin, Heidelberg: Springer-Verlag.</p>"},{"location":"textbook/actions/","title":"Working with Actions","text":"<p>So far we have mostly modeled concurrent activities using threads. Another way of modeling is by enumerating all the possible state transitions from any given state. For example, this is how things are commonly specified in TLA+. As in TLA+, we call such state transitions  actions. In this chapter we will revisit modeling chain replication, but this time using actions.</p> chainaction.hny<pre><code>const NREPLICAS = 3     # number of replicas\nconst NOPS = 2          # number of operations (or clients)\n\nnetwork = {}            # the network is a set of messages\n\ndef send(self, dst, msg):           # send msg to replica dst\n    atomically network |= { (dst, (self, msg)) }\n\ndef broadcast(self, msg):           # broadcast msg to all\n    atomically for dst in {1..NREPLICAS}:\n        network |= { (dst, (self, msg)) }\n\ndef receive(self) returns msgs:     # return messages for me\n    msgs = { payload for (dst, payload) in network where (dst == self) }\n\ndef crash(self):                    # server 'self' is crashing\n    broadcast(self, \"crash\")        # notify all other replicas\n    stop()\n\ndef is_prefix(hist1, hist2) returns result: # hist1 is a strict prefix of hist2\n    result = (len(hist1) &lt; len(hist2)) and\n                all(hist1[i] == hist2[i] for i in {0..len(hist1)-1})\n\ndef replica(self, immortal):        # replica 'self'\n    if not immortal:        # if not immortal, crash sometime\n        trap crash(self)\n\n    var received  = {}              # messages received\n    var requests  = {}              # client requests received\n    var config    = {1..NREPLICAS}  # servers in chain configuration\n    var hist      = []              # history of client requests\n    var delivered = 0               # number requests delivered\n\n    while True:\n        atomically when exists (src, payload) in receive(self) - received:\n            received |= { (src, payload ) }     # don't handle twice\n            if src == \"client\":                 # received a client request\n                requests |= { payload }\n            elif payload == \"crash\":            # a server crashed\n                config -= { src }               # remove from configuration\n            elif (self != min(config)) and is_prefix(hist, payload):\n                hist = payload    # received better hist from predecessor\n\n            if self == min(config):     # I'm the head\n                for update in requests where update not in hist:\n                    hist += [update,]\n            if self == max(config):     # I'm the tail, deliver updates\n                while delivered &lt; len(hist):\n                    print(self, hist[delivered])\n                    delivered += 1\n            else:                  # Not tail: send hist to successor\n                let successor = min(i for i in config where i &gt; self):\n                    send(self, successor, hist)\n\ndef client(self):\n    print(self)\n    broadcast(\"client\", self)\n\nlet immortal = choose {1..NREPLICAS}:\n    for i in {1..NREPLICAS}:\n        spawn eternal replica(i, i == immortal)\nfor i in {1..NOPS}:\n    spawn client(i)\n</code></pre> Figure 28.1 (code/chainaction.hny):  Chain Replication specification using actions <p>Figure 28.1 contains the new specification.  The state of the replicas and the clients are stored in the variables <code>replicas</code> and <code>clients</code> respectively. Each type of action is captured using a lambda and a method. The method updates the state, while the lambda enumerates the possible actions of this type.</p> <p>For example, consider the crash action.  All replicas, except the replica that is immortal and the replicas that have already crashed, can crash.  There is a lambda <code>crash</code> that generates a set of all possible crashes.  Each element in the set is a closure consisting of a method call and an argument.  For example, <code>?do_crash(1)</code> is the action representing replica~1 failing.  If we look at the <code>do_crash(p)</code> method, all it does is set the <code>crashed</code> field of the replica. The specification does this for every type of action:</p> <ul> <li><code>sendOperation</code>: a client broadcasts an operation to all replicas.</li> <li><code>gotOperation</code>: the head replica adds the operation to its history.</li> <li><code>sendHist</code>: a replica sends its history to its successor.</li> <li><code>gotHist</code>: a replica accepts a history it has received.</li> <li><code>deliver</code>: the tail delivers (prints) an operation. </li> <li><code>crash</code>: a replica crashes.</li> <li><code>detect</code>: a replica detects the crash of a peer.</li> </ul> <p>The Harmony <code>action</code> module explores all possible behaviors of such a specification.  It has a single method <code>explore</code> that takes a set of lambdas, each of which returning a set of possible actions.</p> <p>So, which of the two types of specification do you prefer? One metric is readability, but that is subjective and depends on what you have experience with. Another object is the size of the state space, and in general control over the state space that is being explored. Threads have hidden state such as their stacks, program counters, and local variables, adding to the state space in sometimes unexpected ways.</p> <p>With an action-based specification all state is explicit, and all state changes are explicit.  This can be advantageous. On the other hand, the thread-based specification is easier to turn into an actual running implementation.</p>"},{"location":"textbook/actor/","title":"Actors and Message Passing","text":"<p>Some programming languages favor a different way of implementing synchronization using so-called actors. Actors are threads that have only private memory and communicate through message passing. See Figure 20.1 for an illustration. Given that there is no shared memory in the actor model (other than the message queues, which have built-in synchronization), there is no need for critical sections. Instead, some sequential thread owns a particular piece of data and other threads access it by sending request messages to the thread and optionally waiting for response messages. Each thread handles one message at a time, serializing all access to the data it owns. As message queues are FIFO (First-In-First-Out), starvation is prevented.</p> <p></p> Figure 20.1: Depiction of three actors. The producer does not receive messages.  <p>The actor synchronization model is popular in a variety of programming languages, including Erlang and Scala. Actor support is also available through popular libraries such as Akka, which is available for various programming languages. In Python, Java, and C/C++, actors can be easily emulated using threads and synchronized queues (aka blocking queues) for messaging. Each thread would have one such queue for receiving messages. Dequeuing from an empty synchronized queue blocks the thread until another thread enqueues a message on the queue.</p> <p>The <code>synch</code> library supports a synchronized message queue, similar to the <code>Queue</code> object in Python. Its interface is as follows:</p> <ul> <li> <p><code>Queue</code>() returns an empty queue;</p> </li> <li> <p><code>put</code>(q, item) adds item to the queue pointed to by q;</p> </li> <li> <p><code>get</code>(q) waits for and returns an item on the queue pointed to by     q.</p> </li> </ul> <p>For those familiar with counting semaphores: note that a <code>Queue</code> behaves much like a zero-initialized counting semaphore. <code>put</code> is much like <code>V</code>, except that it is accompanied by data. <code>get</code> is much like <code>P</code>, except that it also returns data. Thus, synchronized queues can be considered a generalization of counting semaphores.</p> counter.hny<pre><code>import synch\n\nconst NCLIENTS = 3\n\nserver_queue = synch.Queue()\n\ndef server():\n    var counter = 0\n    while True:\n        let q = synch.get(?server_queue):   # await request\n            synch.put(q, counter)           # send response\n            counter += 1\n\nspawn eternal server()\n\nsequential done\ndone = [False,] * NCLIENTS\n\ndef client(client_queue):\n    synch.put(?server_queue, client_queue)      # send request\n    let response = synch.get(client_queue):     # await response\n        done[response] = True\n    await all(done)\n\nalice_queue = synch.Queue()\nspawn client(?alice_queue)\nbob_queue = synch.Queue()\nspawn client(?bob_queue)\ncharlie_queue = synch.Queue()\nspawn client(?charlie_queue)\n</code></pre> Figure 20.2 (code/counter.hny):  An illustration of the actor approach  <p>Figure 20.2 illustrates the actor approach. There are three client threads that each want to be assigned a unique identifier from the set \\(\\{ 0, 1, 2 \\}\\). Normally one would use a shared 0-initialized counter and a lock. Each client would acquire the lock, get the value of the counter and increment it, and release the lock. Instead, in the actor approach the counter is managed by a separate server thread. The server never terminates, so it is spawned with the keyword eternal to suppress non-terminating state warnings. Each client sends a request to the server, consisting in this case of simply the queue to which the server must send the response. The server maintains a local, zero-initialized counter variable. Upon receiving a request, it returns a response with the value of the counter and increments the counter. No lock is required.</p> <p>This illustration is an example of the client/server model. Here a single actor implements some service, and clients send request messages and receive response messages. The model is particularly popular in distributed systems, where each actor runs on a separate machine and the queues are message channels. For example, the server can be a web server, and its clients are web browsers.</p>"},{"location":"textbook/actor/#exercises","title":"Exercises","text":"<p>20.1 Actors and message queues are good for building pipelines. Develop a pipeline that computes Mersenne primes (primes that are one less than a power of two). Write four actors:</p> <ol> <li> <p>an actor that generates a sequence of integers 1 through <code>N</code>;</p> </li> <li> <p>an actor that receives integers and forwards only those that are     prime;</p> </li> <li> <p>an actor that receives integers and forwards only those that are one     less than a power of two;</p> </li> <li> <p>an actor that receives integers but otherwise ignores them.</p> </li> </ol> <p>Configure two versions of the pipeline, one that first checks if a number is prime and then if it is one less than a power of two, the other in the opposite order. Which do you think is better?</p>"},{"location":"textbook/barrier/","title":"Barrier Synchronization","text":"<p>Barrier synchronization is a problem that comes up in high-performance parallel computing. The Harmony model checker uses it. A barrier is almost the opposite of a critical section: the intention is to get a group of threads to run some code at the same time, instead of having them execute it one at a time. More precisely, with barrier synchronization, the threads execute in rounds. Between each round, there is a so-called barrier where threads wait until all threads have completed the previous round and reached the barrier---before they start the next round. For example, in an iterative matrix algorithm, the matrix may be cut up into fragments. During a round, the threads run concurrently, one for each fragment. The next round is not allowed to start until all threads have completed processing their fragment.</p> <p>A barrier is used as follows:</p> <ul> <li> <p>b = <code>Barrier</code>(n): initialize a barrier b for a collection of     n threads;</p> </li> <li> <p><code>bwait</code>(?b): wait until all threads have reached the barrier</p> </li> </ul> barriertest.hny<pre><code>import barrier\n\nconst NTHREADS = 3\nconst NROUNDS = 4\n\nround = [0,] * NTHREADS\ninvariant (max(round) - min(round)) &lt;= 1\n\nbarr = barrier.Barrier(NTHREADS)\n\ndef thread(self):\n    for r in {0..NROUNDS-1}:\n        barrier.bwait(?barr)\n        round[self] += 1\n\nfor i in {0..NTHREADS-1}:\n    spawn thread(i)\n</code></pre> Figure 21.1 (code/barriertest.hny):  Test program for Figure 21.2  <p>Figure 21.1 is a test program for barriers. It uses an integer array round with one entry per thread. Each thread, in a loop, waits for all threads to get to the barrier before incrementing its round number. If the barrier works as advertised, two threads should never be more than one round apart.</p> <p>When implementing a barrier, a complication to worry about is that a barrier can be used over and over again. If this were not the case, then a solution based on a lock, a condition variable, and a counter initialized to the number of threads could be used. The threads would decrement the counter and wait on the condition variable until the counter reaches 0.</p> barrier.hny<pre><code>from synch import *\n\ndef Barrier(required) returns barrier:\n    barrier = {\n        .mutex: Lock(), .cond: Condition(),\n        .required: required, .left: required, .cycle: 0\n    }\n\ndef bwait(b):\n    acquire(?b-&gt;mutex)\n    b-&gt;left -= 1\n    if b-&gt;left == 0:\n        b-&gt;cycle = (b-&gt;cycle + 1) % 2\n        b-&gt;left = b-&gt;required\n        notifyAll(?b-&gt;cond)\n    else:\n        let cycle = b-&gt;cycle:\n            while b-&gt;cycle == cycle:\n                wait(?b-&gt;cond, ?b-&gt;mutex)\n    release(?b-&gt;mutex)\n</code></pre> Figure 21.2 (code/barrier.hny):  Barrier implementation  <p>Figure 21.2 shows how one might implement a reusable barrier. Besides a counter .left that counts how many threads still have to reach the barrier, it uses a counter .cycle that is incremented after each use of the barrier---to deal with the complication above. The last thread that reaches the barrier restores .left to the number of threads (.required) and increments the cycle counter. The other threads are waiting for the cycle counter to be incremented. The cycle counter is allowed to wrap around---in fact, a single bit suffices for the counter.</p> barriertest2.hny<pre><code>import barrier\n\nconst NTHREADS = 3\nconst NROUNDS = 4\n\nround = [0,] * NTHREADS\ninvariant (max(round) - min(round)) &lt;= 1\n\nphase = 0\nbarr = barrier.Barrier(NTHREADS)\n\ndef thread(self):\n    for r in {0..NROUNDS-1}:\n        if self == 0:                # coordinator prepares\n            phase += 1\n        barrier.bwait(?barr)         # enter parallel work\n        round[self] += 1\n        assert round[self] == phase\n        barrier.bwait(?barr)         # exit parallel work\n\nfor i in {0..NTHREADS-1}:\n    spawn thread(i)\n</code></pre> Figure 21.3 (code/barriertest2.hny):  Demonstrating the double-barrier pattern  <p>A common design pattern with barriers in parallel programs, demonstrated in Figure 21.3, is to use the barrier twice in each round. Before a round starts, one of the threads---let's call it the coordinator---sets up the work that needs to be done while the other threads wait. Then all threads do the work and go on until they reach a second barrier. The second barrier is used so the coordinator can wait for all threads to be done before setting up the work for the next round.</p>"},{"location":"textbook/barrier/#exercises","title":"Exercises","text":"<p>21.1 Implement barrier synchronization for <code>N</code> threads with just three binary semaphores. Busy waiting is not allowed. Can you implement barrier synchronization with two binary semaphores? (As always, the Little Book of Semaphores is a good resource for solving synchronization problems with semaphores. Look for the double turnstile solution.)</p> <p>21.2 Imagine a pool hall with <code>N</code> tables. A table is full from the time there are two players until both players have left. When someone arrives, they can join a table that is not full, preferably one that has a player ready to start playing. Implement a simulation of such a pool hall.</p>"},{"location":"textbook/bib-format/","title":"Bib format","text":"<p>bibliography: sample.bib nocite: \"@*\"</p>"},{"location":"textbook/cds/","title":"Concurrent Data Structures","text":"Sequential Concurrent queuespec.hny<pre><code>import list\n\ndef Queue() returns empty:\n    empty = []\n\ndef put(q, v):\n    !q = list.append(!q, v)\n\ndef get(q) returns next:\n    if !q == []:\n        next = None\n    else:\n        next = list.head(!q)\n        !q = list.tail(!q)\n</code></pre> queue.hny<pre><code>import list\n\ndef Queue() returns empty:\n    empty = []\n\ndef put(q, v):\n    atomically !q = list.append(!q, v)\n\ndef get(q) returns next:\n    atomically:\n        if !q == []:\n            next = None\n        else:\n            next = list.head(!q)\n            !q = list.tail(!q)\n</code></pre> Figure 11.1: A sequential and a concurrent specification of a queue queuedemo.hny<pre><code>import queue\n\ndef sender(q, v):\n    queue.put(q, v)\n\ndef receiver(q):\n    let v = queue.get(q):\n        assert v in { None, 1, 2 }\n\ndemoq = queue.Queue()\nspawn sender(?demoq, 1)\nspawn sender(?demoq, 2)\nspawn receiver(?demoq)\nspawn receiver(?demoq)\n</code></pre> Figure 11.2 (code/queuedemo.hny):  Using a concurrent queue  <p>The most common use for locks is in building concurrent data structures. By way of example, we will first demonstrate how to build a concurrent queue. The <code>queue</code> module can be used as follows:</p> <ul> <li> <p>x = <code>Queue</code>(): initialize a new queue x;</p> </li> <li> <p><code>put</code>(?x, v): add v to the tail of x;</p> </li> <li> <p>r = <code>get</code>(?x): returns r = <code>None</code> if x is empty or r = v     if v was at the head of x.</p> </li> </ul> <p>Figure 11.1(a) shows a sequential specification for such a queue in Harmony (exploiting some methods from the <code>list</code> module described in ). It is a credible queue implementation, but it cannot be used with threads concurrently accessing this queue. Figure 11.1(b) shows the corresponding concurrent specification.  It cannot be used as an implementation for a queue, as processors generally do not have atomic operations on lists, but it will work well as a specification. See Figure 11.2 for a simple demonstration program that uses a concurrent queue.</p> queueconc.hny<pre><code>from synch import Lock, acquire, release\nfrom alloc import malloc, free\n\ndef Queue() returns empty:\n    empty = { .head: None, .tail: None, .lock: Lock() }\n\ndef put(q, v):\n    let node = malloc({ .value: v, .next: None }):\n        acquire(?q-&gt;lock)\n        if q-&gt;tail == None:\n            q-&gt;tail = q-&gt;head = node\n        else:\n            q-&gt;tail-&gt;next = node\n            q-&gt;tail = node\n        release(?q-&gt;lock)\n\ndef get(q) returns next:\n    acquire(?q-&gt;lock)\n    let node = q-&gt;head:\n        if node == None:\n            next = None\n        else:\n            next = node-&gt;value\n            q-&gt;head = node-&gt;next\n            if q-&gt;head == None:\n                q-&gt;tail = None\n            free(node)\n    release(?q-&gt;lock)\n</code></pre> Figure 11.3 (code/queueconc.hny):  An implementation of a concurrent queue data structure  queueMS.hny<pre><code>from synch import Lock, acquire, release, atomic_load, atomic_store\nfrom alloc import malloc, free\n\ndef Queue() returns empty:\n    let dummy = malloc({ .value: (), .next: None }):\n        empty = { .head: dummy, .tail: dummy, .hdlock: Lock(), .tllock: Lock() }\n\ndef put(q, v):\n    let node = malloc({ .value: v, .next: None }):\n        acquire(?q-&gt;tllock)\n        atomic_store(?q-&gt;tail-&gt;next,  node)\n        q-&gt;tail = node\n        release(?q-&gt;tllock)\n\ndef get(q) returns next:\n    acquire(?q-&gt;hdlock)\n    let dummy = q-&gt;head\n    let node = atomic_load(?dummy-&gt;next):\n        if node == None:\n            next = None\n            release(?q-&gt;hdlock)\n        else:\n            next = node-&gt;value\n            q-&gt;head = node\n            release(?q-&gt;hdlock)\n            free(dummy)\n</code></pre> Figure 11.4 (code/queueMS.hny):  A queue with separate locks for enqueuing and dequeuing items  <p>We will first implement the queue as a linked list. The implementation in Figure 11.3 uses the <code>alloc</code> module for dynamic allocation of nodes in the list using <code>malloc</code>() and <code>free</code>(). <code>malloc</code>(v) returns a new memory location initialized to v, which should be released with <code>free</code>() when it is no longer in use. The queue maintains a <code>head</code> pointer to the first element in the list and a <code>tail</code> pointer to the last element in the list. The <code>head</code> pointer is <code>None</code> if and only if the queue is empty. (<code>None</code> is a special address value that is not the address of any memory location.)</p> <p><code>Queue</code>() returns the initial value for a queue object consisting of a <code>None</code> head and tail pointer and a lock. The <code>put</code>(q, v) and <code>get</code>(q) methods both take a pointer q to the queue object because both may modify the queue. Before they access the value of the head or tail of the queue they first obtain the lock. When they are done, they release the lock.</p> <p>An important thing to note in Figure 11.2 is Lines\u00a07 and\u00a08. It would be incorrect to replace these by: <pre><code>assert queue.get(q) in { None, 1, 2 }\n</code></pre> The reason is that <code>queue.get()</code> changes the state by acquiring a lock, but the expressions in assert statements (or invariant and finally statements) are not allowed to change the state.</p> <p>Figure 11.4 shows another concurrent queue implementation. It is well-known, but what is not often realized is that it requires sequentially consistent memory, which is not said explicitly in the paper. As a result, the algorithm must be coded very carefully to work correctly with modern programming languages and computer hardware. The implementation uses separate locks for the head and the tail, allowing a <code>put</code> and a <code>get</code> operation to proceed concurrently. To avoid contention between the head and the tail, the queue uses a dummy node at the head of the linked list. Except initially, the dummy node is the last node that was dequeued. Note that neither the <code>head</code> nor <code>tail</code> pointer are ever <code>None</code>. The problem is when the queue is empty and there are concurrent <code>get</code> and <code>put</code> operations. They obtain separate locks and then concurrently access the next field in the dummy node---a data race with undefined semantics in most environments. To get around this problem, the implementation in Figure 11.4 uses <code>atomic_load</code> and <code>atomic_store</code> from the <code>synch</code> module.</p>"},{"location":"textbook/cds/#exercises","title":"Exercises","text":"<p>11.1 Add a method <code>contains</code>(q, v) to Figure 11.1(b) that checks to see if v is in queue q.</p> <p>11.2 Add a method <code>length</code>(q) to Figure 11.3 that returns the length of the given queue. The complexity of the method should be \\(O(1)\\), which is to say that you should maintain the length of the queue as a field member and update it in <code>put</code> and <code>get</code>.</p> <p>11.3 Write a method <code>check</code>(q) that checks the integrity of the queue in Figure 11.3. In particular, it should check the following integrity properties:</p> <ul> <li> <p>If the list is empty, q-&gt;<code>tail</code> should be <code>None</code>.     Otherwise, the last element in the linked list starting from     q-&gt;<code>head</code> should equal q-&gt;<code>head</code>.     Moreover, q-&gt;<code>tail</code>-&gt;next should be     <code>None</code>;</p> </li> <li> <p>The length field that you added in Exercise 11.3 should equal the length of the     list.</p> </li> </ul> <p>11.4 Method <code>check</code>(q) should not obtain a lock; instead add the following line just before releasing the lock in <code>put</code> and <code>get</code>: <pre><code>assert check()\n</code></pre> \\(\\mathtt{remove}(q, v)\\) to Figure 11.3 that removes all occurrences of v, if any, from queue q.</p> <p>11.5 The test program in Figure 11.2 is not a thorough test program. Design and implement a test program for Figure 11.2. Make sure you test the test program by trying it out against some buggy queue implementations. (You will learn more about testing concurrent programs in Chapter 13.)</p>"},{"location":"textbook/chain/","title":"Chain Replication","text":"<p>As you have probably experienced, computers can crash. If you are running a web service, you may not be able to afford a long outage. If you are running software that flies a plane, then an outage for any length of time could lead to a disaster. To deal with service outages caused by computers crashing, you may want to replicate the service onto multiple computers. As long as one of the computers survives, the service remains available.</p> <p>Besides availability, it is usually important that the replicated service acts as if it were a single one. This requires that the replicas of the service coordinate their actions. The Replicated State Machine Approach is a general approach to do just this. First, you model your service as a deterministic state machine. The replicas each run a copy of the state machine, started in the same state. As long as the replicas handle the same inputs in the same order, determinism guarantees that they produce the same outputs in the same order.</p> rsm.hny<pre><code>const NREPLICAS = 3     # number of replicas\nconst NOPS = 2          # number of operations\n\nnetwork = []            # the network is a queue of messages\n\ndef crash():\n    stop()\n\ndef send(msg):\n    atomically network += [msg,]\n\ndef replica(self, immortal):\n    if not immortal:\n        trap crash()\n    var delivered = 0\n    while True:\n        atomically when len(network) &gt; delivered:\n            let msg = network[delivered]:\n                print(self, msg)\n                delivered += 1\n\ndef client(self):\n    print(self)\n    send(self)\n\nlet immortal = choose {1..NREPLICAS}:\n    for i in {1..NREPLICAS}:\n        spawn eternal replica(i, i == immortal)\nfor i in {1..NOPS}:\n    spawn client(i)\n</code></pre> Figure 27.1 (code/rsm.hny):  Replicated State Machine  <p></p> Figure 27.2: The DFA generated by Figure 27.1 when `NOPS=2` and `NREPLICAS=2` <p>Figure 27.1 presents a Harmony specification of state machine replication. We model the state machine as a history: a sequence of operations. In a replicated state machine, the abstract network maintains this history as an ordered queue of messages. <code>NOPS</code> clients each place an operation on the network. The replicas process messages from the ordered network.</p> <p>All but one of the replicas is allowed to crash. Crashes are modeled as interrupts, so we use Harmony's <code>trap</code> clause to schedule one.  When crashing, a replica simply stops. The model chooses one of the replicas that is not allowed to crash. Of course, a replica does not know whether it is immortal or not in practice---it should just assume that it is. The immortality of one of the replicas is only used for modeling the assumptions we make about the system.</p> <p>The behavior is captured as before.  Before an operation is added to the network, a client prints the operation (in this case, its own identifier). After a replica processes an operation, it prints a pair consisting of its own identifier and the operation. All replicas print the same operations in the same order until they crash. Figure 27.2 shows the allowed behaviors in case there are just two clients and two replicas.  Because one of the replicas is immortal and clients do not crash, at least one of the replicas will print both operations (liveness).  If both do, they do so in the same order (safety).</p> <p>But in reality the network is not an ordered queue and better modeled as a set of messages. The trick now is to ensure that all replicas handle the same requests in the same order and to do so in a way that continues to work even if some strict subset of replicas crash. Chain Replication is such a replication protocol. In Chain Replication, the replicas are organized in a linear chain which may change as replicas crash. Importantly, at any point in time there is only one head and one tail replica.</p> <p>Only the head is allowed to accept new operations from clients. When it does so, it adds the operation to the end of its history and sends the history to its successor on the chain. When the direct successor receives such a history, it makes sure that the history is an extension of its own and, if so, replaces its own history with the one received. It then sends the history on to its successor, if any.</p> <p>When an operation reaches the tail, the operation is what is known as stable --- it has been reliably ordered and persisted.</p> <p>So, when a replica fails, its successors should find out about it. In order for this to work, each replica needs to know who is its predecessor and who is its successor. So, when a replica fails,  its neighbors should find out about it. In practice, one server can detect the failure of another server by pinging it. If a server does not receive a response to its ping within some maximum amount of time, then the server considers its peer crashed. Note that this, in general, is not a safe thing to do---the network or the peer may be temporarily slow but the peer is not necessarily crashed when the timer expires.</p> <p>Nonetheless, we will assume here that failure detection does not make mistakes and that eventually every failure is detected. This is called the Fail-Stop failure model, which is distinct from the often more realistic Crash Failure model where processes can crash but accurate detection is not available. We will consider that more realistic failure model in the upcoming chapters.</p> chain.hny<pre><code>const NREPLICAS = 3     # number of replicas\nconst NOPS = 2          # number of operations (or clients)\n\nnetwork = {}            # the network is a set of messages\n\ndef send(self, dst, msg):           # send msg to replica dst\n    atomically network |= { (dst, (self, msg)) }\n\ndef broadcast(self, msg):           # broadcast msg to all\n    atomically for dst in {1..NREPLICAS}:\n        network |= { (dst, (self, msg)) }\n\ndef receive(self) returns msgs:     # return messages for me\n    msgs = { payload for (dst, payload) in network where (dst == self) }\n\ndef crash(self):                    # server 'self' is crashing\n    broadcast(self, \"crash\")        # notify all other replicas\n    stop()\n\ndef is_prefix(hist1, hist2) returns result: # hist1 is a strict prefix of hist2\n    result = (len(hist1) &lt; len(hist2)) and\n                all(hist1[i] == hist2[i] for i in {0..len(hist1)-1})\n\ndef replica(self, immortal):        # replica 'self'\n    if not immortal:        # if not immortal, crash sometime\n        trap crash(self)\n\n    var received  = {}              # messages received\n    var requests  = {}              # client requests received\n    var config    = {1..NREPLICAS}  # servers in chain configuration\n    var hist      = []              # history of client requests\n    var delivered = 0               # number requests delivered\n\n    while True:\n        atomically when exists (src, payload) in receive(self) - received:\n            received |= { (src, payload ) }     # don't handle twice\n            if src == \"client\":                 # received a client request\n                requests |= { payload }\n            elif payload == \"crash\":            # a server crashed\n                config -= { src }               # remove from configuration\n            elif (self != min(config)) and is_prefix(hist, payload):\n                hist = payload    # received better hist from predecessor\n\n            if self == min(config):     # I'm the head\n                for update in requests where update not in hist:\n                    hist += [update,]\n            if self == max(config):     # I'm the tail, deliver updates\n                while delivered &lt; len(hist):\n                    print(self, hist[delivered])\n                    delivered += 1\n            else:                  # Not tail: send hist to successor\n                let successor = min(i for i in config where i &gt; self):\n                    send(self, successor, hist)\n\ndef client(self):\n    print(self)\n    broadcast(\"client\", self)\n\nlet immortal = choose {1..NREPLICAS}:\n    for i in {1..NREPLICAS}:\n        spawn eternal replica(i, i == immortal)\nfor i in {1..NOPS}:\n    spawn client(i)\n</code></pre> Figure 27.3 (code/chain.hny):  Chain Replication  <p>Figure 27.3 show an implemenation of chain replication. The network is modeled as a append-only set of messages of the form <code>(destination, (source, payload))</code>.  When sending, a message is atomically added to this set. A client broadcasts its operation to all replicas.</p> <p>Each replica maintains its own history <code>hist</code> and a chain configuration <code>config</code>.  The replica executes a loop in which it receives and atomically handles messages until it crashes.  As before, one of the replicas cannot crash. Because replicas do not want to handle the same message twice, each replica maintains a set <code>received</code> of messages it has already handled.  Each replica then waits for a message on the network it has not already handled before.</p> <p>When a replica receives a client request, it adds the request to a set <code>requests</code> that it maintains.  A replica can only handle such a request if it is the head, but each replica can eventually become the head so it should carefully save all requests.  (In theory, it can remove them as soon as they are on its history.) When a replica receives a failure notification, it updates its configuration accordingly. When a non-head replica receives a history that extends its own history, then the replica adopts the received history.</p> <p>Next, if a replica is the head, it adds any requests it has received to its history unless they are already on there. If a replica is the tail, it \"delivers\" operations on its history (by printing the operation) that it has not already delivered. For this, it maintains a counter <code>delivered</code> that counts the number of delivered requests. Any replica that is not the tail sends its history to its successor in the chain.</p> <p>The question is whether chain replication has the same behavior as the replicated state machine specification of Figure 27.1. This can be checked using the following two Harmony commands:</p> <pre><code>$ harmony -o rsm.hfa code/rsm.hny\n$ harmony -B rsm.hfa code/chain.hny\n</code></pre> <p>The first command outputs the behavior DFA of <code>code/rsm.hny</code> in the file <code>rsm.hfa</code>. The second command checks that the behavior of <code>code/chain.hny</code> satisfies the DFA in <code>rsm.hfa</code>. Note that chain replication does not produce all the possible behaviors of a replicated state machine, but all its behaviors are valid.</p> <p>The model has each replica send its entire history each time it extends its history. This is fine for modeling, but in practice that would not scale. In practice, a predecessor would set up a TCP connection to its successor and only send updates to its history along the TCP connection. Because TCP connections guarantee FIFO order, this would be identical to the predecessor sending a series of histories, but much more efficient.</p>"},{"location":"textbook/commandline/","title":"Harmony Command Line","text":"<p><code>harmony [options] filename</code></p>"},{"location":"textbook/commandline/#description","title":"Description","text":"<p><code>harmony</code> is a compiler and model checker for the Harmony programming language. <code>harmony</code> compiles Harmony into bytecode and then model checks the bytecode. The result is analyzed for failing assertions and invariants, non-terminating conditions such as deadlock and infinite loops, race conditions, deviations from specifications, and busy waiting. There are three phases:</p> <ul> <li> <p>compile: parses Harmony source code and generates Harmony virtual     machine code;</p> </li> <li> <p>model check: generates a graph of all reachable states from the     Harmony virtual machine code while checking for safety violations;</p> </li> <li> <p>analysis: checks the graph for non-termination, race conditions,     and busy waiting.</p> </li> </ul> <p>The Harmony file name extensions are as follows:</p> <ul> <li> <p><code>.hny</code>: Harmony source code;</p> </li> <li> <p><code>.hvm</code>: Harmony virtual machine code (in JSON format);</p> </li> <li> <p><code>.hco</code>: Harmony output (in JSON format);</p> </li> <li> <p><code>.hvb</code>: Harmony verbose output (human readable);</p> </li> <li> <p><code>.hfa</code>: Harmony finite automaton, describing the possible \\&lt;print&gt;     outputs (in JSON format).</p> </li> </ul> <p>In addition, <code>harmony</code> can also generate <code>.tla</code> (TLA+), <code>.htm</code> (HTML), <code>.gv</code>: (Graphviz DOT version of <code>.hfa</code> output), <code>.png</code>: (PNG version of <code>.hfa</code> output), and <code>.tex</code>: (LaTeX formatted source code),</p> <p>By default, running \u201c<code>harmony x.hny</code>\u2019 will generate <code>x.hvm</code>, <code>x.hco</code>, <code>x.hvb</code>, and <code>x.hvm</code> files. Harmony will also, by default, automatically start a web browser to display the <code>x.hvm</code> file. Various options can be used to change the behavior.</p> <p>When importing a module using \\&lt;import x&gt;, <code>harmony</code> will try to find the corresponding <code>.hny</code> file in the following order:</p> <ol> <li> <p>check if the module file is specified with the <code>-m</code> or <code>\u2013module</code>     option;</p> </li> <li> <p>see if a file by the name \\&lt;x.hny&gt; is present in the same directory     as the source file;</p> </li> <li> <p>see if a file by the name \\&lt;x.hny&gt; is present in the installation\u2019s     <code>modules</code> directory.</p> </li> </ol>"},{"location":"textbook/commandline/#options","title":"Options","text":""},{"location":"textbook/commandline/#output-file-options","title":"Output file options:","text":"<ul> <li> <p><code>-o</code> filename.gv: specify the name of the file where the     <code>graphviz</code> (DOT) output should be stored;</p> </li> <li> <p><code>-o</code> filename.hco: specify the name of the file where model     checker output should be stored;</p> </li> <li> <p><code>-o</code> filename.hfa: specify the name of the file where the Harmony     finite automaton should be stored;</p> </li> <li> <p><code>-o</code> filename.htm: specify the name of the file where the HTML     output should be stored;</p> </li> <li> <p><code>-o</code> filename.hvb: specify the name of the file where the verbose     output should be stored;</p> </li> <li> <p><code>-o</code> filename.hvm: specify the name of the file where the Harmony     virtual machine code should be stored;</p> </li> <li> <p><code>-o</code> filename.png: specify the name of the file where the PNG     output should be stored;</p> </li> <li> <p><code>-o</code> filename.tla: generate a TLA+ file specifying the behaviors     of the Harmony virtual machine code;</p> </li> <li> <p><code>-o</code> filename.tex: generate a LaTeX+ file containing the      formatted source code.</p> </li> </ul>"},{"location":"textbook/commandline/#other-options","title":"Other options:","text":"<ul> <li> <p><code>-a</code>: compile only and list machine code (with labels);</p> </li> <li> <p><code>-A</code>: compile only and list machine code (without labels);</p> </li> <li> <p><code>-B</code> <code>filename.hfa</code>: check Harmony code against output behaviors     described in <code>filename.hfa</code> (result of another Harmony run);</p> </li> <li> <p><code>-c</code>, <code>\u2013const</code> \\&lt;constant=expression&gt;: set the value of the given     constant (which must be defined in the code) to the result of     evaluating the given expression;</p> </li> <li> <p><code>-m</code>, <code>\u2013module</code> \\&lt;module=filename.hny&gt;: load the given module     instead of looking in default locations;</p> </li> <li> <p><code>\u2013noweb</code>: do not start a web browser upon completion;</p> </li> <li> <p><code>-v</code>, <code>\u2013version</code>: print the <code>harmony</code> version number.</p> </li> <li> <p><code>-w</code> <code>#workers</code>: specify the number of concurrent threads the model checker uses.</p> </li> </ul>"},{"location":"textbook/concurrent/","title":"The Problem of Concurrent Programming","text":"Sequential Concurrent prog1.hny<pre><code>shared = True\n\ndef f(): assert shared\ndef g(): shared = False\n\nf()\ng()\n</code></pre> prog2.hny<pre><code>shared = True\n\ndef f(): assert shared\ndef g(): shared = False\n\nspawn f()\nspawn g()\n</code></pre> Figure 3.1: A sequential and a concurrent program <p>Concurrent programming, aka multithreaded programming, involves multiple threads running in parallel while sharing variables. Figure 3.1 shows two programs. Program (a) is sequential. It sets shared to <code>True</code>, asserts that shared = <code>True</code> and finally sets shared to <code>False</code>. If you run the program through Harmony, it will not find any problems because there is only one execution possible and 1) in that execution the assertion does not fail and 2) the execution terminates. Program (b) is concurrent---it executes methods <code>f</code>() and <code>g</code>() in parallel. If method <code>g</code>() runs and completes before <code>f</code>(), then the assertion in <code>f</code>() will fail when <code>f</code>() runs. This problem is an example of non-determinism: methods <code>f</code>() and <code>g</code>() can run in either order. In one order, the assertion fails, while in the other it does not. But since Harmony will find all possible executions, it will find the problematic one.</p> <p>Figure 3.2 presents a more subtle example that illustrates non-atomicity. The program initializes two shared variables: an integer count and an array done with two booleans. The program then spawns two threads. The first runs <code>incrementer</code>(0); the second runs <code>incrementer</code>(1).</p> <p>Method <code>incrementer</code> takes a parameter called self. It increments count and sets done[self] to <code>True</code>. It then waits until the other thread is done. (await c is shorthand for while not c: pass.) After that, method <code>incrementer</code> verifies that the value of count equals\u00a02.</p> <p>Note that although the threads are spawned one at a time, they will execute concurrently. It is, for example, quite possible that <code>incrementer(1)</code> finishes before <code>incrementer</code>(0) even gets going. And because Harmony tries every possible execution, it will consider that particular execution as well. What would the value of count be at the end of that execution?</p> Up.hny<pre><code>count = 0\ndone = [ False, False ]\n\ndef incrementer(self):\n    count = count + 1\n    done[self] = True\n    await done[1 - self]\n    assert count == 2\n\nspawn incrementer(0)\nspawn incrementer(1)\n</code></pre> Figure 3.2 (code/Up.hny):  Incrementing the same variable twice in parallel <ul> <li>Before you run the program, what do you think will happen? Is the program correct in that count will always end up being 2? (You may assume that <code>load</code> and <code>store</code> instructions of the underlying virtual machine architecture are atomic (indivisible)---in fact they are.)</li> </ul> Upr.hny<pre><code>count = 0\ndone = [ False, False ]\n\ndef incrementer(self):\n    var register = count    # load count\n    register += 1           # increment\n    count = register        # store count\n    done[self] = True\n    await done[1 - self]\n    assert count == 2\n\nspawn incrementer(0)\nspawn incrementer(1)\n</code></pre> Figure 3.3 (code/Upr.hny):  What actually happens in Figure 3.2 <p>What is going on is that the Harmony program is compiled to machine instructions, and it is the machine instructions that are executed by the underlying Harmony machine. The details of this appear in Chapter 4, but suffice it to say that the machine has instructions that load values from memory and store values into memory. Importantly, it does not have instructions to atomically increment or decrement values in shared memory locations. So, to increment a value in memory, the machine must do at least three machine instructions. Figure 3.3 illustrates this. (The <code>var</code> statement declares a new local variable <code>register</code>.) Conceptually, the machine</p> <ol> <li> <p>loads the value of <code>count</code> from its memory location into a register;</p> </li> <li> <p>adds 1 to the register;</p> </li> <li> <p>stores the new value into the memory location of <code>count</code>.</p> </li> </ol> <p>When running multiple threads, each essentially runs an instantiation of the machine, and they do so in parallel. As they execute, their machine instructions are interleaved in unspecified and often unpredictable ways. A program is correct if it works for any interleaving of threads. Harmony will try all possible interleavings of the threads executing machine instructions.</p> <p>If the threads run one at a time, then count will be incremented twice and ends up being 2. However, the following is also a possible interleaving of <code>incrementer</code>(0) and <code>incrementer(1)</code>:</p> <ol> <li> <p><code>incrementer</code>(0) loads the value of count, which is 0;</p> </li> <li> <p><code>incrementer(1)</code> loads the value of count, which is still 0;</p> </li> <li> <p><code>incrementer(1)</code> adds 1 to the value that it loaded (0), and stores     \\(1\\) into count;</p> </li> <li> <p><code>incrementer</code>(0) adds 1 to the value that it loaded (0), and stores     \\(1\\) into count;</p> </li> <li> <p><code>incrementer</code>(0) sets done[0] to <code>True</code>;</p> </li> <li> <p><code>incrementer(1)</code> sets done[1] to <code>True</code>.</p> </li> </ol> <p>The result in this particular interleaving is that count ends up being 1. This is known as a race condition. When running Harmony, it will report violations of assertions. It also provides an example of an interleaving, like the one above, in which an assertion fails.</p> <p>If one thinks of the assertion as providing the specification of the program, then clearly its implementation does not satisfy its specification. Either the specification or the implementation (or both) must have a bug. We could change the specification by changing the assertion as follows:</p> <pre><code>assert (*count* == 1) or (*count* == 2)\n</code></pre> <p>This would fix the issue, but more likely it is the program that must be fixed, not the specification.</p> Upf.hny<pre><code>count = 0\n\nfinally count == 2\n\ndef incrementer():\n    count = count + 1\n\nspawn incrementer()\nspawn incrementer()\n</code></pre> Figure 3.4 (code/Upf.hny):  Demonstrating the `finally` clause. <p>Figure 3.4 demonstrates another way of accomplishing the same using the Harmony <code>finally</code> clause.  The <code>finally</code> clause is like the <code>assert</code> clause, but the condition is only checked when all threads have finished.  This eliminates the need for a shared variable like <code>done</code>, simplifies the code, and makes the intention clearer.</p> <p>The exercises below have you try the same thing (having threads concurrently increment an integer variable) in Python. As you will see, the bug is not easily triggered when you run a Python version of the program. But in Harmony Murphy's Law applies: if something can go wrong, it will. Usually that is not a good thing, but in Harmony it is. It allows you to find bugs in your concurrent programs much more easily than with a conventional programming language.</p>"},{"location":"textbook/concurrent/#exercises","title":"Exercises","text":"<p>3.1 Harmony programs can usually be easily translated into Python by hand. For example, Figure 3.5 is a Python version of Figure 3.2.</p> <ol> <li> <p>Run Figure 3.5 using Python. Does the assertion fail?</p> </li> <li> <p>Using a script, run Figure 3.5 1000 times. For example, if you     are using the bash shell (in Linux or Mac OS X, say), you can do the     following:</p> <pre><code>for i in {1..1000}\ndo\n    python Up.py\ndone\n</code></pre> <p>If you're using Windows, the following batch script does the trick:</p> <pre><code>FOR /L %%i IN (1, 1, 1000) DO python Up.py\nPAUSE\n</code></pre> <p>How many times does the assertion fail (if any)?</p> </li> </ol> <p>3.2 Figure 3.6 is a version of Figure 3.5 that has each incrementer thread increment count <code>N</code> times. Run Figure 3.6 10 times (using Python). Report how many times the assertion fails and what the value of count was for each of the failed runs. Also experiment with lower values of <code>N</code>. How large does <code>N</code> need to be for assertions to fail? (Try powers of 10 for <code>N</code>.)</p> <p>3.3 Can you think of a fix to Figure 3.2? Try one or two different fixes and run them through Harmony. Do not worry about having to come up with a correct fix at this time---the important thing is to develop an understanding of concurrency. (Also, you do not get to use the atomically keyword or a lock, yet.)</p> Up.py<pre><code>import threading\n\ncount = 0\ndone = [ False, False ]\n\ndef incrementer(self):\n    global count\n    count = count + 1\n    done[self] = True\n    while not done[1 - self]:\n        pass\n    assert count == 2\n\nthreading.Thread(target=incrementer, args=(0,)).start()\nthreading.Thread(target=incrementer, args=(1,)).start()\n</code></pre> Figure 3.5 (python/Up.py):  Python implementation of Figure 3.2  UpMany.py<pre><code>import threading\n\nN = 1000000\ncount = 0\ndone = [ False, False ]\n\ndef incrementer(self):\n    global count\n    for i in range(N):\n        count = count + 1\n    done[self] = True\n    while not done[1 - self]:\n        pass\n    assert count == 2*N, count\n\nthreading.Thread(target=incrementer, args=(0,)).start()\nthreading.Thread(target=incrementer, args=(1,)).start()\n</code></pre> Figure 3.6 (python/UpMany.py):  Using Python to increment N times"},{"location":"textbook/condwait/","title":"Conditional Waiting","text":"<p>Critical sections enable multiple threads to easily share data structures whose modification requires multiple steps. A critical section only allows one thread to execute the code of the critical section at a time. Therefore, when a thread arrives at a critical section, the thread blocks until there is no other thread in the critical section.</p> <p>Sometimes it is useful for a thread to block waiting for additional conditions. For example, when dequeuing from an empty shared queue, it may be useful for the thread to block until the queue is non-empty instead of returning an error. The alternative would be busy waiting (aka spin-waiting), where the thread repeatedly tries to dequeue an item until it is successful. Doing so wastes CPU cycles and adds contention to queue access. A thread that is busy waiting until the queue is non-empty cannot make progress until another thread enqueues an item. However, the thread is not considered blocked because it is changing the shared state by repeatedly acquiring and releasing the lock. A process that is waiting for a condition without changing the state (like in a spinlock) is blocked. A process that is waiting for a condition while changing the state (such as repeatedly trying to dequeue an item, which requires acquiring a lock) is actively busy waiting.</p> <p>We would like to find a solution to conditional waiting so that a thread blocks until the condition holds---or at least most of the time. Before we do so, we will give two classic examples of synchronization problems that involve conditional waiting: reader/writer locks and bounded buffers.</p>"},{"location":"textbook/condwait/#readerwriter-locks","title":"Reader/Writer Locks","text":"<p>Locks are useful when accessing a shared data structure. By preventing more than one thread from accessing the data structure at the same time, conflicting accesses are avoided. However, not all concurrent accesses conflict, and opportunities for concurrency may be lost, hurting performance. One important case is when multiple threads are simply reading the data structure. In many applications, reads are the majority of all accesses, and read operations do not conflict with one another. Allowing reads to proceed concurrently can significantly improve performance.</p> RW.hny<pre><code>def RWlock() returns lock:\n    lock = { .nreaders: 0, .nwriters: 0 }\n\ndef read_acquire(rw):\n    atomically when rw-&gt;nwriters == 0:\n        rw-&gt;nreaders += 1\n\ndef read_release(rw):\n    atomically rw-&gt;nreaders -= 1\n\ndef write_acquire(rw):\n    atomically when (rw-&gt;nreaders + rw-&gt;nwriters) == 0:\n        rw-&gt;nwriters = 1\n\ndef write_release(rw):\n    atomically rw-&gt;nwriters = 0\n</code></pre> Figure 15.1 (code/RW.hny):  Specification of reader/writer locks  RWtest.hny<pre><code>import RW\n\nconst NOPS = 3\n\nrw = RW.RWlock()\n\ndef thread():\n    while choose({ False, True }):\n        if choose({ \"read\", \"write\" }) == \"read\":\n            RW.read_acquire(?rw)\n            rcs: assert (countLabel(rcs) &gt;= 1) and (countLabel(wcs) == 0)\n            RW.read_release(?rw)\n        else:                       # write\n            RW.write_acquire(?rw)\n            wcs: assert (countLabel(rcs) == 0) and (countLabel(wcs) == 1)\n            RW.write_release(?rw)\n\nfor i in {1..NOPS}:\n    spawn thread()\n</code></pre> Figure 15.2 (code/RWtest.hny):  Test code for reader/writer locks  <p>What we want is a special kind of lock that allows either (i) one writer or (ii) one or more readers to acquire the lock. This is called a reader/writer lock. A reader/writer lock is an object whose abstract (and opaque) state contains two integer counters (see Figure 15.1):</p> <ol> <li> <p>nreaders: the number of readers</p> </li> <li> <p>nwriters: the number of writers</p> </li> </ol> <p>satisfying the following invariant:</p> <ul> <li>\\((\\mathit{nreaders} \\ge 0 \\land \\mathit{nwriters} = 0) \\lor         (\\mathit{nreaders} = 0 \\land 0 \\le \\mathit{nwriters} \\le 1)\\)</li> </ul> <p>There are four operations on a reader/writer lock rw:</p> <ul> <li> <p><code>read_acquire</code>(rw): waits until nwriters = 0 and then increments     nreaders;</p> </li> <li> <p><code>read_release</code>(rw): decrements nreaders;</p> </li> <li> <p><code>write_acquire</code>(rw): waits until nreaders = nwriters = 0 and     then sets nwriters to 1;</p> </li> <li> <p><code>write_release</code>(rw): sets nwriters to 0.</p> </li> </ul> <p>Figure 15.2 shows how reader/writer locks operations may be tested. Similar to ordinary locks, a thread is restricted in how it is allowed to invoke these operations. In particular, a thread can only release a reader/writer lock for reading if it acquired the lock for reading and the same for writing.</p> RWcheat.hny<pre><code>import synch\n\ndef RWlock() returns lock:\n    lock = synch.Lock()\n\ndef read_acquire(rw):\n    synch.acquire(rw);\n\ndef read_release(rw):\n    synch.release(rw);\n\ndef write_acquire(rw):\n    synch.acquire(rw);\n\ndef write_release(rw):\n    synch.release(rw);\n</code></pre> Figure 15.3 (code/RWcheat.hny):  \\\"Cheating\\\" reader/writer lock  <p>A problem with this test is that it does not find a problem with an implementation like the one in Figure 15.3. This implementation implements a reader/writer lock as an ordinary lock, and thus lets only one thread in the critical section at a time. In some sense, the implementation is correct because it satisfies the requirements, but it is clearly not a desirable implementation. For a case like this one, it is better to compare behaviors between the specification and the implementation.</p> RWbtest.hny<pre><code>import RW\n\nconst NOPS = 3\n\nrw = RW.RWlock()\n\ndef thread(self):\n    while choose({ False, True }):\n        if choose({ \"read\", \"write\" }) == \"read\":\n            print(self, \"enter ra\")\n            RW.read_acquire(?rw)\n            print(self, \"exit ra\")\n            rcs: assert (countLabel(rcs) &gt;= 1) and (countLabel(wcs) == 0)\n            print(self, \"enter rr\")\n            RW.read_release(?rw)\n            print(self, \"exit rr\")\n        else:                       # write\n            print(self, \"enter wa\")\n            RW.write_acquire(?rw)\n            print(self, \"exit wa\")\n            wcs: assert (countLabel(rcs) == 0) and (countLabel(wcs) == 1)\n            print(self, \"enter wr\")\n            RW.write_release(?rw)\n            print(self, \"enter wr\")\n\nfor i in {1..NOPS}:\n    spawn thread(i)\n</code></pre> Figure 15.4 (code/RWbtest.hny):  A behavioral test of reader/writer locks  <p>Figure 15.4 is the same test as Figure 15.2 but prints identifying information before and every lock operation. Now we can compare behaviors as follows:</p> <pre><code>$ harmony -o rw.hfa -o rwspec.png -cNOPS=2 code/RWbtest.hny\n$ harmony -B rw.hfa -o rwimpl.png -cNOPS=2 -m RW=RWcheat code/RWbtest.hny\n</code></pre> <p>The second command will print a warning that there are behaviors in the specification that are not achieved by the implementation. We set <code>NOPS</code> to 2 to make the behaviors relatively small and easier to compare. It is now possible to compare the outputs in <code>rwspec.png</code> and <code>rwimpl.png</code> and see what behaviors are allowed by the specification that are not allowed by the implementation. (Harmony does not yet have a mechanism to do this automatically.)</p> RWbusy.hny<pre><code>from synch import Lock, acquire, release\n\ndef RWlock() returns lock:\n    lock = { .lock: Lock(), .nreaders: 0, .nwriters: 0 }\n\ndef read_acquire(rw):\n    acquire(?rw-&gt;lock)\n    while rw-&gt;nwriters &gt; 0:\n        release(?rw-&gt;lock)\n        acquire(?rw-&gt;lock)\n    rw-&gt;nreaders += 1\n    release(?rw-&gt;lock)\n\ndef read_release(rw):\n    acquire(?rw-&gt;lock)\n    rw-&gt;nreaders -= 1\n    release(?rw-&gt;lock)\n\ndef write_acquire(rw):\n    acquire(?rw-&gt;lock)\n    while (rw-&gt;nreaders + rw-&gt;nwriters) &gt; 0:\n        release(?rw-&gt;lock)\n        acquire(?rw-&gt;lock)\n    rw-&gt;nwriters = 1\n    release(?rw-&gt;lock)\n\ndef write_release(rw):\n    acquire(?rw-&gt;lock)\n    rw-&gt;nwriters = 0\n    release(?rw-&gt;lock)\n</code></pre> Figure 15.5 (code/RWbusy.hny):  Busy waiting reader/writer lock <p>Figure 15.5 illustrates an implementation of a reader/writer lock that uses active busy waiting.  This is an undesirable solution, as it wastes CPU cycles.  Harmony complains about this solution.</p>"},{"location":"textbook/condwait/#bounded-buffer","title":"Bounded Buffer","text":"boundedbuffer.hny<pre><code>import list\n\ndef BoundedBuffer(size) returns buffer:\n    buffer = { .buffer: [], .size: size }\n\ndef put(bb, v):\n    atomically when len(bb-&gt;buffer) &lt; bb-&gt;size:\n        bb-&gt;buffer = list.append(bb-&gt;buffer, v)\n\ndef get(bb) returns next:\n    atomically when bb-&gt;buffer != []:\n        next = list.head(bb-&gt;buffer)\n        bb-&gt;buffer = list.tail(bb-&gt;buffer)\n</code></pre> Figure 15.6 (code/boundedbuffer.hny):  Bounded buffer specification  <p>A bounded buffer is a queue with the usual <code>put/get</code> interface, but implemented using a buffer of a certain maximum length. If the buffer is full, an enqueuer must wait; if the buffer is empty, a dequeuer must wait. Figure 15.6 specifies a bounded buffer. It is similar to the implementation in Figure 11.1(b) but adds checking for bounds. Coming up with a good implementation is known as the \"Producer/Consumer Problem\" and was proposed by Dijkstra. Multiple producers and multiple consumers may all share the same bounded buffer.</p> <p>The producer/consumer pattern is common. Threads may be arranged in pipelines, where each upstream thread is a producer and each downstream thread is a consumer. Or threads may be arranged in a manager/worker pattern, with a manager producing jobs and workers consuming and executing them in parallel. Or, in the client/server model, some thread may act as a server that clients can send requests to and receive responses from. In that case, there is a bounded buffer for each client/server pair. Clients produce requests and consume responses, while the server consumes requests and produces responses.</p> <p>Unlike an ordinary queue, where queues can grow arbitrarily, bounded buffers provide flow control: if the consumer runs faster than the producer (or producers), it will automatically block until there are new requests. Similarly, if the producers add requests at a rate that is higher than the consumers can deal with, the producers are blocked. While a buffer of size 1 already provides those properties, a larger buffer is able to deal with short spikes without blocking anybody.</p>"},{"location":"textbook/consensus/","title":"Distributed Consensus","text":"<p>Distributed consensus is the problem of having a collection of processors agree on a single value over a network. For example, in state machine replication, the state machines have to agree on which operation to apply next. Without failures, this can be solved using leader election: first elect a leader, then have that leader decide a value. But consensus often has to be done in adverse circumstances, for example in the face of processor failures.</p> <p>Each processor proposes a value, which we assume here to be from the set { 0, 1 }. By the usual definition of consensus, we want the following three properties:</p> <ol> <li> <p>Validity: a processor can only decide a value that has been     proposed;</p> </li> <li> <p>Agreement: if two processors decide, then they decide the same     value.</p> </li> <li> <p>Termination: each processor eventually decides.</p> </li> </ol> <p>The consensus problem is impossible to solve in the face of processor failures and without making assumptions about how long it takes to send and receive a message. Here we will not worry about Termination.</p> <p></p> consensus.hny<pre><code>const N = 4\n\nproposals = [ choose({0, 1}) for i in {0..N-1} ]\ndecision = choose { x for x in proposals }\n\ndef processor(proposal):\n    if choose { False, True }:\n        print decision\n\nprint proposals\nfor i in {0..N-1}:\n    spawn processor(proposals[i])\n</code></pre> Figure 30.1 (code/consensus.hny):  Distributed consensus code and behavior DFA  <p>Figure 30.1 presents a specification for binary consensus---the proposals are from the set {0, 2} In this case there are four processors. The proposal of processor i is in proposals[i]. The decision is chosen from the set of proposals. Each processor may or may not print the decision---capturing the absence of the Termination property. It may be that no decisions are made, but that does not violate either Validity or Agreement. Thus the behavior of the program is to first print the array of proposals, followed by some subset of processors printing their decision. Notice the following properties:</p> <ul> <li> <p>there are \\(16 = 2^4\\) possible proposal configurations;</p> </li> <li> <p>all processors that decide decide the same value;</p> </li> <li> <p>if all processors propose 0, then all processors that decide decide     0;</p> </li> <li> <p>if all processors propose 1, then all processors that decide decide     1.</p> </li> </ul> <p>This is just the specification---in practice we do not have a shared variable in which we can store the decision a priori. We will present a simple consensus algorithm that can tolerate fewer than \\(1/3^{rd}\\) of processors failing by crashing. More precisely, constant <code>F</code> contains the maximum number of failures, and we will assume there are <code>N</code> = 3<code>F</code> + 1 processors.</p> bosco.hny<pre><code>import bag\n\nconst F = 1\nconst N = (3 * F) + 1\nconst NROUNDS = 3\n\nproposals = [ choose({0, 1}) for i in {0..N-1} ]\nnetwork = bag.empty()\n\ndef broadcast(msg):\n    atomically network = bag.add(network, msg)\n\ndef receive(round, k) returns quorum:\n    let msgs = { e:c for (r,e):c in network where r == round }:\n        quorum = bag.combinations(msgs, k)\n\ndef processor(proposal):\n    var estimate, decided = proposal, False\n    broadcast(0, estimate)\n    for round in {0..NROUNDS-1}:\n        atomically when exists quorum in receive(round, N - F):\n            let count = [ bag.multiplicity(quorum, i) for i in { 0..1 } ]:\n                assert count[0] != count[1]\n                estimate = 0 if count[0] &gt; count[1] else 1\n                if count[estimate] == (N - F):\n                    if not decided:\n                        print estimate\n                        decided = True\n                    assert estimate in proposals   # check validity\n                broadcast(round + 1, estimate)\n\nprint proposals\nfor i in {0..N-1}:\n    spawn processor(proposals[i])\n</code></pre> Figure 30.2 (code/bosco.hny):  A crash-tolerant consensus protocol  <p></p> Figure 30.3: The behavior DFA for Figure 30.2  <p>Figure 30.2 presents our algorithm. Besides the network variable, it uses a shared list of proposals and a shared set of decisions. In this particular algorithm, all messages are broadcast to all processors, so they do not require a destination address. The <code>N</code> processors go through a sequence of rounds in which they wait for <code>N</code> -- <code>F</code> messages, update their state based on the messages, and broadcast messages containing their new state. The reason that a processor waits for <code>N</code> -- <code>F</code> rather than <code>N</code> messages is because of failures: up to <code>F</code> processors may never send a message and so it would be unwise to wait for all <code>N</code>. You might be tempted to use a timer and time out on waiting for a particular processor. But how would you initialize that timer? While we will assume that the network is reliable, there is no guarantee that messages arrive within a particular time. We call a set of <code>N</code> -- <code>F</code> processors a quorum. A quorum must suffice for the algorithm to make progress.</p> <p>The state of a processor consists of its current round number (initially 0) and an estimate (initially the proposal). Therefore, messages contain a round number and an estimate. To start things, each processor first broadcasts its initial round number and initial estimate. The number of rounds that are necessary to achieve consensus is not bounded. But Harmony can only check finite models, so there is a constant <code>NROUNDS</code> that limits the number of rounds.</p> <p>In Line\u00a021, a processor waits for <code>N</code> -- <code>F</code> messages using the Harmony atomically when exists statement. Since Harmony has to check all possible executions of the protocol, the <code>receive</code>(round, k) method returns all subbags of messages for the given round that have size k = <code>N</code> -- <code>F</code>. The method uses a dictionary comprehension to filter out all messages for the given round and then uses the <code>bag</code>.<code>combinations</code> method to find all combinations of size k. The atomically when exists statement waits until there is at least one such combination and then chooses an element, which is bound to the quorum variable. The body of the statement is then executed atomically. This is usually how distributed algorithms are modeled, because they can only interact through the network. There is no need to interleave the different processes other than when messages are delivered. By executing the body atomically, a lot of unnecessary interleavings are avoided and this reduces the state space that must be explored by the model checker significantly.</p> <p>The body of the atomically when exists statement contains the core of the algorithm. Note that <code>N</code> -- <code>F</code> = 2<code>F</code> + 1, so that the number of messages is guaranteed to be odd. Also, because there are only 0 and 1 values, there must exist a majority of zeroes or ones. Variable count[0] stores the number of zeroes and count[1] stores the number of ones received in the round. The rules of the algorithm are simple:</p> <ul> <li> <p>update estimate to be the majority value;</p> </li> <li> <p>if the quorum is unanimous, decide the value.</p> </li> </ul> <p>After that, proceed with the next round.</p> <p>To check for correct behavior, run the following two commands:</p> <pre><code>$ harmony -o consensus.hfa code/consensus.hny\n$ harmony -B consensus.hfa code/bosco.hny\n</code></pre> <p>Note that the second command prints a warning: \"<code>behavior warning: strict subset of specified behavior</code>.\" Thus, the set of behaviors that our algorithm generates is a subset of the behavior that the specification allows. Figure 30.3 shows the behavior, and indeed it is not the same as the behavior of Figure 30.1. This is because in our algorithm the outcome is decided a priori if more than twothirds of the processors have the same proposal, whereas in the consensus specification the outcome is only decided a priori if the processors are initially unanimous. Another difference is that if the outcome is decided a priori, all processors are guaranteed to decide.</p> bosco2.hny<pre><code>import bag\n\nconst F = 1\nconst N = (3 * F) + 1\nconst NROUNDS = 3\n\nlet n_zeroes = choose { 0 .. N / 2 }:\n    proposals = ([0,] * n_zeroes) + ([1,] * (N - n_zeroes))\nnetwork = bag.empty()\n\ndef broadcast(msg):\n    atomically network = bag.add(network, msg)\n\ndef receive(round) returns quorum:\n    let msgs = { e:c for (r,e):c in network where r == round }:\n        quorum = {} if bag.size(msgs) &lt; N else { msgs }\n\ndef processor(proposal):\n    var estimate, decided = proposal, False\n    broadcast(0, estimate)\n    for round in {0..NROUNDS-1}:\n        atomically when exists msgs in receive(round):\n            let choices = bag.combinations(msgs, N - F)\n            let quorum = choose(choices)\n            let count = [ bag.multiplicity(quorum, i) for i in { 0..1 } ]:\n                assert count[0] != count[1]\n                estimate = 0 if count[0] &gt; count[1] else 1\n                if count[estimate] == (N - F):\n                    if not decided:\n                        print estimate\n                        decided = True\n                    assert estimate in proposals           # validity\n                broadcast(round + 1, estimate)\n\nprint proposals\nfor i in {0..N-1}:\n    spawn processor(proposals[i])\n</code></pre> Figure 30.4 (code/bosco2.hny):  Reducing the state space  <p>While one can run this code within little time for <code>F</code> = 1, for <code>F</code> = 2 the state space to explore is already quite large. One way to reduce the state space to explore is the following realization: each processor only considers messages for the round that it is in. If a message is for an old round, the processor will ignore it; if a message is for a future round, the processor will buffer it. So, one can simplify the model and have each processor wait for all <code>N</code> messages in a round instead of <code>N</code> -- <code>F</code>. It would still have to choose to consider just <code>N</code> -- <code>F</code> out of those <code>N</code> messages, but executions in which some processors are left behind in all rounds are no longer considered. It still includes executions where some subset of <code>N</code> -- <code>F</code> processors only choose each other messages and essentially ignore the messages of the remaining <code>F</code> processors, so the resulting model is just as good.</p> <p>Another way to reduce the state space to explore is to leverage symmetry. First of all, it does not matter who proposes a particular value. Also, the values 0 and 1 are not important to how the protocol operates. So, with 5 processors (<code>F</code> = 2), say, we only need to explore the cases where no processors propose 1, where exactly one processors proposes 1, and where 2 processors proposes 1.</p> <p>Figure 30.4 shows the code for this optimized model. Running this with <code>F</code> = 2 does not take very long and this approach is a good blueprint for testing other round-based protocols (of which there are many).</p>"},{"location":"textbook/consensus/#exercises","title":"Exercises","text":"<p>30.1 The algorithm as given works in the face of crash failures. A more challenging class to tolerate are arbitrary failures in which up to <code>F</code> processors may send arbitrary messages, including conflicting messages to different peers (equivocation). The algorithm can tolerate those failures if you use \\(\\texttt{N} = 5\\texttt{F} - 1\\) processors instead of \\(\\texttt{N} = 3\\texttt{F} - 1\\). Check that.</p> <p>30.2 In 1983, Michael Ben-Or presented a randomized algorithm that can tolerate crash failures with just \\(\\texttt{N} = 2\\texttt{F} - 1\\) processors. Implement this algorithm.</p>"},{"location":"textbook/critical/","title":"Critical Sections","text":"<p>Hopefully you have started thinking of how to solve the concurrency problem and you may already have prototyped some solutions. In this chapter, we will go through a few reasonable but broken attempts. At the heart of the problem is that we would like make sure that, when the count variable is being updated, no other thread is trying to do the same thing. This is called a critical section (aka critical region): a set of instructions where only one thread is allowed to execute at a time.</p> <p>Critical sections are useful when accessing a shared data structure, particularly when that access requires multiple underlying machine instructions. A counter is a very simple example of a data structure (it is an array of bits), but---as we have seen---incrementing it requires multiple instructions. A more involved one would be accessing a binary tree. Adding a node to a binary tree, or re-balancing a tree, often requires multiple operations. Maintaining \"consistency\" is certainly much easier if during this time no other thread also tries to access the binary tree. Typically, you want some invariant property of the data structure to hold at the beginning and at the end of the critical section, but in the middle the invariant may be temporarily broken---this is not a problem as critical sections guarantee that no other thread will be able to see it. An implementation of a data structure that can be safely accessed by multiple threads and is free of race conditions is called thread-safe.</p> csbarebones.hny<pre><code>def thread():\n    while True:\n        # Enter critical section\n\n        # Critical section is here\n        cs: assert countLabel(cs) == 1\n\n        # Exit critical section\n\nspawn thread()\nspawn thread()\n</code></pre> Figure 5.1 (code/csbarebones.hny):  A bare bones critical section with two threads  cs.hny<pre><code>def thread():\n    while choose({ False, True }):\n        # Enter critical section\n\n        # Critical section is here\n        cs: assert countLabel(cs) == 1\n\n        # Exit critical section\n\nspawn thread()\nspawn thread()\n</code></pre> Figure 5.2 (code/cs.hny):  Harmony model of a critical section <p>A critical section is often modeled as threads in an infinite loop entering and exiting the critical section. Figure 5.1 shows the Harmony code. Here <code>cs</code> is a label, identifying a location in the HVM bytecode. The first thing we need to ensure is that there can never be two threads in the critical section. This property is called mutual exclusion. We would like to place an assertion at the <code>cs</code> label that specifies that only one (the current) thread can be there.</p> <p>Harmony in fact supports this. It has an operator countLabel l, where l is the name of the label (in this case, <code>cs</code>). The operator returns the number of threads executing at that label. Method countLabel only exists for specification purposes---do not use it in normal code. If you run the code through Harmony, the assertion should fail because there is no code yet for safely entering and exiting the critical section.</p> <p>However, mutual exclusion by itself is easy to ensure. For example, we could insert the following code to enter the critical section: <pre><code>await False\n</code></pre> This code will surely prevent two or more threads from being at label <code>cs</code> at the same time. But it does so by preventing any thread from reaching the critical section. We clearly need another property besides mutual exclusion.</p> <p>Mutual exclusion is an example of a safety property, a property that ensures that nothing bad will happen, in this case two threads being in the critical section. What we need now is a liveness property: we want to ensure that eventually something good will happen. There are various possible liveness properties we could use, but here we will propose the following informally: if (1) there exists a non-empty set \\(S\\) of threads that are trying to enter the critical section and (2) threads in the critical section always leave eventually, then eventually one thread in \\(S\\) will enter the critical section. We call this progress.</p> <p>In order to detect violations of progress, and other liveness problems in algorithms in general, Harmony requires that every execution must be able to reach a state in which all threads have terminated. Clearly, even if mutual exclusion holds in Figure 5.1, the spawned threads never terminate. We will instead model threads in critical sections using the framework in Figure 5.2: a thread can choose to enter a critical section more than once, but it can also choose to terminate, even without entering the critical section ever. (Recall that Harmony will try every possible execution, and so it will evaluate both choices.) As it turns out, there is an advantage to doing it this way: we can also test if a thread can enter when there is no other thread trying to enter the critical section. As we will see below, this is not always obvious.</p> <p>We will now consider various approaches toward implementing this specification.</p> naiveLock.hny<pre><code>lockTaken = False\n\ndef thread(self):\n    while choose({ False, True }):\n        # Enter critical section\n        await not lockTaken\n        lockTaken = True\n\n        # Critical section\n        cs: assert countLabel(cs) == 1\n\n        # Leave critical section\n        lockTaken = False\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> <p> Figure 5.3 (code/naiveLock.hny):  Na\u0131\u0308ve implementation of a shared lock and the [HTML output]{.underline} of running Harmony on Figure 5.3 </p> naiveFlags.hny<pre><code>flags = [ False, False ]\n\ndef thread(self):\n    while choose({ False, True }):\n        # Enter critical section\n        flags[self] = True\n        await not flags[1 - self]\n\n        # Critical section\n        cs: assert countLabel(cs) == 1\n\n        # Leave critical section\n        flags[self] = False\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> <p> Figure 5.4 (code/naiveFlags.hny):  Na\u0131\u0308ve use of flags to solve mutual exclusion and the [HTML output]{.underline} of running Harmony on Figure 5.4 </p> naiveTurn.hny<pre><code>turn = 0\n\ndef thread(self):\n    while choose({ False, True }):\n        # Enter critical section\n        turn = 1 - self\n        await turn == self\n\n        # Critical section\n        cs: assert countLabel(cs) == 1\n\n        # Leave critical section\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> Figure 5.5 ( code/naiveTurn.hny):  Na\u0131\u0308ve use of turn variable to solve mutual exclusion  <p>You may already have heard of the concept of a lock and have realized that it could be used to implement a critical section. The idea is that the lock is like a baton that at most one thread can own (or hold) at a time. A thread that wants to enter the critical section at a time must obtain the lock first and release it upon exiting the critical section.</p> <p>Using a lock is a good thought, but how does one implement one? Figure 5.3 presents an attempt at mutual exclusion based on a na\u0131\u0308ve (and, as it turns out, incorrect) implementation of a lock. Initially the lock is not owned, indicated by lockTaken being <code>False</code>. To enter the critical section, a thread waits until lockTaken is <code>False</code> and then sets it to <code>True</code> to indicate that the lock has been taken. The thread then executes the critical section. Finally, the thread releases the lock by setting lockTaken back to <code>False</code>.</p> <p>Unfortunately, if we run the program through Harmony, we find that the assertion fails. Figure 5.3 also shows the Harmony output. <code>thread</code>(1) finds that the lock is available, but just before it stores <code>True</code> in lockTaken, <code>thread</code>(0) gets to run. (Recall that you can hover your mouse over a machine instruction in order to see what it does.) Because lockTaken is still <code>False</code>, it too believes it can acquire the lock, and stores <code>True</code> in lockTaken and moves on to the critical section. Finally, <code>thread</code>(1) moves on, also stores <code>True</code> into lockTaken and also moves into the critical section. <code>thread</code>(1) is the one that detects the problem. The lockTaken variable suffers from the same sort of race condition as the count variable in Figure 3.2: testing and setting the lock consists of several instructions. It is thus possible for both threads to believe the lock is available and to obtain the lock at the same time.</p> <p>Preventing multiple threads from updating the same variable, Figure 5.4 presents a solution based on each thread having a flag indicating that it is trying to enter the critical section. A thread can write its own flag and read the flag of its peer. After setting its flag, the thread waits until the other thread (\\(1 - \\mathit{self}\\)) is not trying to enter the critical section. If we run this program, the assertion does not fail. In fact, this solution does prevent both threads being in the critical section at the same time.</p> <p>To see why, first note the following invariant: if thread i is in the critical section, then flags[i] = <code>True</code>. Without loss of generality, suppose that thread\u00a00 sets flags[0] at time \\(t_0\\). Thread 0 can only reach the critical section if at some time \\(t_1\\), \\(t_1 &gt; t_0\\), it finds that flags[1] = <code>False</code>. Because of the invariant, flags[1] = <code>False</code> implies that thread\u00a01 is not in the critical section at time \\(t_1\\). Let \\(t_2\\) be the time at which thread\u00a00 sets flags[0] to <code>False</code>. Thread\u00a00 is in the critical section sometime between \\(t_1\\) and \\(t_2\\). It is easy to see that thread\u00a01 cannot enter the critical section between \\(t_1\\) and \\(t_2\\), because flags[1] = <code>False</code> at time \\(t_1\\). To reach the critical section between \\(t_1\\) and \\(t_2\\), it would first have to set flags[1] to <code>True</code> and then wait until flags[0] = <code>False</code>. But that does not happen until time \\(t_2\\).</p> <p>However, if you run the program through Harmony, it turns out the solution does have a problem: if both try to enter the critical section at the same time, they may end up waiting for one another indefinitely. (This is a form of deadlock, which will be discussed in Chapter 19.) Thus the solution violates progress.</p> <p>The final na\u0131\u0308ve solution that we propose is based on a variable called turn. Each thread politely lets the other thread have a turn first. When turn = i, thread\u00a0i can enter the critical section, while thread \\(1-i\\) has to wait. An invariant of this solution is that while thread\u00a0i is in the critical section, turn = i. Since turn cannot be 0 and 1 at the same time, mutual exclusion is satisfied. The solution also has the nice property that the thread that has been waiting the longest to enter the critical section can go next.</p> <p>Run the program through Harmony. It turns out that this solution also violates progress, albeit for a different reason: if thread\u00a0i terminates instead of entering the critical section, thread \\(1-i\\), politely, ends up waiting indefinitely for its turn. Too bad, because it would have been a great solution if both threads try to enter the critical section ad infinitum.</p>"},{"location":"textbook/critical/#exercises","title":"Exercises","text":"<p>5.1 Run Figure 5.2 using Harmony. As there is no protection of the critical section, mutual exclusion is violated, the assertion should fail, and a trace should be reported. Now insert <pre><code>await False\n</code></pre> just before entering the critical section in Figure 5.2 and run Harmony again. Mutual exclusion is guaranteed but progress is violated. Harmony should print a trace to a state from which a terminating state cannot be reached. Describe in English the difference in the failure reports before and after inserting the code.</p> <p>5.2 See if you can come up with some different approaches that satisfy both mutual exclusion and progress. Try them with Harmony and see if they work or not. If they don't, try to understand why. If you get active busy waiting or data race reports, you probably found a correct solution; you'll learn later how to suppress those. Do not despair if you can't figure out how to develop a solution that satisfies both mutual exclusion and progress---as we will find out, it is possible but not obvious.</p>"},{"location":"textbook/deadlock/","title":"Deadlock","text":"<p>When multiple threads are synchronizing access to shared resources, they may end up in a deadlock situation where one or more of the threads end up being blocked indefinitely because each is waiting for another to give up a resource. The famous Dutch computer scientist Edsger W.\u00a0Dijkstra illustrated this using a scenario he called \"Dining Philosophers.\"</p> <p>Imagine five philosopers sitting around a table, each with a plate of food in front of them and a fork between every two plates. Each philosopher requires two forks to eat. To start eating, a philosopher first picks up the fork on the left, then the fork on the right. Each philosopher likes to take breaks from eating to think for a while. To do so, the philosopher puts down both forks. Each philosopher repeats this procedure. Dijkstra had them repeating this for ever, but for the purposes of this book, philosophers can---if they wish---leave the table when they are not using any forks.</p> Diners.hny<pre><code>from synch import Lock, acquire, release\n\nconst N = 5\n\nforks = [Lock(),] * N\n\ndef diner(which):\n    let left, right = (which, (which + 1) % N):\n        while choose({ False, True }):\n            acquire(?forks[left])\n            acquire(?forks[right])\n            # dine\n            release(?forks[left])\n            release(?forks[right])\n            # think\n\nfor i in {0..N-1}:\n    spawn diner(i)\n</code></pre> Figure 19.1 (code/Diners.hny):  Dining Philosophers  <p>Figure 19.1 implements the dining philosophers in Harmony, using a thread for each philosopher and a lock for each fork. If you run it, Harmony complains that the execution may not be able to terminate, with all five threads being blocked trying to acquire the lock.</p> <ul> <li> <p>Do you see what the problem is?</p> </li> <li> <p>Does it depend on <code>N</code>, the number of philosophers?</p> </li> <li> <p>Does it matter in what order the philosophers lay down their     forks?</p> </li> </ul> <p>There are four conditions that must hold for deadlock to occur:</p> <ol> <li> <p>Mutual Exclusion: each resource can only be used by one thread at     a time:</p> </li> <li> <p>Hold and Wait: each thread holds resources it already allocated     while it waits for other resources that it needs;</p> </li> <li> <p>No Preemption: resources cannot be forcibly taken away from     threads that allocated them;</p> </li> <li> <p>Circular Wait: there exists a directed circular chain of threads,     each waiting to allocate a resource held by the next.</p> </li> </ol> <p>Preventing deadlock thus means preventing that one of these conditions occurs. However, mutual exclusion is not easily prevented in general (although, for some resources it is possible, as demonstrated in Chapter 23). Havender proposed the following techniques that avoid the remaining three conditions:</p> <ul> <li> <p>No Hold and Wait: a thread must request all resources it is going     to need at the same time;</p> </li> <li> <p>Preemption: if a thread is denied a request for a resource, it     must release all resources that it has already acquired and start     over;</p> </li> <li> <p>No Circular Wait: define an ordering on all resources and allocate     resources in a particular order.</p> </li> </ul> DinersCV.hny<pre><code>import synch\n\nconst N = 5\n\nmutex = synch.Lock()\nforks = [False,] * N\nconds = [synch.Condition(),] * N\n\ndef diner(which):\n    let left, right = (which, (which + 1) % N):\n        while choose({ False, True }):\n            synch.acquire(?mutex)\n            while forks[left] or forks[right]:\n                if forks[left]:\n                    synch.wait(?conds[left], ?mutex)\n                if forks[right]:\n                    synch.wait(?conds[right], ?mutex)\n            assert not (forks[left] or forks[right])\n            forks[left] = forks[right] = True\n            synch.release(?mutex)\n            # dine\n            synch.acquire(?mutex)\n            forks[left] = forks[right] = False\n            synch.notify(?conds[left]);\n            synch.notify(?conds[right])\n            synch.release(?mutex)\n            # think\n\nfor i in {0..N-1}:\n    spawn diner(i)\n</code></pre> Figure 19.2 (code/DinersCV.hny):  Dining Philosophers that grab both forks at the same time  <p>To implement a No Hold and Wait solution, a philosopher would need a way to lock both the left and right forks at the same time. Locks do not have such an ability, and neither do semaphores. so we re-implement the Dining Philosophers using condition variables that allow one to wait for arbitrary application-specific conditions. Figure 19.2 demonstrates how this might be done. We use a single mutex for the diners, and, for each fork, a boolean and a condition variable. The boolean indicates if the fork has been taken. Each diner waits if either the left or right fork is already taken. But which condition variable to wait on? The code demonstrates an important technique to use when waiting for multiple conditions. The condition in the while statement is the negation of the condition that the diner is waiting for and consists of two disjuncts. Within the while statement, there is an if statement for each disjunct. The code waits for either or both forks if necessary. After that, it goes back to the top of the while loop.</p> <p>A common mistake is to write the following code instead:</p> <pre><code>while forks[left]:\n\u00a0\u00a0\u00a0\u00a0synch.wait(?conds[left], ?mutex)\nwhile forks[right]:\n\u00a0\u00a0\u00a0\u00a0synch.wait(?conds[right], ?mutex)\n</code></pre> <ul> <li> <p>Can you see why this does not work? What can go wrong?</p> </li> <li> <p>Run it through Harmony in case you are not sure!</p> </li> </ul> <p>The Preemption approach suggested by Havender is to allow threads to back out. While this could be done, this invariably leads to a busy waiting solution where a thread keeps obtaining locks and releasing them again until it finally is able to get all of them.</p> <p>The No Circular Waiting approach is to prevent a cycle from forming, with each thread waiting for the next thread on the cycle. We can do this by establishing an ordering among the resources (in this case the forks) and, when needing more than one resource, always acquiring them in order. In the case of the philosopers, they could prevent deadlock by always picking up the lower numbered fork before the higher numbered fork, like so:</p> <pre><code>if left &lt; right:\n\u00a0\u00a0\u00a0\u00a0synch.acquire(?forks[left])\n\u00a0\u00a0\u00a0\u00a0synch.acquire(?forks[right])\nelse:\n\u00a0\u00a0\u00a0\u00a0synch.acquire(?forks[right])\n\u00a0\u00a0\u00a0\u00a0synch.acquire(?forks[left])\n</code></pre> <p>or like so:</p> <pre><code>synch.acquire(?forks[min(left, right)])\nsynch.acquire(?forks[max(left, right)])\n</code></pre> <p>This completes all the Havender methods. There is, however, another approach, which is sometimes called deadlock avoidance instead of deadlock prevention. In the case of the Dining Philosophers, we want to avoid the situation where each diner picks up a fork. If we can prevent more than four diners from starting to eat at the same time, then we can avoid the conditions for deadlock from ever happening. Figure 19.3 demonstrates this concept. It uses a counting semaphore to restrict the number of diners at any time to four. A counting semaphore is like a binary semaphore, but can be acquired a given number of times. It is supported by the <code>synch</code> module. The <code>P</code> or \"procure\" operation acquires a counting semaphore. That is, it tries to decrement the semaphore, blocking while the semaphore has a value of 0. The <code>V</code> or \"vacate\" operation increments the semaphore.</p> DinersAvoid.hny<pre><code>from synch import *\n\nconst N = 5\n\nforks = [Lock(),] * N\nsema = Semaphore(N - 1)     # can be procured up to N-1 times\n\ndef diner(which):\n    let left, right = (which, (which + 1) % N):\n        while choose({ False, True }):\n            P(?sema)                # procure counting semaphore\n            acquire(?forks[left])\n            acquire(?forks[right])\n            # dine\n            release(?forks[left])\n            release(?forks[right])\n            V(?sema)                # vacate counting semaphore\n            # think\n\nfor i in {0..N-1}:\n    spawn diner(i)\n</code></pre> Figure 19.3 (code/DinersAvoid.hny): Dining Philosophers that carefully avoid getting into a dead-lock scenario  <p>This avoidance technique can be generalized using something called the Banker's Algorithm, but it is outside the scope of this book. The problem with these kinds of schemes is that one needs to know ahead of time the set of threads and what the maximum number of resources is that each thread wants to allocate, making them generally quite impractical.</p>"},{"location":"textbook/deadlock/#exercises","title":"Exercises","text":"<p>19.1 The solution in Figure 19.2 can be simplified by, instead of having a condition variable per fork, having a condition variable per diner. It uses the same number of condition variables, but you will not need to have if statements nested inside the while loop waiting for the forks. See if you can figure it out.</p> <p>19.2 Figure 19.4 shows an implementation of a bank with various accounts and transfers between those accounts. Unfortunately, running the test reveals that it sometimes leaves unterminated threads. Can you fix the problem?</p> <p>19.3 Add a method <code>total</code>() to the solution of the previous question that computes the total over all balances. It needs to obtain a lock on all accounts. Make sure that it cannot cause deadlock.</p> <p>19.4 Add an invariant that checks that the total of the balances never changes. Note that the invariant only holds if none of the locks are held.</p> bank.hny<pre><code>from synch import Lock, acquire, release\n\nconst MAX_BALANCE = 2\nconst N_ACCOUNTS = 2\nconst N_THREADS = 2\n\naccounts = [ { .lock: Lock(), .balance: choose({0..MAX_BALANCE})}\n                            for i in {1..N_ACCOUNTS} ]\n\ndef transfer(a1, a2, amount) returns success:\n    acquire(?accounts[a1].lock)\n    if amount &lt;= accounts[a1].balance:\n        accounts[a1].balance -= amount \n        acquire(?accounts[a2].lock)\n        accounts[a2].balance += amount \n        release(?accounts[a2].lock)\n        success = True\n    else:\n        success = False\n    release(?accounts[a1].lock)\n\ndef thread():\n    let a1 = choose({0..N_ACCOUNTS-1})\n    let a2 = choose({0..N_ACCOUNTS-1} - { a1 }):\n        transfer(a1, a2, choose({1..MAX_BALANCE}))\n\nfor i in {1..N_THREADS}:\n    spawn thread()\n</code></pre> Figure 19.4 (code/bank.hny):  Bank accounts"},{"location":"textbook/debugging/","title":"Debugging","text":"<p>So, you wrote a Harmony program and Harmony reports a problem. Often you may just be able to figure it out by staring at the code and going through some easy scenarios, but what if you don't? The output of Harmony can be helpful in that case.</p> queuebroken.hny<pre><code>from synch import Lock, acquire, release\nfrom alloc import malloc, free\n\ndef Queue() returns empty:\n    empty = { .next: None, .value: None, .lock: Lock() }\n\ndef put(q, v):\n    let node = malloc({ .next: None, .value: v, .lock: Lock() }):\n        var nq = q\n        while nq != None:\n            acquire(?nq-&gt;lock)\n            let n = nq-&gt;next:\n                if n == None:\n                    nq-&gt;next = node\n                release(?nq-&gt;lock)\n                nq = n\n\ndef get(q) returns next:\n    acquire(?q-&gt;lock)\n    if q-&gt;next == None:\n        next = None\n    else:\n        let node = q-&gt;next:\n            q-&gt;next = node-&gt;next\n            next = node-&gt;value\n            free(node)\n    release(?q-&gt;lock)\n</code></pre> Figure 14.1 (code/queuebroken.hny):  Another buggy queue implementation  <p></p> Figure 14.2: Harmony output of running Figure 13.2 against Figure 14.1 <p>Figure 14.1 contains an attempt at a queue implementation where the queue is implemented by a linked list, with the first node being a <code>dummy</code> node to prevent data races. Each node in the list contains a lock. The <code>put</code>() method walks the list until it gets to the last node, each time acquiring the lock to access the node's fields. When <code>put</code>() gets to the last node in the list, it appends a new one. The <code>get</code>() method locks the first (dummy) node, removes the second from the list and frees it. The method returns the value from the removed node.</p> <p>Let us run the code through the test programs in the last chapter. Harmony does not detect any issues with the sequential test in Figure 13.1. (Run this using the <code>-m</code> flag like this: <code>harmony -m queue=queuebroken code/qtestseq.hny</code>) However, when we run the new queue code through the test in Figure 13.2, Harmony reports a safety violation (even without specifying a behavior). The command line to reproduce this is:</p> <pre><code>harmony -m queue=queuebroken code/qtestpar.hny\n</code></pre> <p>Before we go look at the details of what went wrong, we want to make sure that we generate the simplest scenario. So, first we want to explore what the smallest <code>NOPS</code> (number of operations or number of threads) that causes the bug to occur. With some experimentation, we find that <code>NOPS</code> = 2 does not find a problem, but <code>NOPS</code> = 3 does (<code>harmony -m queue=queuebroken -c NOPS=3 code/qtestpar.hny</code>)). Figure 14.2 shows the Harmony output.</p> <p>There is quite a bit of information in the Harmony output, and while it may seem intimidating, we have to learn to navigate through it step-by-step. Let's start with looking at the red text. Harmony found a safety violation (something bad happened during one of the possible executions), and in particular <code>thread</code>(2) (thread T2) was trying to dereference the address ?<code>alloc</code>$<code>pool</code>[0][<code>\"</code>lock<code>\"</code>].</p> <p>The <code>alloc</code> module maintains a shared array pool that it uses for dynamic allocation. Apparently T2 tried to access pool[0], but it does not exist, meaning that either it was not yet allocated, or it had been freed since it was allocated. When we look at the top half of the figure, we see that in fact thread T1 allocated pool[0] in turn 2, but T3 freed it in turn 4. Looking back down, we see that T1 executed <code>thread</code>(1) and has since terminated, while T3 is executing <code>thread</code>(3).</p> <p>Looking further at the stack traces, we can see that T3 was in the process of executing <code>release</code>(?q.lock) within <code>get</code>(?q). T1 is currently executing <code>acquire</code>(?<code>alloc</code>.pool[0].lock) within <code>put</code>(?q, 2), but <code>alloc</code>.pool[0] does not exist. The corresponding line of Harmony code is atomically when not !binsema in line 25 of the <code>sync</code> module.</p> <p>So, how did we get there? In the top we can see that the order of events was the following:</p> <ol> <li> <p>initialization completed, with q being { .lock: <code>False</code>,     .next: <code>None</code>, .value: <code>None</code> };</p> </li> <li> <p>thread T1 (<code>thread</code>(1)) ran and finished executing <code>put</code>(1) (see the     output column for that clue: the thread printed that). We can see     that q.next now points to <code>alloc</code>.pool[0], which the thread     must have allocated. The contents is { .lock: <code>False</code>, .next:     <code>None</code>, .value: 1 }, as expected;</p> </li> <li> <p>thread T2 (<code>thread</code>(1)) started running, calling <code>put</code>(?q, 2). We     can see it got as far as putting 2 on the queue, but it is not yet     done. It is currently trying to acquire <code>alloc</code>.pool[0].lock;</p> </li> <li> <p>thread T3 (<code>thread</code>(1)) started running, calling <code>get</code>(?q). We can     also see that it freed pool[0], and is now releasing q.lock;</p> </li> <li> <p>thread T2 resumes and tries to access pool[0], which no longer     exists (because T3 just freed it).</p> </li> </ol> <p>Clearly there was a race in which T2 was trying to lock pool[0].lock (which contained the node with the value 1) while T3 was freeing that very same node, and T2 lost the race. More precisely, T2 was executing <code>put</code>(?q, 2), when T3 preempted it with <code>get</code>(?q) and removed the node that T2 was trying to access. But why did the locks not prevent this?</p> <p>It is time to start stepping through the code that has been executed before this happened. This is sometimes known as reverse debugging. In fact, Harmony allows you to step through an execution forwards and backwards. In this case, we first want to see what T2 is doing. You can click on its first (top-left) orange box to time-travel to that part in the execution. Now by hitting \\(\\langle\\mathtt{return}\\rangle\\) repeatedly, we can quickly skip through the code. T2 first calls <code>put</code>(?q, 1) and then allocates a new node initialized with a lock. Keep stepping until it executes nq = q. Hit \\(\\langle\\mathtt{return}\\rangle\\) once more and inspect the state of T2 in the lower-right corner. You can see that variable nq is initialized to\u00a0?q. T2 then enters into the while loop and tries to acquire nq-&gt;lock. This succeeds, and next T2 executes let n = nq-&gt;next. Now n = ?<code>alloc</code>.pool[0], which is not <code>None</code>. It then releases nq-&gt;lock (nq points to q). It then sets nq to \\(n\\), which is still <code>alloc</code>.pool[0]. Finally, it calls <code>acquire</code>(?nq-&gt;lock). But before it can complete that operation, T3 runs next.</p> <p>T3 chooses <code>\"</code>get<code>\"</code> and then goes on to invoke <code>get</code>(?q). This first successfully acquires q}-&gt;lock. T3 then finds out that q-&gt;next points to <code>alloc</code>.pool[0]. T3 sets node to <code>alloc</code>.pool[0] as well and sets q-&gt;next to node-&gt;next. T3 the method result next to node-&gt;value (which is 1) and then frees node. This is where the problem is---T2 is about to acquire the lock in that same node.</p> queuefix.hny<pre><code>from synch import Lock, acquire, release\nfrom alloc import malloc, free\n\ndef Queue() returns empty:\n    empty = { .next: None, .value: None, .lock: Lock() }\n\ndef put(q, v):\n    var nq = q\n    let node = malloc({ .next: None, .value: v, .lock: Lock() }):\n        acquire(?nq-&gt;lock)\n        var n = nq-&gt;next\n        while n != None:\n            acquire(?n-&gt;lock)\n            release(?nq-&gt;lock)\n            nq = n\n            n = n-&gt;next\n        nq-&gt;next = node\n        release(?nq-&gt;lock)\n\ndef get(q) returns next:\n    acquire(?q-&gt;lock)\n    if q-&gt;next == None:\n        next = None\n    else:\n        let node = q-&gt;next:\n            acquire(?node-&gt;lock)\n            q-&gt;next = node-&gt;next\n            next = node-&gt;value\n            release(?node-&gt;lock)\n            free(node)\n    release(?q-&gt;lock)\n</code></pre> Figure 14.3 (code/queuefix.hny):  Queue implementation with hand-over-hand locking  <p>To fix the code without changing the data structure, we can use hand-over-hand locking (Chapter 12). Figure 14.3 shows an implementation that uses hand-over-hand locking both for <code>put</code>() and for <code>get</code>(). It passes all tests.</p>"},{"location":"textbook/finegrained/","title":"Fine-Grained Locking","text":"<p>A queue has the nice property that usually only the head or the tail is accessed. However, in many data structures it is necessary to \"walk\" the data structure, an operation that can take significant time. In such a case, a single lock (known as a \"big lock\") for the entire data structure might restrict concurrency to an unacceptable level. To reduce the granularity of locking, each node in the data structure must be endowed with its own lock instead.</p> setobj.hny<pre><code>from alloc import malloc\n\ndef SetObject() returns object:\n    object = malloc({})\n\ndef insert(s, v):\n    atomically !s |= {v}\n\ndef remove(s, v):\n    atomically !s -= {v}\n\ndef contains(s, v) returns present:\n    atomically present = v in !s\n</code></pre> Figure 12.1 (code/setobj.hny):  Specification of a concurrent set object  setobjtest.hny<pre><code>from setobj import *\n\nmyset = SetObject()\n\ndef thread1():\n    insert(myset, 1)\n    let x = contains(myset, 1):\n        assert x\n\ndef thread2(v):\n    insert(myset, v)\n    remove(myset, v)\n\nspawn thread1()\nspawn thread2(0)\nspawn thread2(2)\n</code></pre> Figure 12.2 (code/intsettest.hny):  Test code for set objects <p>Figure 12.1 gives the specification of a concurrent set object. <code>SetObject()</code> returns a pointer to a variable that contains an empty set, rather than returning an empty set value. As such, it is more like an object in an object-oriented language than like a value in its own right. Values can be added to the set object using <code>insert()</code> or deleted using <code>remove()</code>. Method <code>contains()</code> checks if a particular value is in the list. Figure 12.2 contains a simple (although not very thorough) test program to demonstrate the use of set objects.</p> linkedlist.hny<pre><code>from synch import Lock, acquire, release\nfrom alloc import malloc, free\n\ndef _node(v, n) returns node:   # allocate and initialize a new list node\n    node = malloc({ .lock: Lock(), .value: v, .next: n })\n\ndef _find(lst, v) returns pair:\n    var before = lst\n    acquire(?before-&gt;lock)\n    var after = before-&gt;next\n    acquire(?after-&gt;lock)\n    while after-&gt;value &lt; (0, v):\n        release(?before-&gt;lock)\n        before = after\n        after = before-&gt;next\n        acquire(?after-&gt;lock)\n    pair = (before, after)\n\ndef SetObject() returns object:\n    object = _node((-1, None), _node((1, None), None))\n\ndef insert(lst, v):\n    let before, after = _find(lst, v):\n        if after-&gt;value != (0, v):\n            before-&gt;next = _node((0, v), after)\n        release(?after-&gt;lock)\n        release(?before-&gt;lock)\n\ndef remove(lst, v):\n    let before, after = _find(lst, v):\n        if after-&gt;value == (0, v):\n            before-&gt;next = after-&gt;next\n            release(?after-&gt;lock)\n            free(after)\n        else:\n            release(?after-&gt;lock)\n        release(?before-&gt;lock)\n\ndef contains(lst, v) returns present:\n    let before, after = _find(lst, v):\n        present = after-&gt;value == (0, v)\n        release(?after-&gt;lock)\n        release(?before-&gt;lock)\n</code></pre> Figure 12.3 (code/linkedlist.hny):  Implementation of a set of values using a linked list with fine-grained locking  <p>Figure 12.3 implements a concurrent set object using an ordered linked list without duplicates. The list has two dummy ``book-end'' nodes with values \\((-1, None)\\) and \\((1, None)\\).  A value \\(v\\) is stored as \\((0, v)\\) \u2014 note that for any value \\(v\\), \\((-1, None) &lt; (0, v) &lt; (1, None)\\). An invariant of the algorithm is that at any point in time list is \"valid\", starting with a \\((-1, None)\\) node and ending with an \\((1, None)\\) node.</p> <p>Each node has a lock, a value, and next, a pointer to the next node (which is <code>None</code> for the \\((1, None)\\) node to mark the end of the list). The <code>_find</code>(lst, v) helper method first finds and locks two consecutive nodes before and after such that before-&gt;data.value \\(&lt;\\) (0, v) \\(&lt;=\\) after-&gt;data.value. It does so by performing something called hand-over-hand locking. It first locks the first node, which is the \\((-1, None)\\) node. Then, iteratively, it obtains a lock on the next node and release the lock on the last one, and so on, similar to climbing a rope hand-over-hand. Using <code>_find</code>, the <code>insert</code>, <code>remove</code>, and <code>contains</code> methods are fairly straightforward to implement.</p>"},{"location":"textbook/finegrained/#exercises","title":"Exercises","text":"<p>12.1 Add methods to the data structure in Figure 12.3 that report the size of the list, the minimum value in the list, the maximum value in the list, and the sum of the values in the list. (All these should ignore the two end nodes.)</p> <p>12.2 Create a thread-safe sorted binary tree. Implement a module <code>bintree</code> with methods \\(\\mathtt{BinTree}()\\) to create a new binary tree, \\(\\mathtt{insert}(t, v)\\) that inserts v into tree t, and \\(\\mathtt{contains}(t, v)\\) that checks if v is in tree t. Use a single lock per binary tree.</p> <p>12.3 Create a binary tree that uses, instead of a single lock per tree, a lock for each node in the tree.</p>"},{"location":"textbook/grammar/","title":"Simplified Grammar","text":"<p>The next pages show a compact version of the complete Harmony grammar. The precedence rules are loosely as follows. Application binds most strongly. Next are unary operators.  Next are binary operators. Thus <code>-a[1] - a[2]</code> parses as <code>(-(a[1])) - (a[2])</code>. <code>!a[1]</code> parses as <code>!(a[1])</code>. Harmony will complain about ambiguities such as <code>a - b + c</code>. The grammar ignores indentation rules.</p> <pre><code>block: statement [[NEWLINE | ';'] statement]*;\n\nstatement\n    : e     # usually a function call\n    | e '=' [e '=']* e        # assignment\n    | e aug_assign e           # augmented assignment\n    | id: statement     # labeled statement\n    | assert e [',' e]\n    | atomically statement\n    | atomically ':' block\n    | await e\n    | const bv '=' e\n    | def bv [returns id]? ':' block\n    | del e [',' e]*\n    | finally e\n    | from id import id [ ',' id]*\n    | go e e\n    | if e ':' block [elif e ':' block]* [else ':' block]?\n    | import id [ ',' id]*\n    | invariant e\n    | pass\n    | print e\n    | sequential id\n    | spawn e e\n    | trap e e\n    | var bv '=' e\n    | while e ':' block\n    | letwhen ':' block      # let/when statement\n    | comprehension ':' block      # for statement\n    ;\n\ncomprehension: for_clause [for_clause | where_clause]*;\nletwhen: [let_clause | when_clause]+;\nfor_clause: for bv in e;\nwhere_clause: where e;\nlet_clause: let bv '=' e;\nwhen_clause: when e | when exists bv in e;\n\naug_assign\n    : '+=' | '-=' | '*=' | '**=' | '/=' | '//=' | '%=' | 'mod=' | '&gt;&gt;=' | '&lt;&lt;=\n    | 'and-' | 'or=' | '=&gt;=' | '&amp;=' | '|=' | '^='\n    ;\n&lt;{:end:}&gt;\n</code></pre> <pre><code>e   # expression\n    : False | True | None | '{:}'\n    | [0-9]+ | 0x[0-9a-fA-F]+ | 0b[0-1]+ | 0o[0-7]+ # integer\n    | \"...\" | '...' | \"\"\"...\"\"\" | ' ' '...' ' ' | '.' id # string forms\n    | id\n    | unary e\n    | e binary e\n    | e e                   # application\n    | '(' [e,]* e? ')'      # tuple/list\n    | '[' [e,]* e? ']'      # tuple/list\n    | '{' [e,]* e? '}'      # set\n    | '{' [e ':' e,]* [e ':' e] '}' # dictionary\n    | '{' e '..' e '}'      # range\n    | e comprehension       # list comprehension\n    | '{' e comprehension '}'       # set comprehension\n    | '{' e ':' e comprehension '}' # dict comprehension\n    | e if e else e\n    | lambda bv: e end\n    | atomically e\n    | save e\n    | stop id\n    ;\n\nunary\n    : '-' | '?' | '!' | '|' | '&amp;' | '^' | abs | any | all | choose\n    | countLabel | len | keys | max | min | not | str | type\n    ;\n\nbinary\n    : '+' | '-' | '*' | '/' | '//' | '%' | mod | '~' | '&lt;&lt;' | '&gt;&gt;'\n    | '==' | '!=' | '&lt;' | '&lt;=' | '&gt;' | '&gt;='\n    | not? in | not? and | not? or |  not? '=&gt;' \n    ;\n\nbv # bounded variable(s)\n    : id\n    | [bv ',']+ bv\n    | '(' bv ')'\n    | '[' bv ']'\n    ;\n\nid: [_a-zA-Z][_a-zA-Z0-9]*; # identifier\n</code></pre>"},{"location":"textbook/harmonyintro/","title":"Hello World!","text":"<p>The first programming book that I read cover to cover was The C Programming Language (first edition) by Brian W. Kernighan and Dennis M. Ritchie, which was around 1980. I did not know at the time that 10 years later Dennis, the designer of the C programming language, would be my boss at AT&amp;T Bell Labs in Murray Hill, NJ, while Brian would be my colleague in the same lab. The first C program in the book printed the string \"hello, world\". Since then, most programming tutorials for pretty much any programming language start with that example.</p> <p>Harmony, too, has a Hello World program. Figure 2.1 shows the program and the corresponding output. After installation  (see https://harmony.cs.cornell.edu), you can run it as  follows from the command line:</p> <pre><code>$ harmony -o hello1.png code/hello1.hny\n</code></pre> <p>For this to work, make sure <code>harmony</code> is in your command shell's search path. The code for examples in this book can be found in the <code>code</code> folder under the name listed in the caption of the example. If you need to, you can download the sources separately from https://harmony.cs.cornell.edu/sources.zip. In this case, the file <code>code/hello1.hny</code> contains the code in Figure 2.1. The <code>-o hello1.png</code> arguments tell harmony to write the output in the file <code>hello1.png</code>. The output is a Deterministic State Machine (DFA). The green circle represents the initial state and the double circle represents the final state. There is one transition, labeled with the string \"hello world\". The DFA describes (or recognizes) all possible outputs that the program can generate. In this case, there is only one.</p> <p></p> hello1.hny<pre><code>print \"hello world\"\n</code></pre> Figure 2.1 ( code/hello1.hny):  Hello World!  <p></p> hello3.hny<pre><code>print choose { \"hello\", \"world\" }\n</code></pre> Figure 2.2 ( code/hello3.hny):  Harmony program with two possible outputs <p></p> hello4.hny<pre><code>while choose { False, True }:\n    print \"hello world\"\n</code></pre> Figure 2.3 ( code/hello4.hny):  Harmony program with an infinite number of outputs  <p>But programs can usually have more than one execution and produce multiple different outputs as a result. This is usually as a result of different inputs, but Harmony programs do not have inputs. Instead, Figure 2.2 demonstrates nondetermistic choice in Harmony programs. In this case, the program chooses to print either \"hello\" or \"world\". The corresponding DFA captures both possibilities. You can think of the choose operator as enumerating all possible inputs to the program.</p> <p>Figure 2.3 shows a program that has an infinite number of outputs by using a loop. Harmony usually requires that any program must be able to terminate, so the loop is conditioned on a nondeterministic choice between <code>False</code> and <code>True</code>. The possible outputs consist of zero or more copies of the string \"hello world\". Note that this single state DFA (where the initial state and the final state happen to be the same) captures an infinite number of possible outputs.</p> Single Threaded Multi-threaded hello5.hny<pre><code>def p(s):\n    print s\n\np(\"hello\")\np(\"world\")\n</code></pre> hello6.hny<pre><code>def p(s):\n    print s\n\nspawn p(\"hello\")\nspawn p(\"world\")\n</code></pre> Figure 2.4 (Demonstrating Harmony methods and threads) <p>Figure 2.4 demonstrates methods and threads in Harmony. In Figure 2.4(a), the code simply prints the strings \"hello\" and \"world\", in that order. Notice that this leads to an intermediate state after \"hello\" is printed but before \"world\" is. However, there is still only one execution possible. Figure 2.4(b) shows two threads, one printing \"hello\" and one printing \"world\". Because the threads run concurrently, the program can either output \"hello world\" or \"world hello\". Printing in Harmony is atomic, so \"hweolrllod\" is not a possible output.</p> <p></p> hello7.hny<pre><code>def hello(name):\n    print \"hello\"\n    print name\n\nspawn hello(\"Lesley\")\nspawn hello(\"Robbert\")\n</code></pre> Figure 2.5  (code/hello7.hny):  Various interleavings of threads <p></p> hello8.hny<pre><code>def hello(name):\n    atomically:\n        print \"hello\"\n        print name\n\nspawn hello(\"Lesley\")\nspawn hello(\"Robbert\")\n</code></pre> Figure 2.6 (code/hello8.hny):  Making groups of operations atomic reduces interleaving  <p>Figure 2.5 shows two threads, one printing the strings \"hello\" and \"Robbert\", while the other prints \"hello\" and \"Lesley\". Now there are four possible outputs depending on how the two threads are interleaved, including \"hello hello Lesley Robbert\". This is probably not what the programmer wanted. Figure 2.6 shows another important feature of Harmony: atomic blocks. The program is similar to Figure 2.5, but the programmer specified that the two print statements in a thread should be executed as an atomic unit. As a result, there are only two thread interleavings possible.</p> <p>Harmony is a programming language that borrows much of Python's syntax. Like Python, Harmony is an imperative, dynamically typed, and garbage collected programming language. There are also some important differences:</p> <ul> <li> <p>Harmony only supports basic operator precedence or associativity.     Use parentheses liberally to remove ambiguity.</p> </li> <li> <p>Harmony does not support floating point;</p> </li> <li> <p>Python is object-oriented, supporting classes with methods and     inheritance; Harmony has objects but does not support classes. On     the other hand, Harmony supports pointers to objects and methods.</p> </li> </ul> <p>There are also less important differences that you will discover as you get more familiar with programming in Harmony.</p> triangle.hny<pre><code>const N = 10\n\ndef triangle(n) returns result:   # computes the n'th triangle number\n    result = 0\n    for i in {1..n}:     # for each integer from 1 to n inclusive\n        result += i      # add i to result\n\nx = choose {0..N}        # select an x between 0 and N inclusive\nassert triangle(x) == ((x * (x + 1)) / 2)\n</code></pre> Figure 2.7 (code/triangle.hny):  Computing triangle numbers  <p>Figure 2.7 shows another example of a Harmony program. The example is a sequential program and has a method <code>triangle</code> that takes an integer number as argument. Each method has a variable called result that eventually contains the result of the method (there is no return statement in Harmony). The method also has a bound variable called n containing the value of the argument. The { x..y } notation generates a set containing the numbers from\u00a0x to\u00a0y (inclusive). (Harmony does not have a <code>range</code> operator like Python.)  The last two lines in the program are the most interesting.  The first assigns to x some unspecified value in the range <code>0..N</code> and the second verifies that <code>triangle</code>(x) equals \\(x(x+1)/2\\).</p> <p>Running this Harmony program will try all possible executions, which includes all possible values for x. Try it out (here <code>$</code> represents a shell prompt):</p> <pre><code>$ harmony triangle.hny\n#states 13\n13 components, 0 bad states\nNo issues\n$\n</code></pre> <p>The assert statement checks that the output is correct. If the program is correct, Harmony reports the size of the \"state graph\" (13 states in this case). If not, Harmony also reports what went wrong, typically by displaying a summary of an execution in which something went wrong.</p> <p>In Harmony, constants have a default specified value, but those can be overridden on the command line using the <code>-c</code> option. For example, if you want to test the code for <code>N</code> = 100, run:</p> <pre><code>$ harmony -c N=100 triangle.hny\n#states 103\n103 components, 0 bad states\nNo issues\n$\n</code></pre>"},{"location":"textbook/harmonyintro/#exercises","title":"Exercises","text":"<p>2.1 Write a Harmony program that uses choose instead of spawn to create the same output DFA as Figure 2.4(b).</p> <p>2.2 Add the line print(x, <code>triangle</code>(x)) to the end of the program and create an output png file. Before you look at it, what do you think it should look like?</p> <p>2.3 See what happens if, instead of initializing result to 0, you initialize it to 1. (You do not need to understand the error report at this time. They will be explained in more detail in Chapter 4.)</p> <p>2.4 Write a Harmony program that computes squares by repeated adding. So, the program should compute the square of x by adding x to an initial value of 0 x times.</p>"},{"location":"textbook/harmonymachine/","title":"The Harmony Virtual Machine","text":"<p>The Harmony compiler, <code>harmony</code>, places the bytecode for file <code>x.hny</code> in file <code>x.hvm</code>. The model checker (called Charm) executes the code in <code>x.hvm</code> and places its output in a file called <code>x.hco</code>. From the <code>x.hco</code> file, <code>harmony</code> creates a detailed human-readable output file in <code>x.hvb</code> and an interactive HTML file called <code>x.htm</code>. The <code>x.htm</code> file is automatically opened in your default web browser unless you specify the <code>--noweb</code> flag to <code>harmony</code>.</p> <p>To understand the problem of concurrent computing, it is important to have a basic understanding of machine instructions, and in our case those of the HVM.</p>"},{"location":"textbook/harmonymachine/#harmony-values","title":"Harmony Values","text":"<p>Harmony programs, and indeed the HVM, manipulate Harmony values. Harmony values are recursively defined: they include booleans (<code>False</code> and <code>True</code>), integers (but not floating point numbers), strings (enclosed by single or double quotes), sets and lists of Harmony values, and dictionaries that map Harmony values to other Harmony values. Strings that start with a letter or an underscore and only contain letters, digits, and underscores can be written without quotes by preceding it with a dot. So, .example is the same string as <code>\"</code>example<code>\"</code>.</p> <p>A dictionary maps keys to values. Unlike Python, which requires that keys must be hashable, any Harmony value can be a key, including another dictionary. Dictionaries are written as \\(\\{ k_0: v_0, ~ k_1: v_1, ~ ... \\}\\). The empty dictionary is written as {:}. If d is a dictionary, and k is a key, then the following expression retrieves the Harmony value that k maps to in d: <pre><code>d k\n</code></pre> The meaning of d a b \\(...\\) is (((d a) b) \\(...\\)). This notation is unfamiliar to Python programmers, but in Harmony square brackets can be used in the same way as parentheses, so you can express the same thing in the form that is familiar to Python programmers: <pre><code>d[k]\n</code></pre> However, if d = { .count: 3 }, then you can write d.count (which has value 3) instead of having to write d[.count] or d[<code>\"</code>count<code>\"</code>] (although any of those will work). Thus a dictionary can be made to look much like a Python object.</p> <p>In Harmony (unlike Python), lists and tuples are the same type. As in Python, you can create a singleton tuple (or list) by including a comma.  For example, (1,) is a tuple consisting just of the number 1. Importantly, \\((1) = 1 \\ne (1,) = \\{ 0:1 \\}\\). Because square brackets and parentheses work the same in Harmony, [a, b, c] (which looks like a  Python list) is the same Harmony value as (a, b, c) (which looks like a Python tuple). So, if x = [<code>False</code>, <code>True</code>], then x[0] = <code>False</code> and x[1] = <code>True</code>, just like in Python. However, when creating a singleton list, make sure you include the comma, as in [<code>False</code>,]. The expression [<code>False</code>] just means <code>False</code>.</p> <p>Harmony is not an object-oriented language, so objects don't have built-in methods. However, Harmony does have some powerful operators to make up for some of that. For example, dictionaries have two handy unary operators. If d is a dictionary, then keys d (or equivalently keys(d)) returns the set of keys and len d returns the size of this set.</p> <p>Value Types and Operators provides details on all the types of values that Harmony currently supports.</p>"},{"location":"textbook/harmonymachine/#harmony-bytecode","title":"Harmony Bytecode","text":"<p>A Harmony program is translated into HVM bytecode. To make it amenable to efficient model checking, the HVM is not an ordinary virtual machine, but its architecture is nonetheless representative of conventional computers and virtual machines such as the Java Virtual Machine.</p> <p>Instead of bits and bytes, a HVM manipulates Harmony values. A HVM has the following components:</p> <ul> <li> <p>Code: This is an immutable and finite list of HVM instructions,     generated from a Harmony program. The types of instructions will be     described later.</p> </li> <li> <p>Shared memory: A HVM has just one memory location containing a     Harmony value.</p> </li> <li> <p>Threads: Any thread can spawn an unbounded number of other threads     and threads may terminate. Each thread has a program counter that     indexes into the code, a stack of Harmony values, and a private     register that contains a Harmony value.[^2]</p> </li> </ul> <p>The register of a thread contains the local variables of the method that the thread is currently executing. It is saved and restored by method invocations. The state of a thread is called a context (aka continuation): it contains the values of its program counter, stack, and registers. The HVM state consists of the value of its memory and the multiset (or bag) of contexts. It is a multiset of contexts because two threads can have the same context at the same time.</p> <pre><code>   0 Frame __init__ ()\ncode/Up.hny:1 count = 0\n   1 Push 0\n   2 Store count\ncode/Up.hny:2 done = [ False, False ]\n   3 Push [False, False]\n   4 Store done\ncode/Up.hny:4 def incrementer(self):\n   5 Jump 35\n   6 Frame incrementer self\ncode/Up.hny:5     count = count + 1\n   7 Load count\n   8 Push 1\n   9 2-ary +\n   10 Store count\n</code></pre> Figure 4.1: The first part of the HVM bytecode corresponding to Figure 3.2 <p>It may seem strange that there is only one memory location. However, this is not a limitation because Harmony values are unbounded trees. The shared memory is a dictionary that maps strings (names of shared variables) to other Harmony values. We call this a directory. Thus, a directory represents the state of a collection of variables named by the strings. Because directories are Harmony values themselves and Harmony values include dictionaries and lists that themselves contain other Harmony values, directories can be organized into a tree. Each node in a directory tree is then identified by a sequence of Harmony values, like a path name in the file system hierarchy. We call such a sequence an address. For example, in Figure 3.2 the memory is a dictionary with two entries: count and done. And the value of entry done is a list with indexes 0 and 1. So, for example, the address of done[0] is the sequence [done, 0]. An address is itself a Harmony value.</p> <p>Compiling the code in Figure 3.2 results in the HVM bytecode listed in Figure 4.1. You can obtain this code by invoking <code>harmony</code> with the <code>-a</code> flag like so:</p> <pre><code>harmony -a Up.hny\n</code></pre> <p>Each thread in the HVM is predominantly a stack machine, but it also a register. Like shared memory, the register contains a dictionary so it can represent the values of multiple named variables. All instructions are atomically executed. The Harmony memory model is sequentially consistent: all accesses are in program order. Most instructions pop values from the stack or push values onto the stack. At first there is one thread, named <code>__init__</code>, which initializes the state. It starts executing at instruction 0 and keeps executing until it reaches the last instruction in the program. In this case, it executes instructions 0 through 5 first. The last instruction in that sequence is a <code>JUMP</code> instruction that sets the program counter to 35 (skipping over the code for <code>incrementer</code> method). The <code>__init__</code> thread then executes the remaining instructions and finishes. Once initialization completes, any threads that were spawned (in this case <code>incrementer</code>(0) and <code>incrementer(1)</code>) can run.</p> <pre><code>Phase 1: compile Harmony program to bytecode\nPhase 2: run the model checker\nnworkers = 8\n#states 44\nPhase 3: analysis\nPhase 4: write results to code/Up.hco\nSafety Violation\nPhase 5: loading code/Up.hco\nT0: __init__()     [0-5,35-43]   { count: 0, done: [ False, False ] }\nT2: incrementer(1) [6-9]         { count: 0, done: [ False, False ] }\nT1: incrementer(0) [6-20]        { count: 1, done: [ True,  False ] }\nT2: incrementer(1) [10-24,26-31] { count: 1, done: [ True,  True  ] }\nHarmony assertion failed\nopen file:code/Up.htm for more information\n</code></pre> Figure 4.2: The text output of running Harmony on Figure 3.2 <p>At program counter 6 is the code for the <code>incrementer</code> method. All methods start with a <code>Frame</code> instruction and end with a <code>Return</code> instruction. provides a list of all HVM machine instructions, in case you want to read about the details. The <code>Frame</code> instruction lists the name of the method and the names of its arguments. The code generated from \\(\\mathit{count} := \\mathit{count} + 1\\) in line\u00a05 of <code>Up.hny</code> is as follows (see Figure 4.1):</p> <ol> <li> <p>The <code>Load</code> instruction pushes the value of the count variable onto     the stack.</p> </li> <li> <p>The <code>Push</code> instruction pushes the constant 1 onto the stack of the     thread.</p> </li> <li> <p><code>2-ary</code> is a <code>+</code> operation with 2 arguments. It pops two values from     the stack (the value of count and 1), adds them, and pushes the     result back onto the stack.</p> </li> <li> <p>The <code>Store</code> instruction pops a Harmony value (the sum of the count     variable and 1) and stores it in the count variable.</p> </li> </ol> <p>You can think of Harmony as trying every possible interleaving of threads executing instructions. Figure 4.2 shows the output produced by running Harmony on the <code>Up.hny</code> program.</p> <p>Harmony can report the following failure types:</p> <ul> <li> <p><code>Safety violation</code>: This means something went wrong with at least     one of the executions of the program that it tried. This can include     a failing assertion, behavior violations, divide by zero, using an     uninitialized or non-existent variable, dividing a set by an     integer, and so on. Harmony will print a trace of the shortest bad     execution that it found.</p> </li> <li> <p><code>Non-terminating State</code>: Harmony found one or more states from which     there does not exist an execution such that all threads terminate.     Harmony will not only print the non-terminating state with the     shortest trace, but also the list of threads at that state, along     with their program counters.</p> </li> <li> <p><code>Behavior Violation</code>: The program can terminate in a state not     allowed by the behavioral specification (Chapter 13).</p> </li> <li> <p><code>Active Busy Waiting</code>: There are states in which some thread cannot     make progress without the help of another thread, but does not block     (Chapter 15).</p> </li> <li> <p><code>Data Race</code>: There are states in which two or more threads     concurrently access a shared variable, at least one of which is a     store operation (Chapter 10).</p> </li> </ul> <p>Harmony checks for these types of failure conditions in the given order: if there are multiple failure conditions, only the first is reported. Active busy waiting (Chapter 15) is not technically an indication of a synchronization problem, but instead an indication of an inefficient solution to a synchronization problem--- one that uses up CPU cycles unnecessarily. A data race may not be a bug either---whether or not it is might depend on the semantics of the underlying memory operations and are therefore generally undesirable. Harmony may also warn about behaviors, in particular if the generated behavior is only a subset of the provided behavior.</p> <p>Going back to our example, Harmony reports a safety violation. In particular, it reports that an assertion failed. The program got to the failed assertion in four \"turns.\" The output has four columns:</p> <ol> <li> <p>A thread identifier;</p> </li> <li> <p>The main method and argument of the thread;</p> </li> <li> <p>The sequence of program counters of the HVM instructions that the     thread executed;</p> </li> <li> <p>The contents of the shared memory.</p> </li> </ol> <p>The four turns in the execution are as follows:</p> <ol> <li> <p>Thread <code>__init__</code> (with identifier T0) executes instructions 0     through 5 and 35 through 43, setting shared variable count to 0     and shared variable done to [<code>False</code>, <code>False</code>].</p> </li> <li> <p>Thread <code>incrementer(1)</code> (with identifier T1) executes instructions 6     through 20, storing 1 into count and storing <code>True</code> into     done[1];</p> </li> <li> <p>Thread <code>incrementer(0)</code> (with identifier T2) executes instructions 6     through 9, loading the value of count but stopping just before      storing 1 into count;</p> </li> <li> <p>Thread <code>incrementer</code>(0) (T2) continues execution, executing     instructions 10 through 24 storing value 1 into count (instruction     10), storing <code>True</code> into done[0], finding that done[1] is     <code>True</code>, and finally detecting that the assertion is violated.</p> </li> </ol> <p></p> <p>Harmony also generates a detailed and self-explanatory text output file (see <code>code/Up.hvb</code>) and an interactive HTML file that allows exploring more details of the execution. Open the suggested HTML file and you should see something like Figure 4.3.</p> <p>In the top right, the HTML file contains the reported issue in red. Underneath it, a table shows the four turns in the execution. Instead of listing explicitly the program counters of the executed instructions, the HTML file contains a list of blocks for each executed instruction. We call this the timeline. You can click on such a block to see the state of the Harmony virtual machine just after executing the corresponding instruction. If a thread has finished its turn, there is also information on the status of that thread. For example, at the end of turn~2, <code>incrementer[0]</code> is about to store the value 1 in variable <code>count</code>, but at that point is preempted by <code>incrementer[1]</code>. The table also lists the program counter of the thread at each turn,  the values of the shared variables, and any values the thread may have printed (none in this case). Underneath the table it shows the line of Harmony source code that is being executed in blue (with the specific part of the line that is being evaluated in green), and the HVM instruction that is about to be executed in green (along with an explanation in parentheses).</p> <p>The bottom left shows the bytecode of the program being executed. It has alternating grey and white sections. Each section corresponds to a line of Harmony code. The instruction that is about to be executed, if any, is highlighted in red. (In this case, the state shown is a failed state and no instruction will be executed next.) If you hover the mouse over a machine instruction, it provides a brief explanation of what the instruction does.</p> <p>The bottom right contains a table with the state of each thread. Status information for a thread can include:</p> <ul> <li> <p><code>runnable</code>: the thread is runnable but not currently running. In     Harmony, threads are interleaved and so at most one thread is     actually running;</p> </li> <li> <p><code>running</code>: the thread is currently executing instructions;</p> </li> <li> <p><code>terminated</code>: the thread has completed all its instructions;</p> </li> <li> <p><code>failed</code>: the thread has encountered an error, such as violating an     assertion or divide by zero;</p> </li> <li> <p><code>blocked</code>: the thread cannot make progress until another thread has     updated the shared state. For example, this occurs when one of the     implementers is waiting for the other to set its done flag;</p> </li> <li> <p><code>atomic</code>: the thread is in atomic mode, not allowing other threads     to be scheduled. This is, for example, the case when an assertion is     being checked;</p> </li> <li> <p><code>read-only</code>: the thread is in read-only mode, not able to modify     shared state. Assertions can execute arbitrary code including     methods, but they are not allowed to modify the shared state.</p> </li> </ul> <p>The stack of each thread is subdivided into two parts: the stack trace and the stack top. A stack trace is a list of methods that are being invoked. In this case, the <code>incrementer</code> method does not invoke any other methods, and so the list is of length 1. For each entry in the stack trace, it shows the method name and arguments, as well as the variables of the method. The stack top shows the values on the stack beyond the stack trace.</p> <p>When you load the HTML file, it shows the state after executing the last instruction. As mentioned above, you can go to any point in the execution by clicking on one of the blocks in the timeline. When you do so, the current turn and thread will be highlighted in green. There are also various handy keyboard shortcuts:</p> <pre><code>       *Right arrow*: go to the next instruction;\n        *Left arrow*: go to the previous instruction;\n        *Down arrow*: go to the next turn;\n          *Up arrow*: go to the previous turn;\n*Enter (aka Return)*: go to the next line of Harmony code;\n                 *0*: go to the initial state.\n</code></pre> <p>If you want to see an animation of the entire execution, one instruction at a time, you can first hit 0 and then hold down the right arrow. If you want to see it one line of Harmony code at a time, hold down the enter (aka return) key instead. If you hold down the down arrow key, the movie will go by very quickly.</p>"},{"location":"textbook/harmonymachine/#exercises","title":"Exercises","text":"<p>4.1 Figure 4.4 shows an attempt at trying to fix the code of Figure 3.2. Run it through Harmony and see what happens. Based on the error output, describe in English what is wrong with the code by describing, in broad steps, how running the program can get into a bad state.</p> <p>4.2 What if we moved line\u00a05 of Figure 4.4 to after the if statement (between lines\u00a07 and\u00a08)? Do you think that would work? Run it through Harmony and describe either why it works or why it does not work.</p> UpEnter.hny<pre><code>count = 0\nentered = done = [ False, False ]\n\ndef incrementer(self):\n    entered[self] = True\n    if entered[1 - self]:        # if the other thread has already started\n        await done[1 - self]     # wait until it is done\n    count = count + 1\n    done[self] = True\n    await done[1 - self]\n    assert count == 2\n\nspawn incrementer(0)\nspawn incrementer(1)\n</code></pre> Figure 4.4 (code/UpEnter.hny): Incorrect attempt at fixing the code of Figure 3.2"},{"location":"textbook/howitworks/","title":"How Harmony Works","text":"<p>This appendix gives a very brief overview of how Harmony works. In a nutshell, Harmony goes through the following three phases:</p> <ol> <li> <p>The Harmony compiler turns your Harmony program into bytecode. A     recursive descent parser and code generator written in Python (see     <code>harmony.py</code>) turns an <code>x.hny</code> program into <code>x.hvm</code>, a JSON file     containing the corresponding bytecode.</p> </li> <li> <p>The Harmony model checker evaluates the state space that the     program (now in bytecode) can generate. The model checker is written     in C as it needs to be highly efficient (see <code>charm.c</code>). The model     checker starts from the initial state, and then, iteratively, checks     for each state that it has found what next steps are possible and     generates the next states using the Harmony virtual machine (). If     the model is finite, eventually the model checker will generate a     graph with all possible states. If there is a problematic path in     this graph (see below), then it will report the shortest such path     in the <code>x.hco</code> output file in JSON format.</p> </li> <li> <p>The <code>x.hco</code> output file is translated twice by <code>harmony.py</code>. There     is a so-called brief output that is written to standard output.     The rest depends on whether there was a problem with the execution     or not. If there was a problem, the more comprehensive output is     placed in the <code>x.htm</code> HTML output file, allowing you to navigate the     problematic path and all the details of each of the states on the     path. If not, a DFA of the print behavior is generated and compared     with a provided DFA if specified with the <code>-B</code> flag.</p> </li> </ol>"},{"location":"textbook/howitworks/#compiler","title":"Compiler","text":"<p>The Harmony compiler, in order to stay true to the Harmony source program, does not do much in the way of optimizations. The main optimizations that it does are:</p> <ul> <li> <p>Constant folding: (simple) expressions consisting only of constants     are evaluated by the compiler rather than by the model checker;</p> </li> <li> <p>Jump threading: Harmony eliminates jump to jump instructions;</p> </li> <li> <p>Dead variable elimination: Harmony removes method variables that are     no longer in use from the state in order to reduce the state space     to be explored.</p> </li> </ul>"},{"location":"textbook/howitworks/#model-checker","title":"Model Checker","text":"<p>The Harmony model checker, called Charm, takes the output from the compiler and explores the entire state space in breadth-first order. Even though Harmony does not really support input, there are three sources of non-determinism that make this exploration non-trivial:</p> <ul> <li> <p>choose expressions: Harmony's ability to let the program     choose a value from a set;</p> </li> <li> <p>thread interleaving: different threads run pseudo-concurrently     with their instructions interleaved in arbitrary ways;</p> </li> <li> <p>interrupts: Harmony programs can set interrupts that can go off at     arbitrary times.</p> </li> </ul> <p>A thread can be in atomic mode or not. In atomic mode, the execution of the thread is not interleaved with other threads. A thread can also be in read-only mode or not. In read-only mode, the thread cannot write or deleted shared variables.</p> <p>Charm has some tricks to significantly reduce the state space to explore.</p> <ul> <li> <p>A thread can have local state (program counter, stack, method     variables, and thread-local state variables). That state is called     the context of the thread. The context of a thread cannot be     accessed by other threads, nor by invariant or finally      statements. So, the model checker only interleaves threads at     Load, Store, and Del instructions where a thread     interacts with global variables.</p> </li> <li> <p>Threads are anonymous, and therefore two or more threads can have     the same context. The state of the model checker therefore maintains     a bag (multiset) of contexts rather are than a set of contexts.     Thus even if there are hundreds of threads, there may be only tens     of possible context states.</p> </li> </ul> <p>That said, state space explosion is still a possibility, and Harmony programmers should keep this in mind when writing and testing their programs. Do not be too ambitious: start with small tests and gradually build them up as necessary.</p> <p>The model checker stops either when it finds a failing execution or when it has explored the entire state space, whichever comes first. An execution can fail for a variety of reasons:</p> <ul> <li> <p>An invariant failing: Harmony evaluates all invariants in all states     that if finds---if one fails, Harmony stops further exploration;</p> </li> <li> <p>An assertion failing;</p> </li> <li> <p>A behavior violation: this is when the sequence of printed values     are not recognized by the provided DFA (using the <code>-B</code> flag);</p> </li> <li> <p>A silly error: this includes reading variables that have not been     assigned, trying to add a set to an integer, taking the length of     something that is not a set of a dictionary, and so on;</p> </li> <li> <p>An infinite loop: a thread goes into an infinite loop without     accessing shared variables.</p> </li> </ul>"},{"location":"textbook/howitworks/#model-checker-output-analysis","title":"Model Checker Output Analysis","text":"<p>The output of the model checker is a graph (a so-called Kripke structure) that is typically very large. If some execution failed, then Harmony will simply report the path of that failing execution. But otherwise there may be the following outcomes:</p> <ul> <li> <p>No issues: no failing executions and each program can terminate;</p> </li> <li> <p>Non-terminating states: some executions lead to some form of     deadlock or other issue that causes some (non-eternal) threads not     to be able to terminate;</p> </li> <li> <p>Race conditions: there are executions in which two threads access     the same shared state variable, with at least one of those accesses     being a Store operation;</p> </li> <li> <p>Busy waiting: executions in which threads are actively waiting for     some condition, usually by releasing and reacquiring locks.</p> </li> </ul> <p>In order to diagnose these outcomes, Harmony must analyze the graph.</p> <p>The first thing that Harmony does is to locate non-terminating states, if any. To do this, Harmony first determines the strongly connected components of the graph using Kosaraju's algorithm. A component (subgraph) of a graph is strongly connected if each vertex (state) in the component can be reached from each other vertex. The components then form a Directed Acyclic Graph (DAG). The DAG is easier to analyze than the original graph. One can easily determine the sink components (the components with no outgoing edges). If such a component has non-eternal threads in it, then each state in that component is a non-terminating state.</p> <p>To find race conditions, the model checker looks in the graph for states in which there are multiple threads that can make a step. If there is a step in which multiple threads access the same shared variable, at least one of those accesses is a store operation, and at least one of those threads is not in atomic mode, then Harmony reports the shortest path to such a state.</p> <p>To show how Harmony detects busy waiting, we will first show how Harmony determines if a thread is blocked or not. A thread is considered blocked if it cannot terminate without the help of another thread. For example, a thread waiting for a lock is blocked and cannot terminate until another thread releases the lock. Determining whether a thread is blocked in a particular state can be done within the confines of the connected component: the analyzer tries all possible executions of the thread. If it cannot \"escape\" the connected component by doing so, it is considered blocked. A thread is considered busy waiting if it is blocked, but it is also changing the shared state while doing so. A thread that is waiting on a spinlock only observes the state.</p> <p>In the output, each thread has a unique identifier: <code>T0</code> is the initialization thread; <code>T</code>\\(n\\) is the \\(n^{th}\\) spawned thread that executes. This seems to contradict the fact that Harmony threads are anonymous. The output analyzer assigns these identifiers a posteriori to the threads in the state graph by keeping track, along the reported execution path, what state each thread is in. So, by examining the initial context of the thread that is running from some particular state, it can determine if that context corresponds to the current context of some thread that ran previously or if the context belongs to a new thread that has not run before.</p> <p>If there are no issues, Harmony also generates a DFA of the print behavior. Starting with the original state graph or Kripke structure, the edges are inspected. If there are multiple print operations on an edge, additional states are inserted so that there are either 0 or 1 print operations on an edge. This graph of nodes (states) and edges (transitions) forms a Non-deterministic Finite Automaton (NFA) with \\(\\epsilon\\)-transitions (transitions without print operations). Harmony turns the NFA into a DFA and by default also minimizes the DFA (although not strictly necxessary). The DFA can be fed into another run of the model checker to check that its print operations are consistent with the provided DFA.</p>"},{"location":"textbook/hvm/","title":"The Harmony Virtual Machine","text":"<p>The Harmony Virtual Machine (HVM, Chapter 4) has the following state:</p> <p>code        a list of HVM machine instructions   variables   a dictionary mapping strings to values   ctxbag      a bag of runnable contexts   stopbag     a bag of stopped contexts   choosing    if not <code>None</code>, indicates a context that is choosing</p> <p>There is initially a single context with name <code>__init__</code>() and program counter 0. It starts executing in atomic mode until it finishes executing the last <code>Return</code> instruction. Other threads, created through spawn statements, do not start executing until then.</p> <p>A step is the execution of a single HVM machine instruction by a context. Each step generates a new state. When there are multiple contexts, the HVM can interleave them. However, trying to interleave every step would be needlessly expensive, as many steps involve changes to a context that are invisible to other contexts.</p> <p>A stride can involve multiple steps. The following instructions start a new stride: <code>Load</code>, <code>Store</code>, <code>AtomicInc</code>, and <code>Continue</code>. The HVM interleaves stides, not steps. Like steps, each stride involves a single context. Unlike a step, a stride can leave the state unchanged (because its steps lead back to where the stride started).</p> <p>Executing a Harmony program results in a graph where the nodes are Harmony states and the edges are strides. When a state is <code>choosing</code>, the edges from that state are by a single context, one for each choice. If not, the edges from the state are one per context.</p> <p>Consecutive strides by the same thread are called a turn. Each state maintains the shortest path to it from the initial state in terms of turns. The diameter of the graph is the length of the longest path found in terms of turns.</p> <p>If some states have a problem, the state with the shortest path is reported. Problematic states include states that experienced exceptions. If there are no exceptions, Harmony computes the strongly connected components (SCCs) of the graph (the number of such components are printed as part of the output). The sink SCCs should each consist of a terminal state without any threads. If not, again the state with the shortest path is reported.</p> <p>If there are no problematic states, Harmony reports \"no issues found\" and outputs in the HTML file the state with the longest path.</p>"},{"location":"textbook/hvm/#machine-instructions","title":"Machine Instructions","text":"Apply m call method m Assert, Assert2 pop b and check that it is <code>True</code>. Assert2 also pops value to print AtomicInc/Dec increment/decrement the atomic counter of this context Continue no-op (but causes a context switch) Choose choose an element from the set on top of the stack Cut retrieve an element from a iterable type Del [v] delete shared variable v DelVar [v] delete thread variable v Dup duplicate the top element of the stack Finally pc pc is the pc of a lambda that returns a boolean Frame m a start method m with arguments a, initializing variables. Go pop context and value, push value on context's stack, and add to context bag Invariant pc pc is the pc of a lambda that takes arguments <code>pre, post</code> and returns a boolean Jump p set program counter to p JumpCond e p pop expression and, if equal to e, set program counter to p Load [v] evaluate the address on the stack (or load shared variable v) LoadVar v push the value of a thread variable onto the stack Move i move stack element at offset i to top of the stack \\(n\\)-ary op apply \\(n\\)-ary operator op to the top \\(n\\) elements on the stack Pop pop a value of the stack and discard it Print pop a value and add to the print history Push c push constant c onto the stack ReadonlyInc/Dec increment/decrement the read-only counter of this context Return [v [, d]] pop return address, push v (or default value d), and restore pc Sequential pop an address of a variable that has sequential consistency SetIntLevel pop e, set interrupt level to e, and push old interrupt level Spawn [eternal] pop initial thread-local state, argument, and method and spawn a new context Split pop tuple and push its elements Stop [v] save context into shared variable v and remove from context bag Store [v] pop a value from the stack and store it in a shared variable StoreVar [v] pop a value from the stack and store it in a thread variable Trap pop interrupt argument and method <p>Clarifications:</p> <ul> <li> <p>Even though Harmony code does not allow taking addresses of thread     variables, both shared and thread variables can have addresses.</p> </li> <li> <p>The <code>Load</code>, <code>Del</code>, <code>DelVar</code>, and <code>Stop</code> instructions have     an optional variable name: if omitted the top of the stack must     contain the address of the variable.</p> </li> <li> <p>The <code>Store</code> instruction has an optional variable name. The <code>StoreVar</code>     instruction can even have a nested tuple of variable names such as <code>(a, (b, c))</code>.     In both cases the value to be assigned is on the top of the stack.     If the name is omitted, the address is underneath that value on the     stack.</p> </li> <li> <p>The <code>Frame</code> instruction pushes the value of the thread register     (i.e., the values of the thread variables) onto the stack. It     initializes the <code>result</code> variable to <code>None</code>. The <code>Return</code>     instruction restores the thread register by popping its value of the     It initializes the <code>result</code> variable to <code>None</code>. stack.</p> </li> <li> <p>All method calls have exactly one argument, although it sometimes     appears otherwise:</p> <ul> <li> <p>m() invokes method m with the empty dictionary () as     argument;</p> </li> <li> <p>m(a) invokes method m with argument a;</p> </li> <li> <p>m(a, b, c) invokes method m with tuple (a, b, c)     as argument.</p> </li> </ul> <p>The <code>Frame</code> instruction unpacks the argument to the method and places them into thread variables by the given names.</p> </li> <li> <p>The <code>Apply</code> instruction is unnecessary as it can be implemented using     2-ary Closure and <code>Load</code>. However, method calls are frequent enough to     warrant a faster mechanism, reducing model checking time.</p> </li> <li> <p>The <code>Return</code> instruction has an optional result variable and default     value.  If neither is specified, the result value is on top of the stack.     Otherwise it tries to read the local variable.  If the variable does not     exist, the default value is used or an error is thrown.</p> </li> <li> <p>Every <code>Stop</code> instruction must immediately be followed by a     <code>Continue</code> instruction.</p> </li> <li> <p>There are two versions of <code>AtomicInc</code>: lazy or eager. When     eager, an atomic section immediately causes a switch point (switch     between threads). When lazy, the state change does not happen until     the first <code>Load</code>, <code>Store</code>, or <code>Print</code> instruction. If there are no     such instructions, the atomic section may not even cause a switch     point.</p> </li> </ul> <p>The \\(n\\)-Ary instruction can have many different operators as argument. Values describes many of these operators, but some are used internally only. The current set of such operators are as follows:</p> Operator Description AddArg pop an argument and an address and push an address with the argument added Closure pop an argument and a function and push an address with the single argument DictAdd pop a value, a key, and a dictionary, and push an updated dictionary ListAdd pop a value and a list, and push a new list with the given value added to the end SetAdd pop a value and a set, and push a new set with the given value added"},{"location":"textbook/hvm/#addresses-and-method-calls","title":"Addresses and Method Calls","text":"<p>Syntactically, Harmony does not make a distinction between methods calls and indexing in Harmony dictionaries, lists, and strings.  This is because Harmony makes all four look like functions that map a value to another value. Beuses dynamic types, an expression like <code>a b</code> could mean that variable <code>a</code> contains a program counter value and a method call must be made with <code>b</code> as argument, or index <code>b</code> must be looked up in the <code>a</code> value. Things can get more complicated for an expression like <code>a b c</code>, which means <code>((a b) c)</code>: <code>a b</code> could return a program counter value or an indexable Harmony value.</p> <p>To deal with this, Harmony has a fairly unique address type.  An address consists of a function and a list of arguments, which we will denote here as \\(\\langle f, [ a_0, a_1, ... ] \\langle\\).  If <code>a</code> is a shared variable, then the address of <code>a b c</code> is \\(\\langle \\$, [\\) \"`a`\", \\(b, c~]\\rangle\\), where $ is the function that maps the names of shared variables to their values. In particular, $(\"`a`\") is the value of variable <code>a</code>.  A function can also be a program counter value or an indexable Harmony value.  So, if <code>a</code> is instead a method (i.e., a program counter constant), then the address would by \\(\\langle a, [b, c]\\rangle\\).  In the Harmony Virtual Machine, the $ function is represented as the program counter value \\(-1\\).</p> <p>To evaluate the Harmony expression <code>a b c</code>, Harmony first generates its address (evaluating the expression left to right).  If <code>a</code> is a variable name, then the function in the address depends on whether it is a shared variable or a thread variable.  After the address is computed and pushed onto the stack, the <code>Load</code> instruction evaluates the address, possibly in multiple steps in an iterative manner.</p> <p>A basic step of evaluating \\(\\langle \\mathit{function}, \\mathit{arguments} \\rangle\\) proceeds as follows:</p> <ul> <li> <p>If arguments is empty, replace the address by function       and proceed to the next instruction.</p> </li> <li> <p>If function is an indexable Harmony value (list, string, or dictionary), arg is the first argument, and remainder are the remaining arguments, then replace the address by \\(\\langle \\mathit{function}[\\mathit{arg}], \\mathit{remainder} \\rangle\\) and repeat.</p> </li> <li> <p>If function is $, then replace the address by \\(\\langle \\$[\\mathit{arg}], \\mathit{remainder} \\rangle\\) and repeat.</p> </li> <li> <p>If function is a program counter value, then push remainder, the current program counter (still pointing to the <code>Load</code> instruction), and arg onto the stack and set the program counter to function. The <code>Return</code> instruction pushes \\(\\langle r, \\mathit{remainder} \\rangle\\), where \\(r\\) is the result of the function, and restores the program counter so it executes the <code>Load</code> instruction again.</p> </li> </ul> <p>The Harmony Virtual Machine can sometimes to multiple of these basic steps in one big step.  For example, if <code>a b c</code> is a memory address, the <code>Load</code> instruction will finish in a single atomic step.  Both <code>Load</code> and <code>Return</code> are optimized in such ways.</p>"},{"location":"textbook/hvm/#contexts-and-threads","title":"Contexts and Threads","text":"<p>A context captures the state of a thread. Each time the thread executes an instruction, it goes from one context to another. All instructions update the program counter (<code>Jump</code> instructions are not allowed to jump to their own locations), and so no instruction leaves the context the same. There may be multiple threads with the same state at the same time. A context consists of the following:</p> <p>program counter          an integer value pointing into the code   atomic                   if non-zero, the thread is in atomic mode   readonly                 if non-zero, the thread is in read-only mode   stack                    a list of Harmony values   method variables         a dictionary mapping strings (names of method variables) to values   thread-local variables   a dictionary mapping strings (names of thread-local variables) to values   stopped                  a boolean indicating if the context is stopped   failure                  if not None, string that describes how the thread failed</p> <p>Details:</p> <ul> <li> <p>A thread terminates when it reaches the <code>Return</code> instruction of the     top-level method (when the stack frame is of type <code>thread</code>) or when     it hits an exception. Exceptions include divide by zero, reading a     non-existent key in a dictionary, accessing a non-existent variable,     as well as when an assertion fails;</p> </li> <li> <p>The execution of a thread in atomic mode does not get interleaved     with that of other threads.</p> </li> <li> <p>The execution of a thread in read-only mode is not allowed to     update shared variables of spawn threads.</p> </li> <li> <p>The register of a thread always contains a dictionary, mapping     strings to arbitrary values. The strings correspond to the variable     names in a Harmony program.</p> </li> </ul>"},{"location":"textbook/hvm/#formal-specification","title":"Formal Specification","text":"<p>Most of the Harmony Virtual Machine is specified in TLA+. Given a Harmony program, you can output the TLA+ specification for the program using the following command:</p> <pre><code>$ harmony -o program.tla program.hny\n</code></pre> <p>For most Harmony programs, including Peterson's algorithm and the Dining Philosophers in this book, the result is complete enough to run through the TLC model checker.</p>"},{"location":"textbook/install/","title":"Installing and Running Harmony","text":"<p>Harmony requires the following to be installed:</p> <ol> <li>Python (version 3.6 or higher)</li> <li>Graphviz</li> <li>C Compiler (potentially potential)</li> </ol> <p>In the following instructions, Windows users using WSL should follows instructions for Linux.</p> <p>For users of a Cornell CS Department Linux machine, e.g. <code>&lt;netid&gt;@ugclinux.cs.cornell.edu</code>, you likely do not need to install <code>Python3</code> or <code>Graphviz</code> because they may be available already. However, you can verify that they are available by running <code>python3 --version</code> and <code>dot -V</code> respectively.</p>"},{"location":"textbook/install/#installing-python3","title":"Installing Python3","text":"<p>Harmony requires Python (version 3.6 or higher) to be installed. If you do not have Python3 already installed, download and install Python depending on your OS (Windows, Mac, Linux, etc) on the official Python site. Be sure to download the installer for Python version <code>3.6</code> or higher.</p> <p>In the installer, the default installation settings will also add <code>pip</code>. If you choose to run the installer with custom settings, be sure that <code>pip</code> gets installed.</p> <p>On the command line, you can check if Python has been successfully installed by running the following:</p> <pre><code>python3 --version\n</code></pre>"},{"location":"textbook/install/#installing-graphviz","title":"Installing Graphviz","text":"<p>Harmony uses Graphviz to visualize the state changes in a program. For example, the following Harmony program can produce the subsequent graph.</p> <pre><code># Filename: example.hny\ndef a():\n    print \"A\"\n\ndef b():\n    print \"B\"\n\nspawn a()\nspwan b()\n\n# Run with [harmony -o example.png example.hny]\n</code></pre> <p></p> <p>Instructions for installing the latest version of Graphviz can be found here.</p> <p>For Windows users, when running the installer, make sure to select the option Add Graphviz to the system PATH for current user so that the command <code>dot</code> is available to produce the graphs.</p>"},{"location":"textbook/install/#install-harmony-via-pip","title":"Install Harmony via Pip","text":"<p>After installing <code>python</code>, you should also be able to use the command <code>pip</code>. Run the following command to get the latest version of Harmony:</p> <pre><code>pip install harmony\n</code></pre>"},{"location":"textbook/install/#for-windows-users","title":"For Windows Users","text":"<p>For Windows users: you may encounter the error message along the lines of the following when installing <code>harmony-model-checker</code>:</p> <pre><code>error: Microsoft Visual C++ 14.0 or greater is required. Get it with\n\"Microsoft C++ Build Tools\": &lt;link to visual studio - cpp build tools&gt;\n</code></pre> <p>This is to be expected if you had not installed the \"Microsoft C++ Build Tools\" before. Navigate to the outputted link and press <code>Download Build Tools</code> to download the installer. When you run the installer, you will encounter a selection screen such as the following:</p> <p></p> <p>Select <code>Desktop development with C++</code> in the <code>Desktop &amp; Mobile</code> section and then install.</p> <p></p> <p>Note that this will likely take a while. When it finishes installing, run <code>pip install harmony</code> again.</p>"},{"location":"textbook/install/#for-cs-deparment-linux-machine-users","title":"For CS Deparment Linux Machine Users","text":"<p>It may be possible that <code>pip</code> is not available on your Linux machine. In that case, you will need to download and build the source code directly. This can be done via the following commands:</p> <pre><code># Installs version 1.2.2376\nwget https://files.pythonhosted.org/packages/2c/cb/0a1d4dedf7f4dc552da831b28bde842c74bed251d75dd58d9f56fc688b04/harmony_model_checker-1.2.2376.tar.gz\ngzip -d harmony_model_checker-1.2.2376.tar.gz\ntar -xf harmony_model_checker-1.2.2376.tar\ncd harmony_model_checker-1.2.2376\npython3 setup.py install --user\n</code></pre> <p>Afterward, you will likely need to add the directory with the <code>harmony</code> command to your environment <code>PATH</code>. You can get the directory with the script by running <code>python3 -m site --user-base</code>, which will output something like <code>/home/&lt;net-id&gt;/.local</code>. Add this directory to your <code>PATH</code> (See here for more information on how to do so).</p>"},{"location":"textbook/install/#adding-scripts-to-path","title":"Adding Scripts to PATH","text":"<p>When installing Harmony, you may encounter a warning on the command line of something like the following:</p> <pre><code>WARNING: The script harmony is installed in '/path/with/harmony/' which is not on PATH.\n  Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.\n</code></pre> <p>If you do not see this warning, then you can continue.</p> <p>Otherwise, add that path displayed in the message to your <code>PATH</code> variable. See here for extra information on editing the <code>PATH</code> variable.</p>"},{"location":"textbook/install/#command-line-harmony","title":"Command-Line Harmony","text":"<p>Once you have installed <code>harmony-model-checker</code>, you should be able to use the <code>harmony</code> command on your command line.</p> <p>You check which version you have by running <code>harmony --version</code>.</p>"},{"location":"textbook/install/#harmony-on-vscode","title":"Harmony on VSCode","text":"<p>Harmony is available as an extension on VSCode, which includes syntax highlighting and basic parser checks.</p> <p>Please see here for a guide on the basic usage of the VSCode extension.</p>"},{"location":"textbook/install/#updating-harmony","title":"Updating Harmony","text":"<p>Harmony can be updated by running the following <code>pip</code> command on the command line:</p> <pre><code>pip install --upgrade harmony\n</code></pre> <p>In Harmony versions <code>1.2.0</code> and higher, the compiler will output a warning if the currently installed version of Harmony is outdated and an updated one can be installed.</p>"},{"location":"textbook/install/#modifying-your-path-variable","title":"Modifying your PATH variable","text":"<p>Windows:</p> <p>Search for Edit environment variables in the search bar. You can add it either to the <code>Path</code> associated with your account or the system <code>Path</code>.</p> <p></p> <p>Select the variable <code>Path</code> in the user variables section and then click \"Edit\", which opens a new pane.</p> <p></p> <p>Click \"New\" to add a new path, for example, the directory containing <code>gcc</code> or the <code>pip</code> scripts.</p> <p></p> <p>Complete your changes by pressing \"Ok\".</p> <p>MacOS / Linux:</p> <p>Open the Terminal application. Check which shell is running on the Terminal. You check which one you have by running <code>echo \"$SHELL\"</code>.</p> <p>The following instructions are for <code>bash</code> and <code>zsh</code>. Open the <code>~/.bash_profile</code> file (for bash users) or the <code>~/.zsh_profile</code> file (for zsh users) using your favorite text editor, such as <code>vim</code>, <code>nano</code>, <code>emacs</code>, or <code>TextEdit</code>. Then, add the following command to the end of the file, where <code>/path/to/add</code> is to be substituted:</p> <pre><code>export PATH=$PATH:/path/to/add/\n</code></pre> <p>Save the file and restart the Terminal to observe the change.</p>"},{"location":"textbook/interrupts/","title":"Interrupts","text":"<p>Threads can be interrupted. An interrupt is a notification of some event such as a keystroke, a timer expiring, the reception of a network packet, the completion of a disk operation, and so on. We distinguish interrupts and exceptions. An exception is caused by the thread executing an invalid machine instruction such as divide-by-zero. An interrupt is caused by some peripheral device and can be handled in Harmony. In other words: an interrupt is a notification, while an exception is an error.</p> trap.hny<pre><code>sequential done\n\ncount = 0\ndone = False\n\ndef handler():\n    count += 1\n    done = True\n\ndef main():\n    trap handler()\n    await done\n    assert count == 1\n\nspawn main()\n</code></pre> Figure 22.1 (code/trap.hny):  How to use **trap**  <p>Harmony allows modeling interrupts using the <code>trap</code> statement: <pre><code>trap handler argument\n</code></pre> invokes <code>handler</code> argument at some later, unspecified time. Thus you can think of trap as setting a timer. Only one of these asynchronous events can be outstanding at a time; a new call to trap overwrites any outstanding one. Figure 22.1 gives an example of how trap might be used. Here, the <code>main</code>() thread loops until the interrupt has occurred and the done flag has been set.</p> trap2.hny<pre><code>sequential done\n\ncount = 0\ndone = False\n\ndef handler():\n    count += 1\n    done = True\n\ndef main():\n    trap handler()\n    count += 1\n    await done\n    assert count == 2\n\nspawn main()\n</code></pre> Figure 22.2 (code/trap2.hny):  A race condition with interrupts  <p>But now consider Figure 22.2. The difference with Figure 22.1 is that both the <code>main</code>() and <code>handler</code>() methods increment count. This is not unlike the example we gave in Figure 3.2, except that only a single thread is involved now. And, indeed, it suffers from a similar race condition; run it through Harmony to see for yourself. If the interrupt occurs after <code>main</code>() reads count (and thus still has value 0) but before <code>main</code>() writes the updated value\u00a01, then the interrupt handler will also read value\u00a00 and write value\u00a01. We say that the code in Figure 22.2 is not interrupt-safe (as opposed to not being thread-safe).</p> trap3.hny<pre><code>from synch import Lock, acquire, release\n\nsequential done\n\ncountlock = Lock()\ncount = 0\ndone = False\n\ndef handler():\n    acquire(?countlock)\n    count += 1\n    release(?countlock)\n    done = True\n\ndef main():\n    trap handler()\n    acquire(?countlock)\n    count += 1\n    release(?countlock)\n    await done\n    assert count == 2\n\nspawn main()\n</code></pre> Figure 22.3 (code/trap3.hny):  Locks do not work with interrupts  <p>You would be excused if you wanted to solve the problem using locks, similar to Figure 8.3. Figure 22.3 shows how one might go about this. But locks are intended to solve synchronization issues between multiple threads. But an interrupt handler is not run by another thread---it is run by the same thread that experienced the interrupt. If you run the code through Harmony, you will find that the code may not terminate. The issue is that a thread can only acquire a lock once. If the interrupt happens after <code>main</code>() acquires the lock but before <code>main</code>() releases it, the <code>handler</code>() method will block trying to acquire the lock, even though it is being acquired by the same thread that already holds the lock.</p> trap4.hny<pre><code>sequential done\n\ncount = 0\ndone = False\n\ndef handler():\n    count += 1\n    done = True\n\ndef main():\n    trap handler()\n    setintlevel(True)\n    count += 1\n    setintlevel(False)\n    await done\n    assert count == 2\n\nspawn main()\n</code></pre> Figure 22.4 (code/trap4.hny):  Disabling and enabling interrupts  <p>Instead, the way one fixes interrupt-safety issues is through disabling interrupts temporarily. In Harmony, this can be done by setting the interrupt level of a thread to <code>True</code> using the setintlevel interface. Figure 22.4 illustrates how this is done. Note that it is not necessary to change the interrupt level during servicing an interrupt, because it is automatically set to <code>True</code> upon entry to the interrupt handler and restored to <code>False</code> upon exit. It is important that the <code>main</code>() code re-enables interrupts after incrementing count. What would happen if <code>main</code>() left interrupts disabled?</p> trap5.hny<pre><code>sequential done\n\ncount = 0\ndone = False\n\ndef increment():\n    let prior = setintlevel(True):\n        count += 1\n        setintlevel(prior)\n\ndef handler():\n    increment()\n    done = True\n\ndef main():\n    trap handler()\n    increment()\n    await done\n    assert count == 2\n\nspawn main()\n</code></pre> Figure 22.5 (code/trap5.hny):  Example of an interrupt-safe method  <p>setintlevel(il) sets the interrupt level to il and returns the prior interrupt level. Returning the old level is handy when writing interrupt-safe methods that can be called from ordinary code as well as from an interrupt handler. Figure 22.5 shows how one might write a interrupt-safe method to increment the counter.</p> trap6.hny<pre><code>from synch import Lock, acquire, release\n\nsequential t_done, i_done\n\ncount = 0\ncountlock = Lock()\nt_done = i_done = [ False, False ]\n\ndef increment():\n    let prior = setintlevel(True):\n        acquire(?countlock)\n        count += 1\n        release(?countlock)\n        setintlevel(prior)\n\ndef handler(self):\n    increment()\n    i_done[self] = True\n\ndef thread(self):\n    trap handler(self)\n    increment()\n    await i_done[self]\n    t_done[self] = True\n    await all(t_done)\n    assert count == 4\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> Figure 22.6 (code/trap6.hny):  Code that is both interrupt-safe and thread-safe  <p>It will often be necessary to write code that is both interrupt-safe and thread-safe. As you might expect, this involves both managing locks and interrupt levels. To increment count, the interrupt level must be <code>True</code> and countlock must be held. Figure 22.6 gives an example of how this might be done. One important rule to remember is that a thread should disable interrupts before attempting to acquire a lock.</p> <p>Try moving <code>acquire()</code> to the beginning of the <code>increment</code> method and <code>release()</code> to the end of <code>increment</code> and see what happens. This incorrect code can lead to threads getting blocked indefinitely.</p> <p>(Another option is to use synchronization techniques that do not use locks. See Chapter 23 for more information.)</p> <p>There is another important rule to keep in mind. Just like locks should never be held for long, interrupts should never be disabled for long. With locks the issue is to maximize concurrent performance. For interrupts the issue is fast response to asynchronous events. Because interrupts may be disabled only briefly, interrupt handlers must run quickly and cannot wait for other events.</p>"},{"location":"textbook/interrupts/#exercises","title":"Exercises","text":"<p>22.1 The <code>put</code> method you implemented in Example 18.1 cannot be used in interrupt handlers for two reasons: (1) it is not interrupt-safe, and (2) it may block for a long time if the buffer is full. Yet, it would be useful if, say, a keyboard interrupt handler could place an event on a shared queue. Implement a new method <code>i_put</code>(item) that does not block. Instead, it should return <code>False</code> if the buffer is full and <code>True</code> if the item was successfully enqueued. The method also needs to be interrupt-safe.</p>"},{"location":"textbook/leader/","title":"Leader Election","text":"<p>Leader election is the problem of electing a unique leader in a network of processors. Typically this is challenging because the processors have only limited information. In the version that we present, each processor has a unique identifier. The processors are organized in a ring, but each processor only knows its own identifier and the identifier of its successor on the ring. Having already looked into the problem of how to make the network reliable, we assume here that each processor can reliably send messages to its successor.</p> <p>The protocol that we present elects as leader the processor with the highest identifier and works in two phases: in the first phase, each processor sends its identifier to its successor. When a processor receives an identifier that is larger than its own identifier, it forwards that identifier to its successor as well. If a processor receives its own identifier, it discovers that it is the leader. That processor then starts the second phase by sending a message around the ring notifying the other processors of the leader's identifier.</p> leader.hny<pre><code>const NIDS = 5      # number of identifiers\n\nnetwork = {}        # the network is a set of messages\nleader = 0          # used for checking correctness\n\ndef send(msg):\n    atomically network |= { msg }\n\ndef receive(self) returns msg:\n    msg = { (id, found) for (dst, id, found) in network where dst == self }\n\ndef processor(self, succ):\n    send(succ, self, False)\n    var working = True\n    while working:\n        atomically when exists (id, found) in receive(self):\n            if id == self:\n                assert self == leader\n                send(succ, id, True)\n            elif id &gt; self:\n                assert self != leader\n                send(succ, id, found)\n            if found:\n                working = False\n\nvar ids, nprocs, procs = { 1 .. NIDS }, choose({ 1 .. NIDS }), []\nfor i in { 0 .. nprocs - 1 }:\n    let next = choose(ids):\n        ids -= { next }\n        procs += [ next, ]\n        if next &gt; leader:\n            leader = next\nfor i in { 0 .. nprocs - 1 }:\n    spawn processor(procs[i], procs[(i + 1) % nprocs])\n</code></pre> Figure 25.1 ( code/leader.hny):  A leader election protocol on a ring  <p>Figure 25.1 describes the protocol and its test cases in Harmony. In Harmony, processors can be modeled by threads and there are a variety of ways in which one can model a network using shared variables. Here, we model the network as a set of messages. The <code>send</code> method atomically adds a message to this set. Messages are tuples with three fields: (dst, id, found). dst is the identifier of the destination processor; id is the identifier that is being forwarded; and found is a boolean indicating the second phase of the protocol. The <code>receive</code>(self) method looks for all messages destined for the processor with identifier self.</p> <p>To test the protocol, the code first chooses the number of processors and generates an identifier for each processor, chosen non-deterministically from a set of <code>NIDS</code> identifiers. It also keeps track in the variable leader of what the highest identifier is, so it can later be checked.</p> <p>Method <code>processor</code>(self, succ) is the code for a processor with identifier self and successor succ. It starts simply by sending its own identifier to its successor. The processor then loops until it discovers the identifier of the leader in the second phase of the protocol. A processor waits for a message using the Harmony atomically when exists statement. This statement takes the form</p> <p>atomically when exists v in s: statement block</p> <p>where s is a set and v is variable that is bound to an element of s. The properties of the statement are as follows:</p> <ul> <li> <p>it waits until s is non-empty;</p> </li> <li> <p>it is executed atomically;</p> </li> <li> <p>v is selected non-deterministically, like in the choose     operator.</p> </li> </ul> <p>If a processor receives its own identifier, it knows its the leader. The Harmony code checks this using an assertion. In real code the processor could not do this as it does not know the identifier of the leader, but assertions are only there to check correctness. The processor then sends a message to its successor that the leader has been found. If the processor receives an identifier higher than its own, the processor knows that it cannot be the leader. In that case, it simply forwards the message. A processor stops when it receives a message that indicates that the leader has been identified.</p> <p>Note that there is a lot of non-determinism in the specification, leading to a lot of executions that must be checked. First, every possible permutation of identifiers for the processors is tried. When there are multiple messages to receive by a processor, every possible order is tried (including receiving the same message multiple times). Fortunately, the <code>atomically when exists</code> statement is executed atomically, otherwise the body of the statement could lead to additional thread interleavings. Because in practice the different processors do not share memory, it is not necessary to check those interleavings.</p>"},{"location":"textbook/leader/#exercises","title":"Exercises","text":"<p>25.1 Check if the code finds a unique leader if identifiers are not unique.</p> <p>25.2 Messages are added atomically to the network. Is this necessary? What happens if you remove the atomically keyword? Explain what happens.</p>"},{"location":"textbook/method/","title":"Harmony Methods and Pointers","text":"<p>A method m with argument a is invoked in its most basic form as follows (assigning the result to\u00a0r). <pre><code>r = m a\n</code></pre> That's right, no parentheses are required. In fact, if you invoke m(a), the argument is (a), which is the same as a. If you invoke m(), the argument is (), which is the empty tuple. If you invoke m(a, b), the argument is (a, b), the tuple consisting of values a and b.</p> <p>You may note that all this looks familiar. Indeed, the syntax is the  same as that for dictionaries and lists (see Chapter 4). Dictionaries, lists, and methods all map Harmony values to Harmony values, and their syntax is indistinguishable. If <code>f</code> is a method,  list, or dictionary, and <code>x</code> is some Harmony value, then <code>f x</code>, <code>f(x)</code>, and <code>f[x]</code> are all the same expression in Harmony.</p> PetersonMethod.hny<pre><code>def P_enter(pm, pid):\n    pm-&gt;flags[pid] = True\n    pm-&gt;turn = 1 - pid\n    await (not pm-&gt;flags[1 - pid]) or (pm-&gt;turn == pid)\n\ndef P_exit(pm, pid):\n    pm-&gt;flags[pid] = False\n\ndef P_mutex() returns result:\n    result = { .turn: choose({0, 1}), .flags: [ False, False ] }\n\n#### The code above can go into its own Harmony module ####\n\nsequential mutex\nmutex = P_mutex()\n\ndef thread(self):\n    while choose({ False, True }):\n        P_enter(?mutex, self)\n        cs: assert countLabel(cs) == 1\n        P_exit(?mutex, self)\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> Figure 7.1 (code/PetersonMethod.hny):  Peterson's Algorithm accessed through methods  <p>Harmony does not have a return statement. Using the <code>returns</code> clause of <code>def</code>, a result variable can be declared, for example: <code>def f() returns something</code>.  The result of the method should be assigned to variable <code>something</code>. If there is no <code>returns</code> clause, then (for backwards compatibility reasons) the method has a default result variable called <code>result</code>.  The default value of <code>result</code> is <code>None</code> for compatibility with Python.</p> <p>Harmony also does not support break or continue statements in loops. One reason for their absence is that, particularly in concurrent programming, such control flow directions are highly error-prone. It's too easy to forget to, say, release a lock when returning a value in the middle of a method---a major source of bugs in practice.</p> <p>Harmony is not an object-oriented language like Python is. In Python, you can pass a reference to an object to a method, and that method can then update the object. In Harmony, it is also sometimes convenient to have a method update a shared variable specified as an argument. For this, as mentioned in Chapter 4, each shared variable has an address, itself a Harmony value. If x is a shared variable, then the expression ?x is the address of x. If a variable contains an address, we call that variable a pointer. If p is a pointer to a shared variable, then the expression !p is the value of the shared variable. In particular, !?x = x. This is similar to how C pointers work (<code>*&amp;</code>x = x).</p> <p>Often, pointers point to dictionaries, and so if p is such a pointer, then (!p).field would evaluate to the specified field in the dictionary. Note that the parentheses in this expression are needed, as !p.field would wrongly evaluate !(p.field). (!p).field is such a common expression that, like C, Harmony supports the shorthand p-&gt;field, which greatly improves readability.</p> <p>Figure 7.1 again shows Peterson's algorithm, but this time with methods defined to enter and exit the critical section. The name mutex is often used to denote a variable or value that is used for mutual exclusion. <code>P_mutex</code> is a method that returns a \"mutex,\" which, in this case, is a dictionary that contains Peterson's Algorithm's shared memory state: a turn variable and two flags. Both methods <code>P_enter</code> and <code>P_exit</code> take two arguments: a pointer to a mutex and the thread identifier (0 or 1). pm-&gt;turn is the value of the .turn key in the dictionary that pm points to.</p> <p>You can put the first three methods in its own Harmony source file and include it using the Harmony import statement. This would make the code usable by multiple applications.</p> <p>Finally, methods can have local variables. Method variables are either mutable (writable) or immutable (read-only). The arguments to a method and the bound variable (or variables) within a for statement are immutable; the result variable is mutable. Using the var statement, new mutable local variables can be declared. For example, var \\(x = 3\\) declares a new mutable local variable x. The let statement allows declaring new immutable local variables. For example: let \\(x = 3\\): y \\(+\\)\\(=\\) x adds 3 to the global variable y. See for more information.</p> hanoi.hny<pre><code>import list\n\ncurrent = [ [1, 2, 3], [], [] ]\n\nwhile current[2] != [1, 2, 3]:\n    let moves = { (s, d) for s in {0..2} for d in {0..2}\n        where current[s] != []\n        where (current[d] == []) or (current[s][0] &lt; current[d][0]) }\n    let (src,dst) = choose moves:\n        print str(src) + \" -&gt; \" + str(dst)\n        current[dst] = [list.head(current[src]),] + current[dst]\n        current[src] = list.tail(current[src])\n\nassert False\n</code></pre> Figure 7.2 (code/hanoi.hny):  Towers of Hanoi  <p>As an example of using import and let, Figure 7.2 solves the Towers of Hanoi problem. If you are not familiar with this problem: there are three towers with disks of varying sizes. In the initial configuration, the first tower has three disks (of sizes 1, 2, and 3), with the largest disk at the bottom, while the other two towers are empty. You are allowed to move a top disk from one tower to another, but you are not allowed to stack a larger disk on a smaller one. The objective is to move the disks from the first tower to the third one.</p> <p>The program uses the <code>list</code> module documented in . It has methods to extract the head (first element) and the tail (remaining elements) of a list. (The code is simple and available in <code>modules/list.hny</code>.) The program tries valid moves at random until it finds a solution. Curiously, the program then asserts <code>False</code>. This is to cause the model checker to stop and output the trace. If you look in the output column of the trace, you will find the minimal number of moves necessary to solve the problem.</p> <p>It is even cooler to remove that assertion and let Harmony generate all possible solutions to the problem like so:</p> <pre><code>$ harmony -o hanoi.png code/hanoi.hny\n</code></pre> <p>The resulting <code>hanoi.png</code> file contains a DFA describing the possible solutions. It is a little too big to include here, but well worth looking at.</p> clock.hny<pre><code>const FIFO = False\n\ndef CLOCK(n) returns result:\n    result = { .entries: [None,] * n, .recent: {}, .hand: 0, .misses: 0 }\n\ndef ref(clock, x):\n    if x not in clock-&gt;entries:\n        while clock-&gt;entries[clock-&gt;hand] in clock-&gt;recent:\n            clock-&gt;recent -= {clock-&gt;entries[clock-&gt;hand]}\n            clock-&gt;hand = (clock-&gt;hand + 1) % len(clock-&gt;entries)\n        clock-&gt;entries[clock-&gt;hand] = x\n        clock-&gt;hand = (clock-&gt;hand + 1) % len(clock-&gt;entries)\n        clock-&gt;misses += 1\n    if not FIFO:\n        clock-&gt;recent |= {x}\n\nclock3, clock4, refs = CLOCK(3), CLOCK(4), []\n\nconst VALUES = { 1..5 }\n\nvar last = {}\nfor i in {1..100}:\n    let x = i if i &lt; 5 else choose(VALUES - last):\n        refs = refs + [x,]\n        ref(?clock3, x); ref(?clock4, x)\n        assert(clock4.misses &lt;= clock3.misses)\n        last = {x}\n</code></pre> Figure 7.3 (code/clock.hny):  Harmony program that finds page replacement anomalies  <p>If you are ready to learn about how locks are implemented in practice, you can now skip the rest of this chapter. But if you would like to see a cool example of using the concepts introduced in this chapter, hang on for a sequential Harmony program that finds anomalies in page replacement algorithms. In 1969, B\u00e9l\u00e1dy et al.\u00a0published a paper that showed that making a cache larger does not necessarily lead to a higher hit ratio. He showed this for a scenario using a FIFO replacement policy when the cache is full. The program in Figure 7.3 will find exactly the same scenario if you define <code>FIFO</code> to be <code>True</code>. Moreover, if you define <code>FIFO</code> to be <code>False</code>, it will find a scenario for the CLOCK replacement policy, often used in modern operating systems.</p> <p>In this program, <code>CLOCK</code> maintains the state of a cache (in practice, typically pages in memory). The set recent maintains whether an access to the cache for a particular reference was recent or not. (It is not used if <code>FIFO</code> is <code>True</code>.) The integer misses maintains the number of cache misses. Method <code>ref</code>(ck, x) is invoked when x is referenced and checked against the cache ck.</p> <p>The program declares two caches: one with 3 entries (clock3) and one with 4 entries (clock4). The interesting part is in the last block of code. It runs every sequence of references of up to 100 entries, using references in the range 1 through 5. Note that all the constants chosen in this program (3, 4, 5, 100) are the result of some experimentation---you can try other ones. To reduce the search space, the first four references are pinned to 1, 2, 3, and 4. Further reducing the search space, the program never repeats the same reference twice in a row (using the local variable last).</p> <p>The two things to note here is the use of the choose expression and the assert statement. Using choose, we are able to express searching through all possible strings of references without a complicated nested iteration. Using <code>assert</code>, we are able to express the anomaly we are looking for.</p> <p>In case you want to check if you get the right results. For <code>FIFO</code>, the program finds the same anomaly that B\u00e9l\u00e1dy et al.\u00a0found: 1 2 3 4 1 2 5 1 2 3 4 5. For the <code>CLOCK</code> algorithm the program actually finds a shorter reference string: 1 2 3 4 2 1 2 5 1 2.</p>"},{"location":"textbook/method/#exercises","title":"Exercises","text":"<p>7.1 (This is just for fun or exercise as it is not a concurrent or distributed problem.) Implement a Harmony program that finds solutions to the \"cabbage, goat, and wolf\" problem. In this problem, a person accompanied by these three items has to cross a stream in a small boat, but can only take one item at a time. So, the person has to cross back and forth several times, leaving two items on one or the other shore by themselves. Unfortunately, if left to themselves, the goat would eat the cabbage and the wolf would eat the goat. What crossings does the person need to make in order not to lose any items?</p>"},{"location":"textbook/module/","title":"Modules","text":"<p>Harmony modules provide convenient access to various data structures, algorithms, and synchronization paradigms. They are all implemented in the Harmony language itself (so you can look at their code) although some methods have also been implemented directly into the underlying model checker for more efficient model checking.</p> <p>Currently there are the following modules:</p> Module Description <code>action</code> support for action-based specifications <code>alloc</code> dynamic memory allocation <code>bag</code> multi-sets <code>fork</code> fork/join interface to threads <code>hoare</code> Hoare module interface <code>list</code> common operations on lists <code>set</code> common operations on sets <code>synch</code> synchronization"},{"location":"textbook/module/#the-action-module","title":"The <code>action</code> module","text":"<p>The <code>action</code> module supports action-based specification. Such a specification consists of a explicit global state and rules for how to make state transitions. Chapter 28 provides an example. The module has only one method:</p> Method Description <code>explore(x)</code> explore the state space <p>Here <code>x</code> is a set of lambdas, each of which can return a set of closures, each representing a possible action (state change). The union of the results of the lambdas should generate all possible actions.  A closure represents a method and its arguments that updates the state accordingly.</p>"},{"location":"textbook/module/#the-alloc-module","title":"The <code>alloc</code> module","text":"<p>The <code>alloc</code> module supports thread-safe (but not interrupt-safe) dynamic allocation of shared memory locations. There are just two methods:</p> Method Description <code>malloc</code>(v) return a pointer to a memory location initialized to v <code>free</code>(p) free an allocated memory location p <p>The usage is similar to <code>malloc</code> and <code>free</code> in C. <code>malloc</code>() is specified to return <code>None</code> when running out of memory, although this is an impossible outcome in the current implementation of the module.</p>"},{"location":"textbook/module/#the-bag-module","title":"The <code>bag</code> module","text":"<p>The <code>bag</code> module has various useful methods that operate on bags or multisets:</p> Method Description <code>empty</code>() returns an empty bag <code>fromSet(s)</code> create a bag from set s <code>fromList(t)</code> convert list t into a bag <code>multiplicity(b, e)</code> count how many times e occurs in bag b <code>bchoose(b)</code> like <code>choose(s)</code>, but applied to a bag <code>add</code>(b, e) add one copy of e to bag b <code>remove</code>(b, e) remove one copy of e from bag b <code>combinations</code>(b, k) return set of all subbags of size k"},{"location":"textbook/module/#the-fork-module","title":"The <code>fork</code> module","text":"<p>The <code>fork</code> module implements the fork/join interface to threads.</p> Method Description <code>fork(closure)</code> spawn <code>closure</code> and return a thread handle <code>join(handle)</code> wait for the thread to finish and return its result <p>For example, the following code doubles each element of <code>data</code> in parallel and then sums the result when done.</p> <pre><code>from fork import *\nfrom list import *\n\ndata = { 1, 2, 4 }\n\ndef main():\n    let double = lambda x: 2*x end\n    let map = { fork(?double(k)) for k in data }:\n        print sum(join(t) for t in map)\n\nspawn main()\n</code></pre>"},{"location":"textbook/module/#the-hoare-module","title":"The <code>hoare</code> module","text":"<p>The <code>hoare</code> module implements support for Hoare-style monitors and condition variables.</p> Method Description <code>Monitor()</code> return a monitor mutex <code>enter(m)</code> enter a monitor. m points to a monitor mutex <code>exit(m)</code> exit a monitor <code>Condition()</code> return a condition variable <code>wait(c, m)</code> wait on condition variable pointed to by c in monitor pointed to by m <code>signal(c, m)</code> signal a condition variable"},{"location":"textbook/module/#the-list-module","title":"The <code>list</code> module","text":"<p>The <code>list</code> module has various useful methods that operate on lists or tuples:</p> Method Description <code>subseq(t, b, f)</code> return a slice of list t starting at index b and ending just before \\(f\\) <code>append(t, e)</code> append e to list t <code>head(t)</code> return the first element of list t <code>tail(t)</code> return all but the first element of list t <code>index(t, e)</code> return the index of element e in list t <code>startswith(t, s)</code> returns whether s is a prefix of t <code>reversed(t)</code> reverse a list <code>sorted(t)</code> sorted set or list <code>set(t)</code> convert a list into a set <code>list(t)</code> convert set into a list <code>values(t)</code> convert values of a dict into a list sorted by key <code>items(t)</code> convert dict into (key, value) list sorted by key <code>enumerate(t)</code> like Python enumerate <code>sum(t)</code> returns the sum of all elements in t <code>qsort(t)</code> sort list t using quicksort <code>foldl(t, f, z)</code> left fold with f a binary method and z the initial value <code>foldr(t, f, z)</code> right fold with f a binary method and z the initial value <code>reduce(f, t, z)</code> same as <code>foldl(t, f, z)</code>"},{"location":"textbook/module/#the-set-module","title":"The <code>set</code> module","text":"<p>The <code>set</code> module implements the following methods:</p> Method Description <code>issubseteq</code>(s, t) returns whether s is a subset of t <code>issubsetstrict</code>(s, t) returns whether s is a strict subset of t <code>issubset</code>(s, t) same as <code>issubseteq(s, t)</code> <code>issuperseteq</code>(s, t) returns whether s is a superset of t <code>issupersetstrict</code>(s, t) returns whether s is a strict superset of t <code>issuperset</code>(s, t) same as <code>issuperseteq(s, t)</code> <code>add</code>(s, e) returns \\(s \\cup \\{ e \\}\\) <code>remove</code>(s, e) returns \\(s \\backslash \\{ e \\}\\) <code>subsets(s)</code> returns the set of subsets of s <code>union(s)</code> returns the union of the elements of s <code>cartesian(d)</code> d is a list of sets.  Returns the Cartesian product. <code>combinations(s, k)</code> returns set of all subsets of size k <code>reduce(f, t, z}&gt;)</code> same as Python's <code>functools reduce()</code> <p>For Python programmers: note that s \\(&lt;=\\) t does not check if s is a subset of t when s and t are sets, as \"\\(&lt;=\\)\" implements a total order on all Harmony values including sets (and the subset relation is not a total order).</p>"},{"location":"textbook/module/#the-synch-module","title":"The <code>synch</code> module","text":"<p>The <code>synch</code> module provides the following methods:</p> Method Description <code>atomic_load</code>(p) atomically evaluate !p <code>atomic_store</code>(p, v) atomically assign !p = v <code>tas</code>(lk) test-and-set on !lk <code>cas</code>(ptr, old, new) compare-and-swap on !ptr <code>BinSema</code>(v) return a binary semaphore initialized to v <code>Lock</code>() return a binary semaphore initialized to <code>False</code> <code>acquire</code>(bs) acquire binary semaphore !bs <code>release</code>(bs) release binary semaphore !bs <code>Condition</code>() return a condition variable <code>wait</code>(c, lk) wait on condition variable !c and lock lk <code>notify</code>(c) notify a thread waiting on condition variable !c <code>notifyAll</code>(c) notify all threads waiting on condition variable !c <code>Semaphore</code>(cnt) return a counting semaphore initialized to cnt <code>P</code>(sema) procure !sema <code>V</code>(sema) vacate !sema <code>Queue</code>() return a synchronized queue object <code>get</code>(q) return next element of q, blocking if empty <code>put</code>(q, item) add item to a"},{"location":"textbook/monitors/","title":"Monitors","text":"<p>Tony Hoare, who came up with the concept of split binary semaphores (SBS), devised an abstraction of the concept in a programming language paradigm called monitors. (A similar construct was independently invented by Per Brinch Hansen.) A monitor is a special version of an object-oriented class, comprising a set of variables and methods that operate on those variables. A monitor also has special variables called condition variables, one per waiting condition. There are two operations on condition variables: <code>wait</code> and <code>signal</code>.</p> hoare.hny<pre><code>import synch\n\ndef Monitor() returns monitor:\n    monitor = synch.Lock()\n\ndef enter(mon):\n    synch.acquire(mon)\n\ndef exit(mon):\n    synch.release(mon)\n\ndef Condition() returns condition:\n    condition = { .sema: synch.BinSema(True), .count: 0 }\n\ndef wait(cond, mon):\n    cond-&gt;count += 1\n    exit(mon)\n    synch.acquire(?cond-&gt;sema)\n    cond-&gt;count -= 1\n\ndef signal(cond, mon):\n    if cond-&gt;count &gt; 0:\n        synch.release(?cond-&gt;sema)\n        enter(mon)\n</code></pre> Figure 18.1 (modules/hoare.hny):  Implementation of Hoare monitors  <p>Harmony does not have language support for monitors, but it has a module called <code>hoare</code>. Figure 18.1 shows its implementation. A Hoare monitor uses a hidden split binary semaphore. The mutex semaphore is acquired when entering a monitor and released upon exit. Each condition variable maintains a binary semaphore and a counter for the number of threads waiting on the condition. Method <code>wait</code> increments the condition's counter, releases the monitor mutex, blocks while trying to acquire the condition's semaphore, and upon resuming decrements the counter---in much the same way as we have seen for SBS. Method <code>signal</code> checks to see if the condition's count is non-zero, if so releases the condition's semaphore, and then blocks by trying to acquire the mutex again.</p> BBhoare.hny<pre><code>import hoare\n\ndef BoundedBuffer(size) returns buffer:\n    buffer = {\n            .mon: hoare.Monitor(),\n            .prod: hoare.Condition(), .cons: hoare.Condition(),\n            .buf: { x:() for x in {1..size} },\n            .head: 1, .tail: 1,\n            .count: 0, .size: size\n        }\n\ndef put(bb, item):\n    hoare.enter(?bb-&gt;mon)\n    if bb-&gt;count == bb-&gt;size:\n        hoare.wait(?bb-&gt;prod, ?bb-&gt;mon)\n    bb-&gt;buf[bb-&gt;tail] = item\n    bb-&gt;tail = (bb-&gt;tail % bb-&gt;size) + 1\n    bb-&gt;count += 1\n    hoare.signal(?bb-&gt;cons, ?bb-&gt;mon)\n    hoare.exit(?bb-&gt;mon)\n\ndef get(bb) returns next:\n    hoare.enter(?bb-&gt;mon)\n    if bb-&gt;count == 0:\n        hoare.wait(?bb-&gt;cons, ?bb-&gt;mon)\n    next = bb-&gt;buf[bb-&gt;head]\n    bb-&gt;head = (bb-&gt;head % bb-&gt;size) + 1\n    bb-&gt;count -= 1\n    hoare.signal(?bb-&gt;prod, ?bb-&gt;mon)\n    hoare.exit(?bb-&gt;mon)\n</code></pre> Figure 18.2 (modules/BBhoare.hny):  Bounded Buffer implemented using a Hoare monitor  <p>Figure 18.2 presents a bounded buffer implemented using Hoare monitors. It is written in much the same way you would if using the SBS technique (see Exercise 16.3). However, there is no <code>release_one</code> method. Instead, one can conclude that <code>put</code> guarantees that the queue will be non-empty, and <code>signal</code> will check if there are any threads waiting for this event. If so, <code>signal</code> will pass control to one such thread and, unlike <code>release_one</code>, re-enter the critical section afterwards by acquiring the mutex.</p> <p>Implementing a reader/writer lock with Hoare monitors is not quite so straightforward, unfortunately. When a writer releases the lock, it has to choose whether to signal a reader or another writer. For that it needs to know if there is a reader or writer waiting. The simplest solution would be to peek at the counters inside the respective condition variables, but that breaks the abstraction. The alternative is for the reader/writer implementation to keep track of that state explicitly, which complicates the code. Also, it requires a deep understanding of the SBS method to remember to place a call to <code>signal</code> in the <code>read_acquire</code> method that releases additional readers that may be waiting to acquire the lock.</p> <p>In the late 70s, researchers at Xerox PARC, where among others the desktop and Ethernet were invented, developed a new programming language called Mesa. Mesa introduced various important concepts to programming languages, including software exceptions and incremental compilation. Mesa also incorporated a version of monitors. However, there are some subtle but important differences with Hoare monitors that make Mesa monitors quite unlike split binary semaphores and mostly easier to use in practice.</p> <p>As in Hoare monitors, there is a hidden mutex associated with each Mesa monitor, and the mutex must be acquired upon entry to a method and released upon exit. Mesa monitors also have condition variables that a thread can wait on. Like in Hoare monitors, the <code>wait</code> operation releases the mutex. The most important difference is in what <code>signal</code> does. To make the distinction more clear, we shall call the corresponding Mesa operation <code>notify</code> rather than <code>signal</code>. Unlike <code>signal</code>, when a thread p invokes <code>notify</code> it does not immediately pass control to a thread that is waiting on the corresponding condition (if there is such a thread). Instead, p continues executing in the critical section until it leaves the monitor (by calling <code>release</code>) or releases the monitor (by calling <code>wait</code>). Either way, any thread that was notified will now have a chance to enter the critical section, but they compete with other threads trying to enter the critical section.</p> <p>Basically, there is just one gate to enter the critical section, instead of a main gate and a gate per waiting condition. This is a very important difference. In Hoare monitors, when a thread enters through a waiting gate, it can assume that the condition associated with the waiting gate still holds because no other thread can run in between. Not so with Mesa monitors: by the time a thread that was notified enters through the main gate, other threads may have entered first and falsified the condition. So, in Mesa, threads always have to check the condition again after resuming from the <code>wait</code> operation. This is accomplished by wrapping each <code>wait</code> operation in a while statement that loops until the condition of interest becomes valid. A Mesa monitor therefore is more closely related to busy waiting than to split binary semaphores.</p> <p>Mesa monitors also allow notifying multiple threads. For example, a thread can invoke <code>notify</code> twice---if there are two or more threads waiting on the condition variable, two will be resumed. Operation <code>notifyAll</code> (aka <code>broadcast)</code>) notifies all threads that are waiting on a condition. Signaling multiple threads is not possible with Hoare monitors because with Hoare monitors control must be passed immediately to a thread that has been signaled, and that can only be done if there is just one such thread.</p> <p>The so-called \"Mesa monitor semantics\" or \"Mesa condition variable semantics\" have become more popular than Hoare monitor semantics and have been adopted by all major programming languages. That said, few programming languages provide full syntactical support for monitors, instead opting to support monitor semantics through library calls. In Java, each object has a hidden lock and a hidden condition variable associated with it. Methods declared with the <code>synchronized</code> keyword automatically obtain the lock. Java objects also support <code>wait</code>, <code>notify</code>, and <code>notifyAll</code>. In addition, Java supports explicit allocations of locks and condition variables. In Python, locks and condition variables must be explicitly declared. The <code>with</code> statement makes it easy to acquire and release a lock for a section of code. In C and C++, support for locks and condition variables is entirely through libraries.</p> synch.hny<pre><code>import list\nimport bag\n\ndef tas(lk):\n    atomically:\n        result = !lk\n        !lk = True\n\ndef cas(p, old, new):\n    atomically:\n        result = !p == old\n        if result:\n            !p = new\n\ndef BinSema(acquired):\n    result = acquired\n\ndef Lock():\n    result = BinSema(False)\n\ndef acquired(binsema):\n    result = !binsema\n\ndef acquire(binsema):\n    atomically when not !binsema:\n        !binsema = True\n\ndef release(binsema):\n    assert !binsema\n    atomically !binsema = False\n\ndef held(binsema):\n    result = !binsema\n\ndef Condition():\n    result = bag.empty()\n\ndef wait(c, lk):\n    var cnt = 0\n    let (), ctx = save():\n        atomically:\n            cnt = bag.multiplicity(!c, ctx)\n            !c = bag.add(!c, ctx)\n            !lk = False\n        atomically when (not !lk) and (bag.multiplicity(!c, ctx) &lt;= cnt):\n            !lk = True\n\ndef notify(c):\n    atomically if !c != bag.empty():\n        !c = bag.remove(!c, bag.bchoose(!c))\n\ndef notifyAll(c):\n    atomically !c = bag.empty()\n\ndef Semaphore(cnt):\n    result = cnt\n\ndef P(sema):\n    atomically when !sema &gt; 0:\n        !sema -= 1\n\ndef V(sema):\n    atomically !sema += 1\n\ndef Queue():\n    result = []\n\ndef get(q):\n    atomically when !q != []:\n        result = list.head(!q)\n        !q = list.tail(!q)\n\ndef put(q, item):\n    atomically !q = list.append(!q, item)\n</code></pre> Figure 18.3 (modules/synch.hny):  Implementation of condition variables in the `synch` module  RWcv.hny<pre><code>from synch import *\n\ndef RWlock() returns lock:\n    lock = {\n            .nreaders: 0, .nwriters: 0, .mutex: Lock(),\n            .r_cond: Condition(), .w_cond: Condition()\n        }\n\ndef read_acquire(rw):\n    acquire(?rw-&gt;mutex)\n    while rw-&gt;nwriters &gt; 0:\n        wait(?rw-&gt;r_cond, ?rw-&gt;mutex)\n    rw-&gt;nreaders += 1\n    release(?rw-&gt;mutex)\n\ndef read_release(rw):\n    acquire(?rw-&gt;mutex)\n    rw-&gt;nreaders -= 1\n    if rw-&gt;nreaders == 0:\n        notify(?rw-&gt;w_cond)\n    release(?rw-&gt;mutex)\n\ndef write_acquire(rw):\n    acquire(?rw-&gt;mutex)\n    while (rw-&gt;nreaders + rw-&gt;nwriters) &gt; 0:\n        wait(?rw-&gt;w_cond, ?rw-&gt;mutex)\n    rw-&gt;nwriters = 1\n    release(?rw-&gt;mutex)\n\ndef write_release(rw):\n    acquire(?rw-&gt;mutex)\n    rw-&gt;nwriters = 0\n    notifyAll(?rw-&gt;r_cond)\n    notify(?rw-&gt;w_cond)\n    release(?rw-&gt;mutex)\n</code></pre> Figure 18.4 (code/RWcv.hny):  Reader/Writer Lock using Mesa-style condition variables  <p>Harmony provides support for Mesa monitors through the Harmony <code>synch</code> module. Figure 18.3 shows the implementation of condition variables in the <code>synch</code> module. <code>Condition()</code> creates a new condition variable. It is represented by a dictionary containing a bag of contexts of threads waiting on the condition variable. (The <code>synchS</code> library instead uses a list of contexts.)</p> <p>In Harmony, a bag is usually represented by a dictionary that maps the elements of the bag to their multiplicities. For example, the value { .a: 2, .b: 3 } represents a bag with two copies of .a and three copies of .b. The <code>bag</code> module contains a variety of handy functions on bags.</p> <p>Method &lt;{wait}&gt; adds the context of the thread---used as a unique identifier for the thread---to the bag, incrementing the number of threads in the bag with the same context. The Harmony <code>save</code> expression returns a tuple containing a value  (in this case <code>()</code>) and the context of the thread. <code>wait</code> then loops until that count is restored to the value that it had upon entry to <code>wait</code>. Method <code>notify</code> removes an arbitrary context from the bag, allowing one of the threads with that context to resume and re-acquire the lock associated with the monitor. <code>notifyAll</code> empties out the entire bag, allowing all threads in the bag to resume.</p> <p>To illustrate how Mesa condition variables are used in practice, we demonstrate using an implementation of reader/writer locks. Figure 18.4 shows the code. mutex is the shared lock that protects the critical region. There are two condition variables: readers wait on r_cond and writers wait on w_cond. The implementation also keeps track of the number of readers and writers in the critical section.</p> <p>Note that <code>wait</code> is always invoked within a while loop that checks for the condition that the thread is waiting for. It is imperative that there is always a while loop around any invocation of <code>wait</code> containing the negation of the condition that the thread is waiting for. Many implementation of Mesa condition variables depend on this, and optimized implementations of condition variables often allow so-called \"spurious wakeups,\" where <code>wait</code> may sometimes return even if the conditon variable has not been notified. As a rule of thumb, one should always be able to replace <code>wait</code> by <code>release</code> followed by <code>acquire</code>. This turns the solution into a busy-waiting one, inefficient but still correct.</p> <p>In <code>read_release</code>, notice that <code>notify</code>(?w_cond) is invoked when there are no readers left, without checking if there are writers waiting to enter. This is ok, because calling <code>notify</code> is a no-op if no thread is waiting.</p> <p><code>write_release</code> executes <code>notifyAll</code>(?r_cond) as well as <code>notify</code>(?w_cond). Because we do not keep track of the number of waiting readers or writers, we have to conservatively assume that all waiting readers can enter, or, alternatively, up to one waiting writer can enter. So <code>write_release</code> wakes up all potential candidates. There are two things to note here. First, unlike split binary semaphores or Hoare monitors, where multiple waiting readers would have to be signaled one at a time in a baton-passing fashion (see Figure 16.1), with Mesa monitors all readers are awakened in one fell swoop using <code>notifyAll</code>. Second, both readers and writers are awakened---this is ok because both execute <code>wait</code> within a while loop, re-checking the condition that they are waiting for. So, if both type of threads are waiting, either all the readers get to enter next or one of the writers gets to enter next. (If you want to prevent waking up both readers and a writer, then you can keep track of how many threads are waiting in the code.)</p> <p>When using Mesa condition variables, you have to be careful to invoke <code>notify</code> or <code>notifyAll</code> in the right places. Much of the complexity of programming with Mesa condition variables is in figuring out when to invoke <code>notify</code> and when to invoke <code>notifyAll</code>. As a rule of thumb: be conservative---it is better to wake up too many threads than too few. In case of doubt, use <code>notifyAll</code>. Waking up too many threads may lead to some inefficiency, but waking up too few may cause the application to get stuck. Harmony can be particularly helpful here, as it examines each and every corner case. You can try to replace each <code>notifyAll</code> with <code>notify</code> and see if every possible execution of the application still terminates.</p> <p>Andrew Birrell's paper on Programming with Threads gives an excellent introduction to working with Mesa-style condition variables.</p>"},{"location":"textbook/monitors/#exercises","title":"Exercises","text":"<p>18.1 Implement a solution to the bounded buffer problem using Mesa condition variables.</p> <p>18.2 Implement a \"try lock\" module using Mesa condition variables (see also ). It should have the following API:</p> <ol> <li> <p>tl = <code>TryLock</code>() # create a try lock</p> </li> <li> <p><code>acquire</code>(?tl) # acquire a try lock</p> </li> <li> <p><code>tryAcquire</code>(?tl) # attempt to acquire a try lock</p> </li> <li> <p><code>release</code>(?tl) # release a try lock</p> </li> </ol> <p><code>tryAcquire</code> should not wait. Instead it should return <code>True</code> if the lock was successfully acquired and <code>False</code> if the lock was not available.</p> <p>18.3 Write a new version of the GPU allocator in Exercise 16.7 using Mesa condition variables. In this version, a thread is allowed to allocate a set of GPUs and release a set of GPUs that it has allocated. Method <code>gpuAllocSet(n)</code> should block until \\(n\\) GPUs are available, but it should grant them as soon as they are available. It returns a set of \\(n\\) GPU identifiers. Method <code>gpuReleaseSet(s)</code> takes a set of GPU identifiers as argument. A thread does not have to return all the GPUs it allocated at once. (You may want to try implementing this with Split Binary Semaphores. It is not as easy.)</p> <p>18.4 The specification in the previous question makes the solution unfair. Explain why this is so. Then change the specification and the solution so that it is fair.</p> <p>18.5 Bonus problem: Figure 18.5 shows an iterative implementation of the Qsort algorithm, and Figure 18.6 an accompanying test program. The array to be sorted is stored in shared variable testqs.arr. Another shared variable, testqs.todo, contains the ranges of the array that need to be sorted (initially the entire array). Re-using as much of this code as you can, implement a parallel version of this. You should not have to change the methods <code>swap</code>, <code>partition</code>, or <code>sortrange</code> for this. Create <code>NWORKERS</code> \"worker threads\" that should replace the <code>qsort</code> code. Each worker loops until todo is empty and sorts the ranges that it finds until then. The <code>main</code> thread needs to wait until all workers are done.</p> qsort.hny<pre><code>def Qsort(arr) returns state:\n    state = { .arr: arr, .todo: { (0, len(arr) - 1) } }\n\ndef swap(p, q):               # swap !p and !q\n    !p, !q = !q, !p; \n\ndef partition(qs, lo, hi) returns pivot:\n    pivot = lo\n    for i in {lo..hi - 1}:\n        if qs-&gt;arr[i] &lt;= qs-&gt;arr[hi]:\n            swap(?qs-&gt;arr[pivot], ?qs-&gt;arr[i])\n            pivot += 1\n    swap(?qs-&gt;arr[pivot], ?qs-&gt;arr[hi]); \n\ndef sortrange(qs, range):\n    let lo, hi = range let pivot = partition(qs, lo, hi):\n        if (pivot - 1) &gt; lo:\n            qs-&gt;todo |= { (lo, pivot - 1) }\n        if (pivot + 1) &lt; hi:\n            qs-&gt;todo |= { (pivot + 1, hi) }\n\ndef sort(qs) returns sorted:\n    while qs-&gt;todo != {}:\n        let range = choose(qs-&gt;todo):\n            qs-&gt;todo -= { range }\n            sortrange(qs, range)\n    sorted = qs-&gt;arr\n</code></pre> Figure 18.5 (code/qsort.hny):  Iterative qsort() implementation  qsorttest.hny<pre><code>import qsort, bag\n\nconst NITEMS = 4\n\na = [ choose({1..NITEMS}) for i in {1..choose({1..NITEMS})} ]\ntestqs = qsort.Qsort(a)\nsa = qsort.sort(?testqs)\nassert all(sa[i - 1] &lt;= sa[i] for i in {1..len(sa)-1}) # sorted?\nassert bag.fromList(a) == bag.fromList(sa); # is it a permutation?\n</code></pre> Figure 18.6 (code/qsorttest.hny):  Test program for Figure 18.5"},{"location":"textbook/nonblocking/","title":"Non-Blocking Synchronization","text":"<p>So far, we have concentrated on critical sections to synchronize multiple threads. Certainly, preventing multiple threads from accessing certain code at the same time simplifies how to think about synchronization. However, it can lead to starvation. Even in the absence of starvation, if some thread is slow for some reason while being in the critical section, the other threads have to wait for it to finish executing the critical section. Also, using synchronization primitives in interrupt handlers is tricky to get right (Chapter 22) and might be too slow. In this chapter, we will have a look at how one can develop concurrent code in which threads do not have to wait for other threads (or interrupt handlers) to complete their ongoing operations.</p> hw.hny<pre><code>const MAX_ITEMS = 3\n\nsequential back, items\nback = 0\nitems = [None,] * MAX_ITEMS\n\ndef inc(pcnt) returns prior:\n    atomically:\n        prior = !pcnt\n        !pcnt += 1\n\ndef exch(pv) returns prior:\n    atomically:\n        prior = !pv\n        !pv = None\n\ndef produce(item):\n    items[inc(?back)] = item\n\ndef consume() returns next:\n    next = None\n    while next == None:\n        var i = 0\n        while (i &lt; back) and (next == None):\n            next = exch(?items[i])\n            i += 1\n\nfor i in {1..MAX_ITEMS}:\n    spawn produce(i)\nfor i in {1..choose({0..MAX_ITEMS})}:\n    spawn consume()\n</code></pre> Figure 23.1 (code/hw.hny):  Non-blocking queue  <p>As an example, we will revisit the producer/consumer problem. The code in Figure 23.1 is based on code developed by Herlihy and Wing. The code is a \"proof of existence\" for non-blocking synchronization; it is not necessarily practical. There are two variables. items is an unbounded array with each entry initialized to <code>None</code>. back is an index into the array and points to the next slot where a new value is inserted. The code uses two atomic operations:</p> <ul> <li> <p><code>inc</code>(p): atomically increments !p and returns the old value;</p> </li> <li> <p><code>exch</code>(p): sets !p to <code>None</code> and returns the old value.</p> </li> </ul> <p>Method <code>produce</code>(item) uses <code>inc</code>(?back) to allocate the next available slot in the items array. It stores the item as a singleton tuple. Method <code>consume</code>() repeatedly scans the array, up to the back index, trying to find an item to return. To check an entry, it uses <code>exch</code>() to atomically remove an item from a slot if there is one. This way, if two or more threads attempt to extract an item from the same slot, at most one will succeed.</p> <p>There is no critical section. If one thread is executing instructions very slowly, this does not negatively impact the other threads, as it would with solutions based on critical sections. On the contrary, it helps them because it creates less contention. Unfortunately, the solution is not practical for the following reasons:</p> <ul> <li> <p>The items array must be of infinite size if an unbounded number of     items may be produced;</p> </li> <li> <p>Each slot in the array is only used once, which is inefficient;</p> </li> <li> <p>the <code>inc</code> and <code>exch</code> atomic operations are not universally available     on existing processors.</p> </li> </ul> <p>However, in the literature you can find examples of practical non-blocking (aka wait-free) synchronization algorithms.</p>"},{"location":"textbook/nonblocking/#exercises","title":"Exercises","text":"<p>23.1 A seqlock consists of a lock and a version number. An update operation acquires the lock, increments the version number, makes the changes to the data structure, and then releases the lock. A read-only operation does not use the lock. Instead, it retrieves the version number, reads the data structure, and then checks if the version number has changed. If so, the read-only operation is retried. Use a seqlock to implement a bank much like Exercise 19.2, with one seqlock for the entire bank (i.e., no locks on individual accounts). Method <code>transfer</code> is an update operation; method <code>total</code> is a read-only operation. Explain how a seqlock can lead to starvation.</p>"},{"location":"textbook/ns/","title":"Needham-Schroeder Authentication Protocol","text":"<p>The Needham-Schroeder protocol is a security protocol in which two parties authenticate one another by exchanging large and recently created random numbers called nonces that nobody else should be able to read. The nonces should only be used once for an instantiation of the protocol between honest participants (i.e., participants that follow the protocol). The version we describe here uses public key cryptography: with public key cryptography it is possible to create a message for a particular destination that only that destination can read. We denote with \\(\\langle m \\rangle_p\\) a message m encrypted for p so that only p can decrypt the message and see that it contains m.</p> <p>Suppose Alice wants to communicate with Bob. The three critical steps in the Needham-Schroeder protocol are as follows:</p> <ol> <li> <p>Alice creates a new nonce \\(N_A\\) and sends     \\(\\langle 1, A, N_A \\rangle_\\mathtt{Bob}\\) to Bob;</p> </li> <li> <p>Upon receipt, Bob creates a new nonce \\(N_B\\) and sends     \\(\\langle 2, N_A, N_B \\rangle_\\mathtt{Alice}\\) to Alice;</p> </li> <li> <p>Alice sends \\(\\langle 3, N_B \\rangle_\\mathtt{Bob}\\) to Bob.</p> </li> </ol> <p>When Bob receives \\(\\langle 1, A, N_A \\rangle_\\mathtt{Bob}\\), Bob does not know for sure that the message came from Alice, and even if it came from Alice, it does not know if Alice sent the message recently or if it was replayed by some adversary. When Alice receives \\(\\langle 2, N_A, N_B \\rangle_\\mathtt{Alice}\\), Alice does know that, if Bob is honest, (1) Bob and only Bob could have created this message, and (2) Bob must have done so recently (since Alice created \\(N_A\\)). When Bob receives \\(\\langle 3, N_B \\rangle_\\mathtt{Bob}\\), Bob decides that it is Alice that is trying to communicate at this time. Since Bob created \\(N_B\\) recently and sent it encrypted to Alice, Bob does not have to worry that the type 3 message was an old message that was replayed by some adversary. Also, if Alice is honest, it seems only Alice can have seen the message containing \\(N_B\\).</p> <p>Thus, the intended security properties of this protocol are symmetric. Assuming Alice and Bob are both honest:</p> <ul> <li> <p>if Alice finishes the protocol with Bob and received \\(B_N\\) from Bob,     then nobody but Alice and Bob can learn \\(N_B\\).</p> </li> <li> <p>if Bob finishes the protocol with Alice and received \\(A_N\\) from     Alice, then nobody but Bob and Alice can learn \\(N_A\\).</p> </li> </ul> <p>After the protocol, Alice can include \\(N_A\\) in messages to Bob and Bob can include \\(N_B\\) in messages to Alice to authenticate the sources of those messages to one another.</p> needhamschroeder.hny<pre><code>network = {}\n\ndest = choose({ None, \"Bob\", \"Corey\" })\n\ndef send(msg):\n    atomically network |= { msg }\n\ndef alice():\n    if dest != None:\n        send({ .dst: dest,\n            .contents: { .type: 1, .nonce: \"nonceA\", .initiator: \"Alice\" } })\n        atomically when exists m in network when (m.dst == \"Alice\")\n                    and (m.contents.type == 2) and (m.contents.nonce == \"nonceA\"):\n            send({ .dst: dest, .contents: { .type: 3, .nonce: m.contents.nonce2 } })\n\ndef bob():\n    atomically when exists m in network when (m.dst == \"Bob\")\n                    and (m.contents.type == 1) and (m.contents.initiator == \"Alice\"):\n        send({ .dst: \"Alice\",\n            .contents: { .type: 2, .nonce: m.contents.nonce, .nonce2: \"nonceB\" } })\n    atomically when exists m in network when (m.dst == \"Bob\")\n                    and (m.contents.type == 3) and (m.contents.nonce == \"nonceB\"):\n        assert dest == \"Bob\"\n\ndef corey():\n    var received, nonces, msgs = {}, { \"nonceC\" }, {}\n    while True:\n        atomically when exists m in network - received when m.dst == \"Corey\":\n            received |= { m }\n            nonces |= { m.contents.nonce }\n            if m.contents.type == 2:\n                nonces |= { m.contents.nonce2 }\n            for dst in { \"Alice\", \"Bob\" } for n in nonces:\n                msgs |= {{ .dst: dst, .contents: { .type: 1, .nonce: n, .initiator: ini }}\n                                    for ini in { \"Alice\", \"Bob\" }}\n                msgs |= {{ .dst: dst, .contents: { .type: 2, .nonce: n, .nonce2: n2 }}\n                                    for n2 in nonces }\n                msgs |= {{ .dst: dst, .contents: { .type: 3, .nonce: n }}}\n            send(choose(msgs - network))\n\nspawn alice(); spawn bob()\nspawn eternal corey()\n</code></pre> Figure 32.1 ( code/needhamschroeder.hny):  Needham-Schroeder protocol and an attack  <p>Figure 32.1 shows the protocol implemented in Harmony. A message \\(\\langle m \\rangle_p\\) is encoded in Harmony as a dictionary \\(\\{ \\mathtt{.dst}: p, \\mathtt{.contents}: m \\}\\). The code for Alice and Bob simply follows the steps listed above.</p> <p>Unfortunately, the protocol turns out to be incorrect, but it took 17 years before somebody noticed. Model checking can be used to find the bug. To demonstate the bug, we need to model the environment. In particular, we introduce a third party, which we will call Corey. We want to make sure that Corey cannot impersonate Alice or Bob. However, it is possible that Alice tries to set up an authenticated connection to Corey using the Needham-Schroeder protocol. That in itself should not be a problem if the protocol were correct.</p> <p>The code in Figure 32.1 has Alice either not do anything, or has Alice try to set up a connection to either Bob or Corey. Bob only accepts connections with Alice. Corey, when receiving a message that it can decrypt, will try to find an attack by sending every possible message to every possible destination. In particular, it keeps track of every nonce that it has seen and will try to construct messages with them to send to Alice and Bob. If Bob finishes the protocol, it checks to see if Alice actually tried to connect to Bob. If not, the assertion fails and an attack is found.</p> <p>Running the code in Figure 32.1 quickly finds a viable attack. The attack goes like this:</p> <ol> <li> <p>Alice creates a new nonce \\(N_A\\) and sends     \\(\\langle 1, A, N_A \\rangle_\\mathtt{Corey}\\) to Corey;</p> </li> <li> <p>Upon receipt, Corey sends \\(\\langle 1, A, N_A \\rangle_\\mathtt{Bob}\\)     to Bob;</p> </li> <li> <p>Upon receipt, Bob, believing it is engaging in the protocol with     Alice, creates a new nonce \\(N_B\\) and sends     \\(\\langle 2, N_A, N_B \\rangle_\\mathtt{Alice}\\) to Alice;</p> </li> <li> <p>Alice thinks the message came from Corey (because it contains \\(N_A\\),     which Alice created for Corey and sent to Corey) and sends     \\(\\langle 3, N_B \\rangle_\\mathtt{Corey}\\) to Corey.</p> </li> <li> <p>Corey learns \\(N_B\\) and sends \\(\\langle 3, N_B \\rangle_\\mathtt{Bob}\\)     to Bob.</p> </li> <li> <p>Bob receiving \\(\\langle 3, N_B \\rangle_\\mathtt{Bob}\\) is identical to     the situation in which Alice tried to set up a connection to Bob, so     Bob now thinks it is talking to Alice, even though Alice never tried     to communicate with Bob.</p> </li> </ol> <p>The security property is violated. In particular, Bob, duped by Corey, finished the protocol with Alice and received \\(A_N\\), and even though Bob and Alice are both honest, Corey has a copy of \\(A_N\\). So, Corey is now able to impersonate Alice to Bob (but not vice versa because Alice did not try to authenticate Bob).</p>"},{"location":"textbook/ns/#exercises","title":"Exercises","text":"<p>32.1 Figure out how to fix the protocol.</p> <p>32.2 There were two versions of the Needham-Schroeder protocol: the Symmetric Key protocol and the Public Key protocol. In this chapter we only discussed the latter, but the former also had a problem. See if you can find it using Harmony.</p>"},{"location":"textbook/paxos/","title":"Paxos","text":"<p>Paxos is the most well-known family of consensus protocols for environments in which few or no assumptions are made about timing. In this chapter, we present a basic version of a Paxos protocol, one that is single-decree (only tries to make a single decision). It uses two kinds of processors: leaders and acceptors. In order to tolerate <code>F</code> crash failures, you need at least <code>F</code> + 1 leaders and \\(2\\texttt{F} + 1\\) acceptors, but leaders and acceptors can be colocated, so in total only \\(2\\texttt{F} + 1\\) independently failing processors are needed. Here we provide only a rudimentary introduction to Paxos; for more detailed information refer to.</p> <p>As in the consensus protocol of Chapter 29, Paxos uses rounds of messaging. The communication pattern, however, is different. Similar to the atomic read/write register protocol in Chapter 28, Paxos uses two kinds of rounds: \"Phase 1\" and \"Phase 2\" rounds. Rounds are identified by a so-called ballot number combined with the phase number. Different leaders are in charge of different ballot numbers. Leaders broadcast \"Type A\" messages to the acceptors, which respond point-to-point with \"Type B\" messages.</p> paxos.hny<pre><code>import bag\n\nconst F = 1\nconst NACCEPTORS = (2 * F) + 1\nconst NLEADERS = F + 1\nconst NBALLOTS = 2\n\nnetwork = bag.empty()\n\nproposals = [ choose({0, 1}) for i in {0..NLEADERS-1} ]\n\ndef send(msg):\n    atomically network = bag.add(network, msg)\n\ndef receive(ballot, phase) returns quorum:\n    let msgs = { e:c for (b,p,t,e):c in network\n                        where (b,p,t) == (ballot, phase, \"B\") }:\n        quorum = bag.combinations(msgs, NACCEPTORS - F)\n\ndef leader(self, proposal):\n    var ballot, estimate = self, proposal\n    send(ballot, 1, \"A\", None)\n    while ballot &lt;= NBALLOTS:\n        atomically when exists quorum in receive(ballot, 1):\n            let accepted = { e for e:_ in quorum where e != None }:\n                if accepted != {}:\n                    _, estimate = max(accepted)\n            send(ballot, 2, \"A\", estimate)\n        atomically when exists quorum in receive(ballot, 2):\n            if bag.multiplicity(quorum, (ballot, estimate)) == (NACCEPTORS - F):\n                assert estimate in proposals    # validity\n                print estimate\n            ballot += NLEADERS\n            if ballot &lt;= NBALLOTS:\n                send(ballot, 1, \"A\", None)\n\ndef acceptor():\n    var ballot, last_accepted, received = 0, None, {}\n    while True:\n        atomically when exists b,p,e in { (b,p,e) for b,p,t,e:_ in network\n                    where ((b,p) not in received) and (t == \"A\") }:\n            received |= { (b, p) }\n            if b &gt;= ballot:\n                ballot = b\n                if p == 2:\n                    last_accepted = (ballot, e)\n            send(b, p, \"B\", last_accepted)\n\nprint proposals\nfor i in {0..NLEADERS - 1}:\n    spawn leader(i + 1, proposals[i])\nfor i in {1..NACCEPTORS}:\n    spawn eternal acceptor()\n</code></pre> Figure 31.1 (code/paxos.hny):  A version of the Paxos protocol <p>Figure 31.1 contain the code for this Paxos protocol. Paxos is perhaps best understood starting with the second phase. At the end of the first phase, the leader broadcasts a <code>2.A</code> message (Phase 2, Type A) to the acceptors containing the ballot number and a proposal and then waits for <code>N</code> -- <code>F</code> matching <code>2.B</code> responses from the acceptors. If each response contains the ballot number and the proposal, then the proposal is deemed decided. But one or more of the responses can contain a higher ballot number, in which case the leader has to try again with an even higher ballot number. This is where the first phase comes in.</p> <p>It is not possible that an acceptor responds with a smaller ballot number. This is because acceptors maintain two state variables. One is ballot, the highest ballot number they have seen. Second is a variable called last_accepted that, if not <code>None</code>, contains the last proposal the acceptor has accepted and the corresponding ballot number. The acceptor also contains a set received that contains (ballot, phase) tuples identifiying all rounds that the ballot has already participated in. An acceptor waits for a message for a round that is not in received. If its ballot number is higher than what it has seen before, the acceptor moves into that ballot. If the phase is\u00a02, then the acceptor accepts the proposal and remembers when it did so by saving the (ballot, proposal) tuple in last_accepted. In all cases, the acceptor responds with the current values of ballot and last_accepted.</p> <p>In its first phase, a leader of a ballot must come up with a proposal that cannot conflict with a proposal of an earlier ballot that may already have been decided. To this end, the leader broadcasts a <code>2.A</code> message to the acceptors and awaits <code>N</code> -- <code>F</code> of their last_accepted values. If all those acceptors responded with <code>None</code>, then the leader is free to choose its own proposal. Otherwise the leader updates its proposal with the one corresponding to the highest ballot number. The leader then moves on to the second round.</p> <p>To run and check the Paxos code, do the following (leveraging the consensus specification of Figure 30.1):</p> <pre><code>$ harmony -o consensus.hfa -cN=2 code/consensus.hny\n$ harmony -B consensus.hfa code/paxos.hny\n</code></pre> <p>You should get a warning that our implementation of Paxos does not generate all possible behaviors. This is because we only run the protocol for a finite number of ballots, and therefore at least one of the ballots will be successful. With an unlimited number of ballots, Paxos may never decide unless you make some liveness assumptions.</p>"},{"location":"textbook/paxos/#exercises","title":"Exercises","text":"<p>31.1 Perhaps the trickiest detail of the algorithm is that, in Line\u00a029 of Figure 31.1, the leader selects the proposal with the highest ballot number it receives. Replace the <code>max</code> operator in that statement with choose and see if it finds a problem. First try with \\(\\texttt{NBALLOTS} = 2\\) and then with \\(\\texttt{NBALLOTS} = 3\\). (Warning, the latter may take a long time.) If it finds a problem, analyze the output and see what went wrong.</p> <p>31.2 Missing Link: paxosbroken.hny discusses a buggy version of Paxos. In this version, the responses to the second phase are matched not by ballot number but by the value of the proposal. Implement this version and, using Harmony, find the problem this causes.</p>"},{"location":"textbook/peterson/","title":"Peterson's Algorithm","text":"Peterson.hny<pre><code>sequential flags, turn\n\nflags = [ False, False ]\nturn = choose({0, 1})\n\ndef thread(self):\n    while choose({ False, True }):\n        # Enter critical section\n        flags[self] = True\n        turn = 1 - self\n        await (not flags[1 - self]) or (turn == self)\n\n        # Critical section is here\n        cs: assert countLabel(cs) == 1\n\n        # Leave critical section\n        flags[self] = False\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> Figure 6.1 (code/Peterson.hny):  Peterson's Algorithm  <p>In 1981, Gary L.\u00a0Peterson came up with a beautiful solution to the mutual exclusion problem, now known as \"Peterson's Algorithm\". The algorithm is an amalgam of the (incorrect) algorithms in Figure 5.4 and Figure 5.5, and is presented in Figure 6.1. (The first line specifies that the flags and turn variables are assumed to satisfy sequential consistency---it prevents Harmony from complaining about data races involving these variables, explained in Chapter 9.)</p> <p>A thread first indicates its interest in entering the critical section by setting its flag. It then politely gives way to the other thread should it also want to enter the critical section---if both do so at the same time one will win because writes to memory in Harmony are atomic. The thread continues to be polite, waiting until either the other thread is nowhere near the critical section (flag[1 -- self] = <code>False</code>) or has given way (turn = self). Running the algorithm with Harmony shows that it satisfies both mutual exclusion and progress.</p> <p> </p> Figure 6.2 (Venn diagram classifying all states and a trace  <p>Why does it work? We will focus here on how one might go about proving mutual exclusion for an algorithm such as Peterson's. It turns out that doing so is not easy. If you are interested in learning more about concurrent programming but not necessarily in how to prove concurrent programs correct, you may choose to skip the rest of this chapter. If you are still here, you have to understand a little bit more about how the Harmony virtual machine (HVM) works. In Chapter 4 we talked about the concept of state: at any point in time the HVM is in a specific state. A state is comprised of the values of the shared variables as well as the values of the thread variables of each thread, including its program counter and the contents of its stack. Each time a thread executes a HVM machine instruction, the state changes (if only because the program counter of the thread changes). We call that a step. Steps in Harmony are atomic.</p> <p>The HVM starts in an initial state in which there is only one thread (<code>__init__</code>()) and its program counter is\u00a00. A trace is a sequence of steps starting from the initial state, resulting in a sequence of states. When making a step, there are two sources of non-determinism in Harmony. One is when there is more than one thread that can make a step. The other is when a thread executes a choose operation and there is more than one choice. Because there is non-determinism, there are multiple possible traces. We call a state reachable if it is either the initial state or it can be reached from the initial state through a finite trace. A state is final when there are no threads left to make state changes.</p> <p>It is often useful to classify states. Initial, final, and reachable, and unreachable are all examples of classes of states. Figure 6.2 depicts a Venn diagram of various classes of states and a trace. One way to classify states is to define a predicate over states. All states in which x = 1, or all states where there are two or more threads executing, are examples of such predicates. For our purposes, it is useful to define a predicate that says that at most one thread is in the critical section. We shall call such states exclusive.</p> <p>An invariant of a program is a predicate that holds over all states that are reachable by that program. We want to show that exclusivity is an invariant because mutual exclusion means that all reachable states are exclusive. In other words, we want to show that the set of reachable states of executing the program is a subset of the set of states where there is at most one thread in the critical section.</p> <p>One way to prove that a predicate is an invariant is through induction on the number of steps. First you prove that the predicate holds over the initial state. Then you prove that for every reachable state, and for every step from that reachable state, the predicate also holds over the resulting state. For this to work you would need a predicate that describes exactly which states are reachable. But we do not have such a predicate: we know how to define the set of reachable states inductively, but---given an arbitrary state---it is not easy to see whether it is reachable or not.</p> <p>To solve this problem, we will use what is called an inductive invariant. An inductive invariant\u00a0\\(\\mathcal{I}\\) is a predicate over states that satisfies the following:</p> <ul> <li> <p>\\(\\mathcal{I}\\) holds in the initial state.</p> </li> <li> <p>For any state in which \\(\\mathcal{I}\\) holds (including unreachable     ones) and for any thread in the state, if the thread takes a step,     then \\(\\mathcal{I}\\) also holds in the resulting state.</p> </li> </ul> <p>One candidate for such a predicate is exclusivity itself. After all, it certainly holds over the initial state. And as Harmony has already determined, exclusivity is an invariant: it holds over every reachable state. Unfortunately, exclusivity is not an inductive invariant. To see why, consider the following state s: let thread\u00a00 be at label <code>cs</code> and thread\u00a01 be at the start of the await statement. Also, in state s, \\(\\mathit{turn} = 1\\). Now let thread\u00a01 make a step. Because \\(\\mathit{turn} = 1\\), thread\u00a01 will stop waiting and also enter the critical section, entering a state that is not exclusive. So, exclusivity is an invariant (holds over every reachable state, as demonstrated by Harmony), but not an inductive invariant. It will turn out that s is not reachable.</p> <p>We are looking for an inductive invariant that implies exclusivity. In other words, the set of states where the inductive invariant holds must be a subset of the set of states where there is at most one thread in the critical section.</p> <p>Let us begin with considering the following important property: \\(\\mathcal{F}(i) = \\mathtt{thread}(i)@[10 \\cdots 17] \\Rightarrow \\mathit{flags}[i]\\), that is, if thread\u00a0i is executing in lines 10 through 17, then \\(\\mathit{flags}[i]\\) is set. Although it does not, by itself, imply exclusivity, we can show that \\(\\mathcal{F}(i)\\) is an inductive invariant (for both threads\u00a00 and\u00a01). To wit, it holds in the initial state, because in the initial state thread i does not even exist yet. Now we have to show that if \\(\\mathcal{F}(i)\\) holds in some state, then \\(\\mathcal{F}(i)\\) also holds in a next state. Since only thread\u00a0i ever changes \\(\\mathit{flags}[i]\\), we only need to consider steps by thread\u00a0i. Since \\(\\mathcal{F}(i)\\) holds, there are two cases to consider:</p> <ol> <li> <p>states in which \\(\\mathit{flags}[i] = \\texttt{true}\\)</p> </li> <li> <p>states in which \\(\\lnot \\mathtt{thread}(i)@[10 \\cdots 17]\\) (because     false implies anything)</p> </li> </ol> <p>In each case, we need to show that if thread i takes a step, then \\(\\mathcal{F}(i)\\) still holds. In the first case, there is only one step that thread i can take that would set \\(\\mathit{flags}[i]\\) to false: the step from line 17 to line 18. But executing the line would also take the thread out of lines \\(10 \\cdots 17\\), so \\(\\mathcal{F}(i)\\) continues to hold. In the second case (thread\u00a0i is not executing in lines \\(10 \\cdots 17\\)), the only step that would cause thread\u00a0i to execute in lines \\(10 \\cdots 17\\) would be the step in line 9. But in that case \\(\\mathit{flags}[i]\\) would end up being true, so \\(\\mathcal{F}(i)\\) continues to hold as well. So, \\(\\mathcal{F}(i)\\) is an inductive invariant (for both threads\u00a00 and\u00a01).</p> <p>While \\(\\mathcal{F}(i)\\) does not imply mutual exclusion, it does imply the following useful invariant: \\(\\mathtt{thread}(i)@cs \\Rightarrow \\mathit{flags}[i]\\): when thread i is at the critical section, \\(\\mathit{flags}[i]\\) is set. This seems obvious from the code, but now you know how to prove it. We will use a similar technique to prove the exclusivity is invariant.</p> <p>We need a stronger inductive invariant than \\(\\mathcal{F}(i)\\) to prove mutual exclusion. What else do we know when thread i is in the critical section? Let \\(\\mathcal{C}(i) = \\lnot\\mathit{flags}[1 - i] \\lor \\mathit{turn} = i\\), that is, the condition on the await statement for thread\u00a0i. In a sequential program, \\(\\mathcal{C}(i)\\) would clearly hold if thread i is in the critical section: \\(\\mathtt{thread}(i)@cs \\Rightarrow \\mathcal{C}(i)\\). However, because thread \\(1-i\\) is executing concurrently, this property does not hold. You can use Harmony to verify this. Just place the following command in the critical section of the program:</p> <p>assert (not flags[1 -- self]) or (turn == self)</p> PetersonInductive.hny<pre><code>sequential flags, turn\n\nflags = [ False, False ]\nturn = choose({0, 1})\n\ndef thread(self):\n    while choose({ False, True }):\n        # Enter critical section\n        flags[self] = True\n        gate: turn = 1 - self\n        await (not flags[1 - self]) or (turn == self)\n\n        # Critical section\n        cs: assert (not flags[1 - self]) or (turn == self) or (countLabel(gate) == 1)\n\n        # Leave critical section\n        flags[self] = False\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> Figure 6.3 ( code/PetersonInductive.hny):  Peterson's Algorithm with Inductive Invariant  <p>When running Harmony, this assertion will fail. You can check the HTML output to see what happened. Suppose thread 0 is at the critical section, \\(\\mathit{flags}[0]\\) = true, \\(\\mathit{turn} = 1\\), and thread 1 just finished the step in line 7, setting \\(\\mathit{flags}[1]\\) to true. Then \\(C(0)\\) is violated. But it suggests a new property: \\(\\mathcal{G}(i) = \\mathtt{thread}(i)@\\mathtt{cs} \\Rightarrow \\mathcal{C}(i) \\lor \\mathtt{thread}(1-i)@10\\). That is, if thread i is at the critical section, then either \\(\\mathcal{C}(i)\\) holds or thread \\(1-i\\) is about to execute line 10. Figure 6.3 formalizes \\(\\mathcal{G}(i)\\) in Harmony. The label <code>gate</code> refers to line 10, that is, the step that sets turn to \\(1-i\\). You can run Figure 6.3 to determine that \\(\\mathcal{G}(i)\\) is an invariant for \\(i = 0, 1\\). Moreover, if \\(\\mathcal{F}(i)\\) and \\(\\mathcal{G}(i)\\) both hold for \\(i = 0, 1\\), then mutual exclusion holds. We can show this using proof by contradiction. Suppose mutual exclusion is violated and thus both threads are in the critical section. By \\(\\mathcal{F}\\) it must be the case that both flags are true. By \\(\\mathcal{G}\\) and the fact that neither thread is at label <code>gate</code>, we know that both \\(C(0)\\) and \\(C(1)\\) must hold. This then implies that \\(\\mathit{turn} = 0 \\land \\mathit{turn} = 1\\), providing the desired contradiction.</p> <p>We claim that \\(\\mathcal{G}(i)\\) is an inductive invariant. First, since neither thread in in the critical section in the initial state, it is clear that \\(\\mathcal{G}(i)\\) holds in the initial state. Without loss of generality, suppose \\(i=0\\) (a benefit from the fact that the algorithm is symmetric for both threads). We still have to show that if we are in a state in which \\(\\mathcal{G}(0)\\) holds, then any step will result in a state in which \\(\\mathcal{G}(0)\\) still holds.</p> <p>First consider the case that thread\u00a00 is at label <code>cs</code>. If thread\u00a00 were to take a step, then in the next state thread\u00a00 would be no longer at that label and \\(\\mathcal{G}(0)\\) would hold trivially over the next state. Therefore we only need to consider a step by thread\u00a01. From \\(\\mathcal{G}\\) we know that one of the following three cases must hold before thread\u00a01 takes a step:</p> <ol> <li> <p>flags[1] = <code>False</code>;</p> </li> <li> <p>turn = 0;</p> </li> <li> <p>thread\u00a01 is at label <code>gate</code>.</p> </li> </ol> <p>Let us consider each of these cases. We have to show that if thread\u00a01 takes a step, then one of those cases must hold after the step. In the first case, if thread\u00a01 takes a step, there are two possibilities: either \\(flags[1]\\) will still be <code>False</code> (in which case the first case continues to hold), or \\(flags[1]\\) will be <code>True</code> and thread\u00a01 will be at label <code>gate</code> (in which case the third case will hold). We know that thread\u00a01 never sets turn to 1, so if the second case holds before the step, it will also hold after the step. Finally, if thread\u00a01 is at label <code>gate</code> before the step, then after the step turn will equal 0, and therefore the second case will hold after the step.</p> <p>Now consider the case where thread\u00a00 is not in the critical section, and therefore \\(\\mathcal{G}(0)\\) holds trivially because false implies anything. There are three cases to consider:</p> <ol> <li> <p>Thread\u00a01 takes a step. But then thread\u00a00 is still not in the     critical section and \\(\\mathcal{G}(0)\\) continues to hold;</p> </li> <li> <p>Thread\u00a00 takes a step but still is not in the critical section. Then     again \\(\\mathcal{G}(0)\\) continues to hold.</p> </li> <li> <p>Thread\u00a00 takes a step and ends up in the critical section. Because     thread\u00a00 entered the critical section, we know that     \\(\\mathit{flags}[1] = \\texttt{False}\\) or \\(\\mathit{turn} = 0\\) because     of the <code>await</code> condition. And hence \\(\\mathcal{G}(0)\\) continues to     hold in that case as well.</p> </li> </ol> <p>We have now demonstrated mutual exclusion in Peterson's Algorithm in two different ways: one by letting Harmony explore all possible executions, the other using inductive invariants and proof by induction. The former is certainly easier, but it does not provide intuition for why the algorithm works. The second provides much more insight.</p> <p>Even though they are not strictly necessary, we encourage you to include invariants in your Harmony code. They can provide important insights into why the code works.</p> <p>A cool anecdote is the following. When the author of Harmony had to teach Peterson's Algorithm, he refreshed his memory by looking at the Wikipedia page. The page claimed that the following predicate is invariant: if thread i is in the critical section, then \\(\\mathcal{C}(i)\\) (i.e., \\(\\mathcal{G}\\) without the disjunct that thread \\(1-i\\) is at label <code>gate</code>). We already saw that this is not an invariant. (The author fixed the Wikipedia page with the help of Fred B.\u00a0Schneider.)</p> <p>This anecdote suggests the following. If you need to do a proof by induction of an algorithm, you have to come up with an inductive invariant. Before trying to prove the algorithm, you can check that the predicate is at least invariant by testing it using Harmony. Doing so could potentially avoid wasting your time on a proof that will not work because the predicate is not invariant, and therefore not an inductive invariant either. Moreover, analyzing the counterexample provided by Harmony may well suggest how to fix the predicate.</p>"},{"location":"textbook/peterson/#exercises","title":"Exercises","text":"csonebit.hny<pre><code>sequential flags\n\nflags = [ False, False ]\n\ndef thread(self):\n    while choose({ False, True }):\n        # Enter critical section\n        flags[self] = True\n        while flags[1 - self]:\n            flags[self] = False\n            flags[self] = True\n\n        # Critical section\n        cs: assert countLabel(cs) == 1\n\n        # Leave critical section\n        flags[self] = False\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> Figure 6.4 (code/csonebit.hny):  Mutual exclusion using a flag per thread  <p>6.1 Figure 6.4 presents another solution to the mutual exclusion problem. It is similar to the one in Figure 5.4, but has a thread back out and try again if it finds that the other thread is either trying to enter the critical section or already has. Compare this algorithm with Peterson's. Why does Harmony complain about active busy waiting?</p> <p>6.2 Can you find one or more inductive invariants for the algorithm in Figure 6.4 to prove it correct? Here's a pseudo-code version of the algorithm to help you. Each line is an atomic action:</p> <pre><code>    initially: flagX = flagY = False\n\n    thread X:                          thread Y:\n        X0: flagX = True                   Y0: flagY = True\n        X1: if not flagY goto X4           Y1: if not flagX goto Y4\n        X2: flagX = False                  Y2: flagY = False\n        X3: goto X0                        Y3: goto Y0\n        X4: ...critical section...         Y4: ...critical section...\n        X5: flagX = False                  Y5: flagY = False\n</code></pre> <p>6.3 A colleague of the author asked if the first two assignments in Peterson's algorithm (setting flags[self] to <code>True</code> and turn to 1 -- self can be reversed. After all, they are different variables assigned independent values---in a sequential program one could surely swap the two assignments. See if you can figure out for yourself if the two assignments can be reversed. Then run the program in Figure 6.1 after reversing the two assignments and describe in English what happens.</p> <p>6.4 Bonus question: Can you generalize Peterson's algorithm to more than two threads?</p> <p>6.5 Bonus question: Implement Dekker's Algorithm, Eisenstein and McGuire's Algorithm, Szyma\u0144ski's Algorithm, or the Lamport's Bakery Algorithm. Note that the last one uses unbounded state, so you should modify the threads so they only try to enter the critical section a bounded number of times.</p>"},{"location":"textbook/sbs/","title":"Split Binary Semaphores","text":"<p>The Split Binary Semaphore (SBS) approach is a general technique for implementing conditional waiting. It was originally proposed by Tony Hoare and popularized by Edsger Dijkstra. A binary semaphore is a generalization of a lock. While a lock is always initialized in the released state, a binary semaphore---if so desired---can be initialized in the acquired state. SBS is an extension of a critical section that is protected by a lock. If there are \\(n\\) waiting conditions, then SBS uses \\(n+1\\) binary semaphores to protect the critical section. An ordinary critical section has no waiting conditions and therefore uses just one binary semaphore (because \\(n = 0\\)). But, for example, a bounded buffer has two waiting conditions:</p> <ol> <li> <p>consumers waiting for the buffer to be non-empty;</p> </li> <li> <p>producers waiting for an empty slot in the buffer.</p> </li> </ol> <p>So, it will require 3 binary semaphores if the SBS technique is applied.</p> <p>Think of each of these binary semaphores as a gate that a thread must go through in order to enter the critical section. A gate is either open or closed. Initially, exactly one gate, the main gate, is open. Each of the other gates, the waiting gates, is associated with a waiting condition. When a gate is open, one thread can enter the critical section, closing the gate behind it.</p> <p>When leaving the critical section, the thread must open exactly one of the gates, but it does not have to be the gate that it used to enter the critical section. In particular, when a thread leaves the critical section, it should check for each waiting gate if its waiting condition holds and if there are threads trying to get through the gate. If there is such a gate, then it must select one and open that gate. If there is no such gate, then it must open the main gate.</p> <p>Finally, if a thread is executing in the critical section and needs to wait for a particular condition, then it leaves the critical section and waits for the gate associated with that condition to open.</p> <p>The following invariants hold:</p> <ul> <li> <p>At any time, at most one gate is open;</p> </li> <li> <p>If some gate is open, then no thread is in the critical section.     Equivalently, if some thread is in the critical section, then all     gates are closed;</p> </li> <li> <p>At any time, at most one thread is in the critical section.</p> </li> </ul> <p>The main gate is implemented by a binary semaphore, initialized in the released state (signifying that the gate is open). The waiting gates each consist of a pair: a counter that counts how many threads are waiting behind the gate and a binary semaphore initialized in the acquired state (signifying that the gate is closed).</p> RWsbs.hny<pre><code>from synch import BinSema, acquire, release\n\ndef RWlock() returns lock:\n    lock = {\n            .nreaders: 0, .nwriters: 0, .mutex: BinSema(False),\n            .r_gate: { .sema: BinSema(True), .count: 0 },\n            .w_gate: { .sema: BinSema(True), .count: 0 }\n        }\n\ndef _release_one(rw):\n    if (rw-&gt;nwriters == 0) and (rw-&gt;r_gate.count &gt; 0):\n        release(?rw-&gt;r_gate.sema)\n    elif ((rw-&gt;nreaders + rw-&gt;nwriters) == 0) and (rw-&gt;w_gate.count &gt; 0):\n        release(?rw-&gt;w_gate.sema)\n    else:\n        release(?rw-&gt;mutex)\n\ndef read_acquire(rw):\n    acquire(?rw-&gt;mutex)\n    if rw-&gt;nwriters &gt; 0:\n        rw-&gt;r_gate.count += 1; _release_one(rw)\n        acquire(?rw-&gt;r_gate.sema); rw-&gt;r_gate.count -= 1\n    rw-&gt;nreaders += 1\n    _release_one(rw)\n\ndef read_release(rw):\n    acquire(?rw-&gt;mutex); rw-&gt;nreaders -= 1; _release_one(rw)\n\ndef write_acquire(rw):\n    acquire(?rw-&gt;mutex)\n    if (rw-&gt;nreaders + rw-&gt;nwriters) &gt; 0:\n        rw-&gt;w_gate.count += 1; _release_one(rw)\n        acquire(?rw-&gt;w_gate.sema); rw-&gt;w_gate.count -= 1\n    rw-&gt;nwriters += 1\n    _release_one(rw)\n\ndef write_release(rw):\n    acquire(?rw-&gt;mutex); rw-&gt;nwriters -= 1; _release_one(rw)\n</code></pre> Figure 16.1 (code/RWsbs.hny):  Reader/Writer Lock using Split Binary Semaphores  <p>We will illustrate the technique using the reader/writer problem. Figure 16.1 shows code. The first step is to enumerate all waiting conditions. In the case of the reader/writer problem, there are two: a thread that wants to read may have to wait for a writer to leave the critical section, while a thread that wants to write may have to wait until all readers have left the critical section or until a writer has left. The state of a reader/writer lock thus consists of the following:</p> <ul> <li> <p>nreaders: the number of readers in the critical section;</p> </li> <li> <p>nwriters: the number of writers in the critical section (0 or 1);</p> </li> <li> <p>mutex: the main gate binary semaphore;</p> </li> <li> <p>r_gate: the waiting gate used by readers, consisting of a binary     semaphore and the number of readers waiting to enter;</p> </li> <li> <p>w_gate: the waiting gate used by writers, similar to the readers'     gate.</p> </li> </ul> <p>Each of the <code>read_acquire</code>, <code>read_release</code>, <code>write_acquire</code>, and <code>write_release</code> methods must maintain this state. First they have to acquire the mutex (i.e., enter the main gate). After acquiring the mutex, <code>read_acquire</code> and <code>write_acquire</code> each must check to see if the thread has to wait. If so, it increments the count associated with its respective gate, opens a gate (using method <code>_release_one</code>), and then blocks until its waiting gate opens up.</p> <p><code>_release_one</code>() is the function that a thread uses when leaving the critical section. It must check to see if there is a waiting gate that has threads waiting behind it and whose condition is met. If so, it selects one and opens that gate. In the given code, <code>_release_one</code>() first checks the readers' gate and then the writers' gate, but the other way around works as well. If neither waiting gate qualifies, then <code>_release_one</code>() has to open the main gate (i.e., release mutex).</p> <p>Let us examine <code>read_acquire</code> more carefully. First, the method acquires mutex. Then, in the case that the thread finds that there is a writer in the critical section (\\(\\mathit{nwriters &gt; 0}\\)), it increments the counter associated with the readers' gate, leaves the critical section (<code>_release_one</code>), and then tries to acquire the binary semaphore associated with the waiting gate. This causes the thread to block until some other thread opens that gate.</p> <p>Now consider the case where there is a writer in the critical section and there are two readers waiting. Let us see what happens when the writer calls <code>write_release</code>:</p> <ol> <li> <p>After acquiring mutex, the writer decrements nwriters, which     must be 1 at this time, and thus becomes 0.</p> </li> <li> <p>It then calls <code>_release_one</code>(). <code>_release_one</code>() finds that there are     no writers in the critical section and there are two readers     waiting. It therefore releases not mutex but the readers' gate's     binary semaphore.</p> </li> <li> <p>One of the waiting readers can now re-enter the critical section.     When it does, the reader decrements the gate's counter (from 2 to 1)     and increments nreaders (from\u00a00 to\u00a01). The reader finally calls     <code>_release_one</code>().</p> </li> <li> <p>Again, <code>_release_one</code>() finds that there are no writers and that     there are readers waiting, so again it releases the readers'     semaphore.</p> </li> <li> <p>The second reader can now enter the critical section. It decrements     the gate's count from 1 to 0 and increments nreaders from\u00a01 to\u00a02.</p> </li> <li> <p>Finally, the second reader calls <code>_release_one</code>(). This time     <code>_release_one</code>() does not find any threads waiting, and so it     releases mutex. There are now two reader threads that are holding     the reader/writer lock.</p> </li> </ol>"},{"location":"textbook/sbs/#exercises","title":"Exercises","text":"<p>16.1 Several of the calls to <code>_release_one</code>() in Figure 16.1 can be replaced by simply releasing mutex. Which ones?</p> <p>16.2 Optimize your solutions to Exercise 11.1 to use reader/writer locks.</p> <p>16.3 Implement a solution to the producer/consumer problem using split binary semaphores.</p> <p>16.4 Using busy waiting, implement a \"bound lock\" that allows up to <code>M</code> threads to acquire it at the same time.[^3] A bound lock with <code>M = 1</code> is an ordinary lock. You should define a constant <code>M</code> and two methods: <code>acquire_bound_lock</code>() and <code>release_bound_lock</code>(). (Bound locks are useful for situations where too many threads working at the same time might exhaust some resource such as a cache.)</p> <p>16.5 Write a test program for your bound lock that checks that no more than <code>M</code> threads can acquire the bound lock.</p> <p>16.6 Write a test program for bound locks that checks that up to <code>M</code> threads can acquire the bound lock at the same time.</p> gpu.hny<pre><code>const N = 10\n\navailGPUs = {1..N}\n\ndef gpuAlloc() returns gpu:\n    gpu = choose(availGPUs)\n    availGPUs -= { result }\n\ndef gpuRelease(gpu):\n    availGPUs |= { gpu }\n</code></pre> Figure 16.2 (code/gpu.hny):  A thread-unsafe GPU allocator  <p>16.7 Implement a thread-safe GPU allocator by modifying Figure 16.2. There are <code>N</code> GPUs identified by the numbers 1 through <code>N</code>. Method <code>gpuAlloc</code>() returns the identifier of an available GPU, blocking if there is currently no GPU available. Method <code>gpuRelease</code>(gpu) releases the given GPU. It never needs to block.</p> <p>16.8 With reader/writer locks, concurrency can be improved if a thread downgrades its write lock to a read lock when its done writing but not done reading. Add a downgrade method to the code in Figure 16.1. (Similarly, you may want to try to implement an upgrade of a read lock to a write lock. Why is this problematic?)</p> <p>16.9 Cornell\u2019s campus features some one-lane bridges. On a one-lane bridge, cars can only go in one direction at a time. Consider northbound and southbound cars wanting to cross a one-lane bridge. The bridge allows arbitrary many cars, as long as they're going in the same direction. Implement a lock that observes this requirement using SBS. Write methods <code>OLBlock()</code> to create a new \"one lane bridge\" lock, <code>nb_enter</code>() that a car must invoke before going northbound on the bridge and <code>nb_leave</code>() that the car must invoke after leaving the bridge. Similarly write <code>sb_enter</code>() and <code>sb_leave</code>() for southbound cars.</p> <p>16.10 Extend the solution to Exercise 16.9 by implementing the requirement that at most \\(n\\) cars are allowed on the bridge. Add \\(n\\) as an argument to <code>OLBlock</code>.</p>"},{"location":"textbook/specification/","title":"Specification","text":"<p>So far, we have used Harmony to implement various algorithms. But Harmony can also be used to specify what an algorithm is supposed to do. For example, Figure 8.1 specifies the intended behavior of a lock. In this case, a lock is a boolean, initially <code>False</code>, with two operations, <code>acquire()</code> and <code>release()</code>. The <code>acquire()</code> operation waits until the lock is <code>False</code> and then sets it to <code>True</code> in an atomic operation. The <code>release()</code> operation sets the lock back to <code>False</code>. The code is similar to Figure 5.3, except that waiting for the lock to become available and taking it is executed as an atomic operation.</p> synch.hny<pre><code>import list\nimport bag\n\ndef tas(lk):\n    atomically:\n        result = !lk\n        !lk = True\n\ndef cas(p, old, new):\n    atomically:\n        result = !p == old\n        if result:\n            !p = new\n\ndef BinSema(acquired):\n    result = acquired\n\ndef Lock():\n    result = BinSema(False)\n\ndef acquired(binsema):\n    result = !binsema\n\ndef acquire(binsema):\n    atomically when not !binsema:\n        !binsema = True\n\ndef release(binsema):\n    assert !binsema\n    atomically !binsema = False\n\ndef held(binsema):\n    result = !binsema\n\ndef Condition():\n    result = bag.empty()\n\ndef wait(c, lk):\n    var cnt = 0\n    let (), ctx = save():\n        atomically:\n            cnt = bag.multiplicity(!c, ctx)\n            !c = bag.add(!c, ctx)\n            !lk = False\n        atomically when (not !lk) and (bag.multiplicity(!c, ctx) &lt;= cnt):\n            !lk = True\n\ndef notify(c):\n    atomically if !c != bag.empty():\n        !c = bag.remove(!c, bag.bchoose(!c))\n\ndef notifyAll(c):\n    atomically !c = bag.empty()\n\ndef Semaphore(cnt):\n    result = cnt\n\ndef P(sema):\n    atomically when !sema &gt; 0:\n        !sema -= 1\n\ndef V(sema):\n    atomically !sema += 1\n\ndef Queue():\n    result = []\n\ndef get(q):\n    atomically when !q != []:\n        result = list.head(!q)\n        !q = list.tail(!q)\n\ndef put(q, item):\n    atomically !q = list.append(!q, item)\n</code></pre> Figure 8.1 (modules/synch.hny):  Specification of a lock  cssynch.hny<pre><code>import synch\n\nconst NTHREADS = 2\n\nlock = synch.Lock()\n\ndef thread():\n    while choose({ False, True }):\n        synch.acquire(?lock)\n        cs: assert countLabel(cs) == 1\n        synch.release(?lock)\n\nfor i in {1..NTHREADS}:\n    spawn thread()\n</code></pre> Figure 8.2 (code/cssynch.hny):  Using a lock to implement a critical section UpLock.hny<pre><code>from synch import Lock, acquire, release\n\nsequential done\n\ncount = 0\ncountlock = Lock()\ndone = [ False, False ]\n\ndef thread(self):\n    acquire(?countlock)\n    count = count + 1\n    release(?countlock)\n    done[self] = True\n    await done[1 - self]\n    assert count == 2\n\nspawn thread(0)\nspawn thread(1)\n</code></pre> Figure 8.3 (code/UpLock.hny):  Figure 3.2 fixed with a lock  <p>The code in Figure 8.1 is similar to the code in Harmony's <code>synch</code> module. (The module generalizes locks to binary semaphores (Chapter 16), but the lock interface is the same.) Figure 8.2 shows how locks may be used to implement a critical section. Figure 8.3 gives an example of how locks may be used to fix the program of Figure 3.2.</p> <p>Note that the code of Figure 8.1 is executable in Harmony. However, the atomically keyword is not available in general programming languages and should not be used for implementation. Peterson's algorithm is an implementation of a lock, although only for two processes. In the following chapters, we will look at more general ways of implementing locks using atomic constructions that are usually available in the underlying hardware.</p> <p>In Harmony, any statement can be preceded by the atomically keyword. It means that statement as a whole is to be executed atomically. The atomically keyword can be used to specify the behavior of methods such as <code>acquire</code> and <code>release</code>. But an actual executable program---such as the one in Figure 8.2---should not use the atomically keyword because---on a normal machine---it cannot be directly compiled into machine code. If we want to make the program executable on hardware, we have to show how <code>Lock</code>, <code>acquire</code>, and <code>release</code> are implemented, not just how they are specified. Chapter 9 presents such an implementation.</p> <p>The code in Figure 8.1 also uses the Harmony when statement. A when statement waits until a time in which condition holds (not necessarily the first time) and then executes the statement block. The \"await condition\" statement is the same as \"when condition: pass\". Combined with the atomically keyword, the entire statement is executed atomically at a time that the condition holds.</p> <p>It is important to appreciate the difference between an atomic section (the statements executed within an atomic block of statements) and a critical section (protected by a lock of some sort). The former ensures that while the statements are executing no other thread can execute. The latter allows multiple threads to run concurrently, just not within the critical section. The former is rarely available to a programmer (e.g., none of Python, C, or Java support it), while the latter is very common.</p> <p>Atomic statements are not intended to replace locks or other synchonization primitives. When implementing synchronization solutions you should not directly use atomic statements but use the synchronization primitives that are available to you. But if you want to specify a synchronization primitive, then use atomically by all means. You can also use atomic statements in your test code. In fact, as mentioned before, assert statements are included to test if certain conditions hold in every execution and are executed atomically.</p>"},{"location":"textbook/spinlock/","title":"Spinlock","text":"<p>Peterson's algorithm implements locks, but it is not efficient, especially if generalized to multiple threads. Worse, Peterson relies on load and store operations to be executed atomically, but this may not be the case. There are a variety of possible reasons for this.</p> <ul> <li> <p>Variables may have more bits than the processor's data bus. For     example, variables may have 32 bits, but the data bus may only have     16 bits. Thus to store or load a variable takes two 16-bit     operations each. Take, for example, a variable that has value     0xFFFFFFFF, and consider a concurrent load and store operation on     the variable. The store operation wants to clear the variable, but     because it takes two store operations on the bus, the load operation     may return either 0xFFFF0000 or 0x0000FFFF, a value that the     variable never was supposed to have. This is the case even if the     processor supports a 32-bit load or store machine instruction: on     the data bus it is still two operations.</p> </li> <li> <p>Modern processors sometimes re-orders load and store operations     (out-of-order execution) for improved performance. On a sequential     processor, the re-ordering is not a problem as the processor only     re-orders operations on independent memory locations. However, as     Example 6.3 showed, Peterson's algorithm breaks down if such     seemingly independent operations are re-ordered. Some memory caches     can also cause non-atomic behavior of memory when shared among     multiple cores.</p> </li> <li> <p>Even compilers, in their code generation, may make optimizations     that can reorder operations, or even eliminate operations, on     variables. For example, a compiler may decide that it is unnecessary     to read the same variable more than once, because how could it     possibly change if there are no store operations in between?</p> </li> </ul> <p>Peterson's algorithm relies on a sequential consistent memory model and hence the sequential statement: without it Harmony will complain about data races. More precisely, the sequential statement says that the program relies on memory load and store instructions operating on the indicated variables to be performed sequentially, and that this order should be consistent with the order of operations invoked on each thread. The default memory models of C and Java are not sequentially consistent. The unfortunately named volatile keyword in Java has a similar function as Harmony's sequential keyword. Like many constructions in Java, its <code>volatile</code> keyword was borrowed from C and C++. However, in C and C++, they do not provide sequential consistency, and one cannot implement Peterson's algorithm in C or C++ directly.</p> <p>For proper synchronization, multi-core processors provide so-called atomic instructions: special machine instructions that can read memory and then write it in an indivisible step. While the HVM does not have any specific built-in atomic instructions besides loading and storing variables, it does have support for executing multiple instructions atomically. Any Harmony statement can be made atomic by placing either a label in front of it or the keyword atomically. We can use atomic statements to implement a wide variety of atomic operations. For example, we could fix the program in Figure 3.2 by constructing an atomic increment operation for a counter, like so:</p> <pre><code>def atomic_inc(ptr):\n\u00a0\u00a0\u00a0\u00a0atomically !ptr += 1\n\u00a0\u00a0\u00a0\u00a0\ncount = 0\natomic_inc(?count)\n</code></pre> <p>To support implementing locks, many CPUs have an atomic \"test-and-set\" (TAS) operation. Method <code>test_and_set</code> in Figure 9.1 shows its specification. Here s points to a shared boolean variable and p to a private boolean variable, belonging to some thread. The operation copies the value of the shared variable to the private variable (the \"test\") and then sets the shared variable to <code>True</code> (\"set\").</p> spinlock.hny<pre><code>const N = 3\n\nshared = False\nprivate = [ True, ] * N\n\ninvariant len(x for x in [shared,] + private where not x) &lt;= 1\n\ndef test_and_set(s, p):\n    atomically:\n        !p = !s\n        !s = True\n\ndef clear(s):\n    assert !s\n    atomically !s = False\n\ndef thread(self):\n    while choose({ False, True }):\n        # Enter critical section\n        while private[self]:\n            test_and_set(?shared, ?private[self])\n\n        # Critical section\n        cs: assert (not private[self]) and (countLabel(cs) == 1)\n\n        # Leave critical section\n        private[self] = True\n        clear(?shared)\n\nfor i in {0..N-1}:\n    spawn thread(i)\n</code></pre> Figure 9.1 (code/spinlock.hny):  Mutual Exclusion using a \"spinlock\" based on test-and-set  <p>Figure 9.1 goes on to implement mutual exclusion for a set of <code>N</code> threads. The approach is called spinlock, because each thread is \"spinning\" (executing a tight loop) until it can acquire the lock. The program uses <code>N</code> + 1 boolean variables. Variable shared is initialized to <code>False</code> while private}[i] for each thread i is initialized to <code>True</code>.</p> <p>An important invariant, \\(\\mathcal{I}_1\\), of the program is that at any time at most one of these variables is <code>False</code>. Another invariant, \\(\\mathcal{I}_2(i)\\), is that if thread i is in the critical section, then private}[i] = <code>False</code>. Between the two (i.e., \\(\\mathcal{I}_1 \\land \\forall i: \\mathcal{I}_2(i)\\)), it is clear that only one thread can be in the critical section at the same time.</p> <p>To see that invariant \\(\\mathcal{I}_1\\) is maintained, note that !p = <code>True</code> upon entry of <code>test_and_set</code> (because of the condition on the while loop that the <code>test_and_set</code> method is invoked in). There are two cases:</p> <ol> <li> <p>!s is <code>False</code> upon entry to <code>test_and_set</code>. Then upon exit !p =     <code>False</code> and !s = <code>True</code>, maintaining the invariant.</p> </li> <li> <p>!s is <code>True</code> upon entry to <code>test_and_set</code>. Then upon exit nothing     has changed, maintaining the invariant.</p> </li> </ol> <p>Invariant \\(\\mathcal{I}_1\\) is also easy to verify for exiting the critical section because we can assume, by the induction hypothesis, that private[i] is <code>True</code> just before exiting the critical section. Invariant \\(\\mathcal{I}_2(i)\\) is obvious as (i) thread i only proceeds to the critical section if private[i] is <code>False</code>, and (ii) no other thread modifies private[i].</p> <p>Harmony can check these invariants as well. \\(\\mathcal{I}_2(i)\\) is checked by the assert statement. But how would one go about checking an invariant like \\(\\mathcal{I}_1\\)? Invariants must hold for every state. For \\(\\mathcal{I}_2\\) we only need an assertion at label <code>cs</code> because the premise is that there is a thread at that label. However, we would like to check \\(\\mathcal{I}_1\\) in every state (after the variables have been initialized). Harmony supports checking such invariants using the <code>invariant</code> keyword. The expression counts the number of <code>False</code> values and checks that the result is less than or equal to 1. Harmony checks the expression in every reachable state.</p>"},{"location":"textbook/spinlock/#exercises","title":"Exercises","text":"<p>9.1 Implement an atomic swap operation. It should take two pointer arguments and swap the values.</p> <p>9.2 Implement a spinlock using the atomic swap operation.</p> <p>9.3 For the solution to Example 9.1, write out the invariants that need to hold and check them using Harmony.</p>"},{"location":"textbook/starvation/","title":"Starvation","text":"<p>A property is a set of traces. If a program has a certain property, that means that the traces that that program allows are a subset of the traces in the property. So far, we have pursued two properties: mutual exclusion and progress. The former is an example of a safety property---it prevents something \"bad\" from happening, like a reader and writer thread both acquiring a reader/writer lock. The progress property is an example of a liveness property---guaranteeing that something good eventually happens. Informally (and inexactly), progress states that if no threads are in the critical section, then some thread that wants to enter can.</p> <p>Progress is a weak form of liveness. It says that some thread can enter, but it does not prevent a scenario such as the following. There are three threads repeatedly trying to enter a critical section using a spinlock. Two of the threads successfully keep entering, alternating, but the third thread never gets a turn. This is an example of starvation. With a spinlock, this scenario could even happen with two threads. Initially both threads try to acquire the spinlock. One of the threads is successful and enters. After the thread leaves, it immediately tries to re-enter. This state is identical to the initial state, and there is nothing that prevents the same thread from acquiring the lock yet again.</p> <p>Peterson's Algorithm (Figure 6.1) does not suffer from starvation, thanks to the <code>turn</code> variable that alternates between 0 and 1 when two threads are contending for the critical section. Ticket locks (Figure 10.2) are also free from starvation.</p> <p>While spinlocks suffer from starvation, it is a uniform random process and each thread has an equal chance of entering the critical section. Thus the probability of starvation is exponentially vanishing. We shall call such a solution fair (although it does not quite match the usual formal nor vernacular concepts of fairness).</p> <p>Unfortunately, such is not the case for the reader/writer solution that we presented in\u00a0Chapter 16. Consider this scenario: there are two readers and one writer. One reader is in the critical section while the writer is waiting. Now the second reader tries to enter and is able to. The first reader leaves. We are now in a similar situation as the initial state with one reader in the critical section and the writer waiting, but it is not the same reader. Unfortunately for the writer, this scenario can repeat itself indefinitely. So, even if neither reader was in the critical section all of the time, and the second reader arrived well after the writer, the writer never had a chance.</p> RWfair.hny<pre><code>from synch import BinSema, acquire, release\n\ndef RWlock() returns lock:\n    lock = {\n            .nreaders: 0, .nwriters: 0, .mutex: BinSema(False),\n            .r_gate: { .sema: BinSema(True), .count: 0 },\n            .w_gate: { .sema: BinSema(True), .count: 0 }\n        }\n\ndef read_acquire(rw):\n    acquire(?rw-&gt;mutex)\n    if (rw-&gt;nwriters &gt; 0) or (rw-&gt;w_gate.count &gt; 0):\n        rw-&gt;r_gate.count += 1; release(?rw-&gt;mutex)\n        acquire(?rw-&gt;r_gate.sema); rw-&gt;r_gate.count -= 1\n    rw-&gt;nreaders += 1\n    if rw-&gt;r_gate.count &gt; 0:\n        release(?rw-&gt;r_gate.sema)\n    else:\n        release(?rw-&gt;mutex)\n\ndef read_release(rw):\n    acquire(?rw-&gt;mutex)\n    rw-&gt;nreaders -= 1\n    if (rw-&gt;w_gate.count &gt; 0) and (rw-&gt;nreaders == 0):\n        release(?rw-&gt;w_gate.sema)\n    else:\n        release(?rw-&gt;mutex)\n\ndef write_acquire(rw):\n    acquire(?rw-&gt;mutex)\n    if (rw-&gt;nreaders + rw-&gt;nwriters) &gt; 0:\n        rw-&gt;w_gate.count += 1; release(?rw-&gt;mutex)\n        acquire(?rw-&gt;w_gate.sema); rw-&gt;w_gate.count -= 1\n    rw-&gt;nwriters += 1\n    release(?rw-&gt;mutex)\n\ndef write_release(rw):\n    acquire(?rw-&gt;mutex)\n    rw-&gt;nwriters -= 1\n    if rw-&gt;r_gate.count &gt; 0:\n        release(?rw-&gt;r_gate.sema)\n    elif rw-&gt;w_gate.count &gt; 0:\n        release(?rw-&gt;w_gate.sema)\n    else:\n        release(?rw-&gt;mutex)\n</code></pre> Figure 17.1 (code/RWfair.hny):  Reader/Writer Lock SBS implementation addressing fairness  <p>SBSs allow much control over which type of thread runs next and is therefore a good starting point for developing fair synchronization algorithms. Figure 17.1 is based on Figure 16.1, but there are two important differences:</p> <ol> <li> <p>When a reader tries to enter the critical section, it yields not     only if there are writers in the critical section, but also if there     are writers waiting to enter the critical section;</p> </li> <li> <p>Instead of a one-size-fits-all <code>release_one</code> method, each method has     a custom way of selecting which gate to open. In particular,     <code>read_release</code> prefers the write gate, while <code>write_release</code> prefers     the read gate.</p> </li> </ol> <p>The net effect of this is that if there is contention between readers and writers, then readers and writers end up alternating entering the critical section. While readers can still starve other readers and writers can still starve other writers, readers can no longer starve writers nor vice versa. Other fairness is based on the fairness of semaphores themselves.</p>"},{"location":"textbook/starvation/#exercises","title":"Exercises","text":"<p>17.1 Write a fair solution to the one-lane bridge problem of Exercise 16.9.</p>"},{"location":"textbook/synch/","title":"Lock Implementations","text":"<p>Locks are probably the most prevalent and basic form of synchronization in concurrent programs. Typically, whenever you have a shared data structure, you want to protect the data structure with a lock and acquire the lock before access and release it immediately afterward. In other words, you want the access to the data structure to be a critical section. That way, when a thread makes modifications to the data structure that take multiple steps, other threads will not see the intermediate inconsistent states of the data structure.</p> <p>When there is a bug in a program because some code omitted obtaining a lock before accessing a shared data structure, that is known as a data race. More precisely, a data race happens when there is a state in which multiple threads are trying to access the same variable, and at least one of those accesses updates the variable. In many environments, including C and Java programs, the behavior of concurrent load and store operations have tricky or even undefined semantics. One should therefore avoid data races, which is why Harmony reports them even though Harmony has sequentially consistent memory.</p> <p>Harmony does not report data races in two cases. First, using the sequential statement, you can specify that concurrent access to the specified variables is intended. Second, if the accesses are within an atomic statement block, then they are not considered part of a data race.</p> <p>Figure 9.1 shows a lock implementation based on a shared variable and a private variable for each thread. The private variables themselves are actually implemented as shared variables, but they are accessed only by their respective threads. A thread usually does not keep explicit track of whether it has a lock or not, because it is implied by the control flow of the program---a thread implicitly knows that when it is executing in a critical section it has the lock. There is no need to keep private as a shared variable---we only did so to be able to show and check the invariants. Figure 10.1 shows a more straightforward implementation of a spinlock. The lock is also cleared in an atomic statement to prevent a data race. This approach is general for any number of threads.</p> <p>You can test the spinlock with the program in Figure 8.2 using the command <code>harmony -m synch=taslock code/cssynch.hny</code>. The <code>-m</code> flag tells Harmony to use the <code>taslock.hny</code> file for the <code>synch</code> module rather than the standard <code>synch</code> module (which contains only a specification of the lock methods).</p> <p>The spinlock implementation suffers potentially from starvation: an unlucky thread may never be able to get the lock while other threads successfully acquire the lock one after another. It could even happen with just two threads: one thread might successfully acquire the lock repeatedly in a loop, while another thread is never lucky enough to acquire the lock in between.</p> tasLock.hny<pre><code>def test_and_set(s) returns result:\n    atomically:\n        result = !s\n        !s = True\n\ndef Lock() returns result:\n    result = False\n\ndef acquire(lk):\n    while test_and_set(lk):\n        pass\n\ndef release(lk):\n    atomically !lk = False\n</code></pre> Figure 10.1 (code/tasLock.hny):  Implementation of the lock specification in Figure 8.1 using a spinlock based on test-and-set  ticket.hny<pre><code>const MAX_THREADS = 8\n\ndef fetch_and_increment(p) returns result:\n    atomically:\n        result = !p\n        !p = (!p + 1) % MAX_THREADS\n\ndef atomic_load(p) returns result:\n    atomically result = !p\n\ndef Lock():\n    result = { .counter: 0, .dispenser: 0 }\n\ndef acquire(lk):\n    let my_ticket = fetch_and_increment(?lk-&gt;dispenser):\n        while atomic_load(?lk-&gt;counter) != my_ticket:\n            pass\n\ndef release(lk):\n    fetch_and_increment(?lk-&gt;counter)\n</code></pre> Figure 10.2 (code/ticket.hny):  Implementation of the lock specification in Figure 8.1 using a ticket lock  <p>A ticket lock (Figure 10.2 is an implementation of a lock that prevents starvation using an atomic fetch-and-increment operator. It is inspired by European bakeries. A European bakery often has a clearly displayed counter (usually just two digits) and a ticket dispenser. Tickets are numbered 0 through 99 and repeat over and over again (in the case of a two digit counter). When a customer walks into the bakery, they draw a number from the dispenser and wait until their number comes up. Every time a customer has been helped, the counter is incremented. (Note that this only works if there can be no more than 100 customers in the bakery at a time.)</p> <p>Figure 10.2 similarly uses two variables for a lock, counter and dispenser. When a thread acquires the lock, it fetches the current dispenser value and increments it modulo <code>MAX_THREADS</code>, all in one atomic operation. In practice, <code>MAX_THREADS</code> would be a number like \\(2^{32}\\) or \\(2^{64}\\), but since the Harmony model checker checks every possible state, limiting <code>MAX_THREADS</code> to a small number significantly reduces the time to model check a Harmony program. Plus it is easier to check that it fails when you run it with more than <code>MAX_THREADS</code> threads. Note that loading the counter must also be done atomically in order to avoid a data race. You can test the implementation using the command <code>harmony -m synch=ticket code/cssynch.hny</code>. To see it fail, try <code>harmony -c NTHREADS=10 -m synch=ticket code/cssynch.hny</code>.</p> <p>We now turn to a radically different way of implementing locks, one that is commonly provided by operating systems to user processes. We call a thread blocked if a thread cannot change the state or terminate unless another thread changes the state first. A thread trying to acquire a lock held by another thread is a good example of a thread being blocked. The only way forward is if the other thread releases the lock. A thread that is in an infinite loop is also considered blocked.</p> synchS.hny<pre><code>import list\n\ndef tas(lk):\n    atomically:\n        result = !lk\n        !lk = True\n\ndef cas(p, old, new):\n    atomically:\n        result = !p == old\n        if result:\n            !p = new\n\ndef BinSema(acquired):\n    result = { .acquired: acquired, .suspended: [] }\n\ndef Lock():\n    result = BinSema(False)\n\ndef acquire(binsema):\n    atomically:\n        if binsema-&gt;acquired:\n            stop ?binsema-&gt;suspended[len binsema-&gt;suspended]\n            assert binsema-&gt;acquired\n        else:\n            binsema-&gt;acquired = True\n\ndef release(binsema):\n    atomically:\n        assert binsema-&gt;acquired\n        if binsema-&gt;suspended == []:\n            binsema-&gt;acquired = False\n        else:\n            go (list.head(binsema-&gt;suspended)) ()\n            binsema-&gt;suspended = list.tail(binsema-&gt;suspended)\n\ndef held(binsema):\n    result = binsema-&gt;acquired\n\ndef Condition():\n    result = []\n\ndef wait(c, lk):\n    atomically:\n        release(lk)\n        stop ?(!c)[len !c]\n    acquire(lk)\n\ndef notify(c):\n    atomically if !c != []:\n        go (list.head(!c)) ()\n        !c = list.tail(!c)\n\ndef notifyAll(c):\n    atomically:\n        while !c != []:\n            go (list.head(!c)) ()\n            !c = list.tail(!c)\n\ndef Semaphore(cnt):\n    result = { .count: cnt, .waiters: [] }\n\ndef P(sema):\n    atomically:\n        if sema-&gt;count &gt; 0:\n            sema-&gt;count -= 1\n        else:\n            stop ?sema-&gt;waiters[len sema-&gt;waiters]\n\ndef V(sema):\n    atomically let cnt, waiters = sema-&gt;count, sema-&gt;waiters:\n        if waiters != []:\n            assert cnt == 0\n            go (waiters[0]) ()\n            sema-&gt;waiters = list.tail(waiters)\n        else:\n            sema-&gt;count = cnt + 1\n\ndef Queue():\n    result = { .list: [], .waiters: [] }\n\ndef get(q):\n    atomically:\n        if q-&gt;list == []:\n            stop ?q-&gt;waiters[len q-&gt;waiters]\n\n        result = list.head(q-&gt;list)\n        q-&gt;list = list.tail(q-&gt;list)\n\ndef put(q, item):\n    atomically:\n        q-&gt;list = list.append(q-&gt;list, item)\n        let waiters = q-&gt;waiters:\n            if waiters != []:\n                go (waiters[0]) item\n                q-&gt;waiters = list.tail(waiters)\n</code></pre> Figure 10.3 (modules/synchS.hny):  Lock implementation using suspension  <p>In most operating systems, threads are virtual (as opposed to \"raw CPU cores\") and can be suspended until some condition changes. For example, a thread that is trying to acquire a lock can be suspended until the lock is available. In Harmony, a thread can suspend itself and save its context (state) in a shared variable. Recall that the context of a thread contains its program counter, stack, and register (containing the current method's variables). A context is a regular (if complex) Harmony value. The syntax of the expression that a thread executes to suspend itself is as follows: <pre><code>stop s\n</code></pre> This causes the context of the thread to be saved in s and the thread to be no longer running. Another thread can revive the thread using the go statement: <pre><code>go s r\n</code></pre> Here c is a context and r is a Harmony value. It causes a thread with context c to be added to the state that has just executed the stop expression. The stop expression returns the value r.</p> <p>Figure 10.3 shows the lock interface using suspension. It is implemented as follows:</p> <ul> <li> <p>A lock maintains both a boolean indicating whether the lock is     currently acquired and a list of contexts of threads that want to     acquire the lock.</p> </li> <li> <p><code>acquire</code>() acquires the lock if available and suspends the invoking     thread if not. In the latter case, the context of the thread is     added to the end of the list of contexts. Note that stop is     called within an atomic statement block---this is the only exception     to such an atomic statement block running to completion. While the     thread is running no other threads can run, but when the thread     suspends itself other threads can run.</p> </li> <li> <p><code>release</code>() checks to see if any threads are waiting to acquire the     lock. If so, it uses the <code>head</code> and <code>tail</code> methods from the <code>list</code>     module (see ) to resume the first thread that got suspended and to     remove its context from the list.</p> </li> </ul> <p>Selecting the first thread is a design choice. Another implementation could have picked the last one, and yet another implementation could have used choose to pick an arbitrary one. Selecting the first is a common choice in lock implementations as it prevents starvation.</p> <p>You will find that using the implementation of a lock instead of the specification of a lock (in the <code>synch</code> module) often leads to the model checker searching a significantly larger state space. Thus it makes sense to model check larger programs in a modular fashion: model check one module implementation at a time, using specifications for the other modules.</p>"},{"location":"textbook/synch/#exercises","title":"Exercises","text":"<p>10.1 Run Figure 8.3 using (i) <code>synch</code> and (ii) <code>synchS</code>. Report how many states were explored by Harmony for each module.</p> xy.hny<pre><code>x, y = 0, 100\n\ndef setX(a):\n    x = a\n    y = 100 - a\n\ndef getXY() returns xy:\n    xy = [x, y]\n\ndef checker():\n    let xy = getXY():\n        assert (xy[0] + xy[1]) == 100, xy\n\nspawn checker()\nspawn setX(50)\n</code></pre> Figure 10.4 (code/xy.hny):  Incomplete code for Exercise 10.2 with desired invariant $x + y = 100$  <p>10.2 Figure 10.4 shows a Harmony program with two variables x (initially 0) and y (initially 100) that can be accessed through methods <code>setX</code> and <code>getXY</code>. An application invariant is that <code>getXY</code> should return a pair that sums to 100. Add the necessary synchronization code.</p> <p>10.3 Implement <code>tryAcquire</code>(b) as an additional interface for both the <code>synch</code> and <code>synchS</code> modules. This interface is like <code>acquire</code>(b) but never blocks. It returns <code>True</code> if the lock was available (and now acquired) or <code>False</code> if the lock was already acquired. Hint: you do not have to change the existing code.</p> atm.hny<pre><code>from synch import Lock, acquire, release\n\nconst N_ACCOUNTS = 2\nconst N_CUSTOMERS = 2\nconst N_ATMS = 2\nconst MAX_BALANCE = 1\n\naccounts = [ { .lock: Lock(), .balance: choose({0..MAX_BALANCE})}\n                            for i in {1..N_ACCOUNTS} ]\n\ninvariant min(accounts[acct].balance for acct in {0..N_ACCOUNTS-1}) &gt;= 0\n\ndef atm_check_balance(acct) returns balance:  # return the balance on acct\n    acquire(?accounts[acct].lock)\n    balance = accounts[acct].balance\n    release(?accounts[acct].lock)\n\ndef atm_withdraw(acct, amount) returns success: # withdraw amount from acct\n    assert amount &gt;= 0\n    acquire(?accounts[acct].lock)\n    accounts[acct].balance -= amount\n    release(?accounts[acct].lock)\n    success = True\n\ndef customer(atm, acct, amount):\n    assert amount &gt;= 0\n    let bal = atm_check_balance(acct):\n        if amount &lt;= bal:\n            atm_withdraw(acct, amount)\n\nfor i in {1..N_ATMS}:\n    spawn customer(i, choose({0..N_ACCOUNTS-1}),\n                      choose({0..MAX_BALANCE}))\n</code></pre> Figure 10.5 (code/atm.hny):  Withdrawing money from an ATM <p>10.4 People who use an ATM often first check their balance and then withdraw a certain amount of money not exceeding their balance. A negative balance is not allowed. Figure 10.5 shows two operations on bank accounts: one to check the balance and one to withdraw money. Note that all operations on accounts are carefully protected by a lock (i.e., there are no data races). The <code>customer</code> method models going to a particular ATM and withdrawing money not exceeding the balance. Running the code through Harmony reveals that there is a bug. It is a common type of concurrency bug known as Time Of Check Time Of Execution (TOCTOE). In this case, by the time the withdraw operation is performed, the balance can have changed. Fix the code in Figure 10.5. Note, you should leave the customer code the same. You are only allowed to change the <code>atm_</code> methods, and you cannot use the atomically keyword.</p>"},{"location":"textbook/testing/","title":"Testing: Checking Behaviors","text":"qtestseq.hny<pre><code>import queue, queueconc\n\nconst NOPS = 4\nconst VALUES = { 1..NOPS }\n\nspecq = queue.Queue()\nimplq = queueconc.Queue()\n\nfor i in {1..NOPS}:\n    let op = choose({ \"get\", \"put\" }):\n        if op == \"put\":\n            let v = choose(VALUES):\n                queueconc.put(?implq, v)\n                queue.put(?specq, v)\n        else:\n            let v = queueconc.get(?implq)\n            let w = queue.get(?specq):\n                assert v == w\n</code></pre> Figure 13.1 (code/qtestseq.hny):  Sequential queue test  <p>Testing is a way to increase confidence in the correctness of an implementation. Figure 11.2 demonstrates how concurrent queues may be used, but it is not a very thorough test program for an implementation such as the one in Figure 11.3 and does little to increase our confidence in its correctness. To wit, if <code>get()</code> always returned 1, the program would find no problems. Similarly, Figure 12.2 is not a good test program for something as complicated as Figure 12.3. In this chapter, we will look at approaches to testing concurrent code.</p> <p>As with critical sections---when testing a concurrent data structure---we need a specification. For example, Figure 11.1(a) shows a sequential specification of a queue in Harmony. First, we can check if the queue implementation in Figure 11.3 meets the sequential queue specification in Figure 11.1(a). To check if the queue implementation meets the specification, we need to see if any sequence of queue operations in the implementation matches a corresponding sequence in the specification. We say that the implementation and the specification have the same behaviors or are behaviorally equivalent.</p> <p>Behaviors say something about how we got to a state. The same state can be reaching by multiple behaviors, and the behaviors are often an integral part of whether a program is correct or not. Just because a state satisfies some invariant---however important---does not mean that the state is valid given the sequence of operations. For example, a state in which the queue is empty is certainly a valid state in its own right, but if the last operation to get there was an enqueue operation, there must be a bug in the program. It can therefore be important to capture the behaviors. We could store behaviors in the state itself by adding what is known as a history variable that keeps track of all the operations. While this can be useful for correctness proofs, for model checking this approach presents a problem: introducing this additional state can lead to state explosion or even turn a finite model (a model with a finite number of states) into an infinite one. We therefore use a different approach: composing an implementation with its specification to ensure that accept the same behaviors.</p> <p>Figure 13.1 presents a test program that does exactly this, for sequences of up to <code>NOPS</code> queue operations. It maintains two queues:</p> <ul> <li> <p>specq: the queue of the specification;</p> </li> <li> <p>implq: the queue of the implementation.</p> </li> </ul> <p>For each operation, the code first chooses whether to perform a <code>get</code> or <code>put</code> operation. In the case of a <code>put</code> operation, the code also chooses which value to append to the queue. All operations are performed on both the queue implementation and the queue specification. In the case of <code>get</code>, the results of the operation on both the implementation and specification are checked against one another.</p> <p>Test programs themselves should be tested. Just because a test program works with a particular implementation does not mean the implementation is correct---it may be that the implementation is incorrect but the test program does not have enough coverage to find any bugs in the implementation. So, run a test program like this with a variety of queue implementations that have known bugs in them and make sure that the test program finds them. Conversely, a test program may be broken in that it finds bugs that do not exist. In my experience, it is often harder to implement the test program than the algorithm that the test program tests.</p> <p>As with any other test program, Figure 13.1 may not trigger extant bugs, but it nonetheless inspires reasonable confidence that the queue implementation is correct, at least sequentially. The higher <code>NOPS</code>, the higher the confidence. It is possible to write similar programs in other languages such as Python, but the choose expression in Harmony makes it relatively easy to explore all corner cases. For example, a common programming mistake is to forget to update the <code>tail</code> pointer in <code>get()</code> in case the queue becomes empty. Normally, it is a surprisingly tricky bug to find. You can comment out those lines in Figure 11.3 and run the test program---it should easily find the bug and explain exactly how the bug manifests itself, adding confidence that the test program is reasonably thorough.</p> <p>The test program also finds some common mistakes in using locks, such as forgetting to release a lock when the queue is empty, but it is not designed to find concurrency bugs in general. If you remove all <code>acquire()</code> and <code>release()</code> calls from Figure 11.3, the test program will not (and should not) find any errors, but it would be an incorrect implementation of a concurrent queue.</p> <p>The next step is to test if the queue implementation meets the concurrent queue specification or not. Figure 11.1(b) shows the concurrent queue specification. It is similar to the sequential specification in Figure 11.1(a) but makes all operations (except instantiation itself) atomic. Testing the implementation of a concurrent queue specification is trickier than testing the implementation of a sequential one because there are many more scenarios to check.</p> <p>We would like a way that---similar to the sequential test---systematically compares behaviors of the concurrent queue implementation with behaviors of the concurrent queue specification. But we cannot do this by composing the specification and the implementation and simply run the same test operations on both as we did before---concurrency make the operations non-determistic and thus the specification and implementation of a single execution might produce different results, even if both are correct. Instead, we will create a test program that tries various concurrent combinations of queue operations, and run it twice: once against the specification of the concurrent queue and once against the implementation. We will then check if the behaviors obtained from running the implementation are also behaviors obtained from the specification.</p> <p></p> qtestpar.hny<pre><code>import queue\n\nconst NOPS = 4\nq = queue.Queue()\n\ndef put_test(self):\n    print(\"call put\", self)\n    queue.put(?q, self)\n    print(\"done put\", self)\n\ndef get_test(self):\n    print(\"call get\", self)\n    let v = queue.get(?q):\n        print(\"done get\", self, v)\n\nnputs = choose {1..NOPS-1}\nfor i in {1..nputs}:\n    spawn put_test(i)\nfor i in {1..NOPS-nputs}:\n    spawn get_test(i)\n</code></pre> Figure 13.2 (code/qtestpar.hny):  Concurrent queue test. The behavior DFA is for NOPS = 2.  queueseq.hny<pre><code>def Queue() returns empty:\n    empty = { .data: [], .head: 0, .tail: 0 }\n\ndef put(q, v):\n    let i = q-&gt;tail:\n        q-&gt;data[i] = v\n        q-&gt;tail = i + 1\n\ndef get(q) returns next:\n    let i = q-&gt;head:\n        if i == q-&gt;tail:\n            next = None\n        else:\n            next = q-&gt;data[i]\n            q-&gt;head = i + 1\n</code></pre> Figure 13.3 (code/queueseq.hny):  Sequential but not a concurrent queue implementation  <p>We will start with a test program that tries concurrent combinations of various queue operations. Figure 13.2 shows the test program. It starts <code>NOPS</code> threads doing either a <code>put</code> or a <code>get</code> operation.  It selects the fraction of <code>put</code> over <code>get</code> operations nondetermistically, although avoiding the uninteresting case in which there are none of one of them. In case of a <code>put</code> operation, the thread enqueues its own name (which is provided as an argument to the thread). In order to capture the behaviors, each thread prints what operation it is about to perform, and afterwards it prints that the operation has completed (including the return value if any). This is probably much like you would do if you were trying to find a bug in a program.</p> <p>Figure 13.2 also shows the deterministic finite automaton that describes the possible outputs when the test program is run against the specification in the case <code>NOPS</code> = 2---for <code>NOPS</code> = 4 it would be much too large to print here. Since there are no cycles in the DFA, you can follow some paths through this DFA and see that they are valid interleavings of the threads. You can obtain this output yourself by running</p> <pre><code>$ harmony -c NOPS=2 -o spec.png code/qtestpar.hny\n</code></pre> <p>If you run the same test program against the implementation of Figure 11.3, you will get the same output:</p> <pre><code>$ harmony -c NOPS=2 -o impl.png -m queue=queueconc code/qtestpar.hny\n</code></pre> <p>You can try this for various <code>NOPS</code>, although it gets increasingly harder to check by hand that the generated DFAs are the same as <code>NOPS</code> increases. Now run the test program against Figure 13.3, which is clearly an incorrect implementation of the concurrent queue specification because it contains no synchronization code. However, Harmony does not immediately detect any problems. In fact, for \\(\\mathtt{NOPS} = 2\\) it even generates the same set of behaviors. This is because the test program only outputs the behaviors---it does not check if they are correct.</p> <p>Harmony does have a way to check the behaviors of one program against the behaviors of another. In particular, we want to check if the behaviors of the implementations we have match behaviors of the specification. The following shows, for example, how to check the <code>queueconc.hny</code> implementation on the command line:</p> <pre><code>$ harmony -o queue4.hfa code/qtestpar.hny\n$ harmony -B queue4.hfa -m queue=queueconc code/qtestpar.hny\n</code></pre> <p>The first command runs the <code>code/qtestpar.hny</code> program (with the default 4 threads) and writes a representation of the output DFA in the file <code>queue4.hfa</code>. The second command runs the same test program, but using the queue implementation in the file <code>code/queueconc.hny</code>. Moreover, it reads the DFA in <code>queue4.hfa</code> to check if every behavior of the second run of the test program is also a behavior of the first run. You can try the same using the <code>code/queueseq.hny</code> implementation and find that this implementation has behaviors that are not allowed by the specification.</p>"},{"location":"textbook/testing/#exercises","title":"Exercises","text":"<p>13.1 Figure 8.1 shows a specification of a lock. Write a program that checks the behaviors of lock implementations such as Figure 10.1 and Figure 10.2. That is, it should not rely on assertions such as in Figure 5.2.</p> <p>13.2 Write a Harmony program that checks if Figure 12.3 satisfies the specification of Figure 12.1 sequentially.</p> <p>13.3 Write a Harmony program that checks if Figure 12.3 satisfies the specification of Figure 12.1 concurrently.</p> <p>13.4 Rewrite Figure 13.1 so it only imports <code>queue</code> and runs <code>NOPS</code> nondeterministically chosen operations against it (similar in style to Figure 13.2 but without threads). Then use behaviors to check that Figure 11.3 and Figure 13.3 are correct sequential implementations of the queue. Check your test program by also trying it on one or two buggy queue implementations.</p>"},{"location":"textbook/values/","title":"Harmony Language Details","text":""},{"location":"textbook/values/#value-types-and-operators","title":"Value Types and Operators","text":"<p>Chapter 4 provides an introduction to Harmony values Below is a complete list of Harmony value types with examples:</p> Type Name Example Boolean \"bool\" <code>False</code>, <code>True</code> Integer \"int\" ..., --2, --1, 0, 1, 2, ... String \"str\" <code>\"</code>example<code>\"</code>, .example Program Counter \"pc\" ((method names, lambdas, and labels) List \"list\" [ 1, 2, 3, ], ( (1, 2), 3 ), [1,], () Dictionary \"dict\" { .account: 12345, .valid: <code>False</code> }, {:} Set \"set\" {}, { 1, 2, 3 }, { <code>False</code>, .id, 3 } Address \"address\" ?lock, ?flags[2], <code>None</code> Context \"context\" (generated by stop or save expression) <p>In Harmony, there is no distinction between tuples (denoted with parentheses) and lists (denoted by square brackets). That is, their format is either (e, e, ..., e,) or [e, e, ..., e,]. They map indexes (starting at 0) to Harmony values. If the list has two or more elements, then the final comma is optional.</p> <p>Method <code>type e</code> returns the type name of <code>e</code>.</p> <p>All Harmony values are ordered with respect to one another. First they are ordered by type according to the table above. So, for example, <code>True</code> \\(&lt;\\) 0 \\(&lt;\\) .xyz \\(&lt;\\) { 0 }. Within types, the following rules apply:</p> <ul> <li> <p><code>False</code> \\(&lt;\\) <code>True</code>;</p> </li> <li> <p>integers are ordered in the natural way;</p> </li> <li> <p>strings are lexicographically ordered;</p> </li> <li> <p>program counters are ordered by their integer values;</p> </li> <li> <p>lists are lexicographically ordered;</p> </li> <li> <p>dictionaries are first converted into a list of ordered (key, value)     pairs. Then two dictionaries are lexicographically ordered by this     representation;</p> </li> <li> <p>a set is first converted into an ordered list, then     lexicographically ordered;</p> </li> <li> <p>Except for <code>None</code>, an address is a pair of a function a list of arguments.     Addresses are lexicographically ordered accordingly. <code>None</code> is the smallest     address.</p> </li> <li> <p>contexts are ordered deterministically in an unspecified way.</p> </li> </ul> <p>Harmony supports the following comparison operators:</p> e == e equivalence e != e inequivalence e \\(&lt;\\) e, e \\(&lt;=\\) e, e \\(&gt;\\) e, e \\(&gt;=\\) e comparison <p>Comparison operators can be chained: <code>x &lt;= y == z</code> means <code>x &lt;= y and y == z</code>, although y is evaluated once in the former and twice in the latter expression.</p> <p>Harmony supports atomic expression evaluation using the following syntax: <code>atomically e</code>, where <code>e</code> is some expression.</p>"},{"location":"textbook/values/#boolean","title":"Boolean","text":"<p>The boolean type has only two possible values: <code>False</code> and <code>True</code>. Unlike Python, in Harmony booleans are distinct from integers, and in particular \\(\\mathbf{False} &lt; 0\\). In statements and expressions where booleans are expected, it is not possible to substitute values of other types.</p> <p>Operations on booleans include:</p> e and e and ... conjuction e or e or ... disjunction e =\\(&gt;\\) e, e not =\\(&gt;\\) e implication not e negation v if e else v' v or v' depending on e any s, all s disjunction / conjunction for set or list s"},{"location":"textbook/values/#integer","title":"Integer","text":"<p>The integer type supports any whole number. Harmony supports decimal integers, hexadecimal integers (start with <code>0x</code>), binary integers (start with <code>0b</code>), and octal integers (start with <code>0o</code>).</p> <p>In the C-based model checker, integers are currently implemented by two's complement 60-bit words. The model checker checks for overflow on various operations.</p> <p>Operations on integers include:</p> Operation Description -e negation abs e absolute value e + e + ... sum e - e difference e * e * ... product e / e, e // e integer division e % e, e mod e integer division remainder e e power ~e binary inversion e e e e e ^ e ^ ... binary exclusive or e &lt;&lt; e binary shift left e &gt;&gt; e binary shift right { e..e' } set of integers from e to e' inclusive"},{"location":"textbook/values/#string","title":"String","text":"<p>A string is a sequence of zero or more unicode characters. If it consists entirely of alphanumerical characters or underscore characters and does not start with a digit, then a string can be represented by a \".\" followed by the characters. For example, .example is the same as the string <code>\"</code>example<code>\"</code>.</p> <p>Native operations on strings include the following:</p> Operation Description s k indexing s + s + ... concatenation s * n n copies of s concatenated v [not] in s check if v is [not] a substring in s len s the length of s str e string representation of any value e"},{"location":"textbook/values/#set","title":"Set","text":"<p>In Harmony you can create a set of any collection of Harmony values. Its syntax is <code>{ v_0, v_1, ... }</code>. Python users: note that in Harmony the empty set is denoted as <code>{}</code>. (In Python, <code>{}</code> means the empty dictionary, which is represented as <code>{:}</code> in Harmony.)</p> <p>The <code>set</code> module contains various convenient routines that operate on sets. Native operations on sets include:</p> Operation Description len s cardinality s -- s set difference s &amp; s &amp; ... intersection s \\(\\vert\\) s \\(\\vert\\) ... union s \\^ s \\^ ... inclusion/exclusion (elements in odd number of sets) choose s select an element (Harmony will try all) min s minimum element max s maximum element any s <code>True</code> if any value is <code>True</code> all s <code>True</code> if all values are <code>True</code> <p>In Python, the \\(&lt;\\) operator on sets represents the subset relation.  However, in Harmony \\(&lt;\\) is a total order. If you want to check if <code>x</code> is a subset of <code>y</code>, either use the <code>subset</code> method in the <code>set</code> module  or write something like <code>(x | y) == y</code> (the union of <code>x</code> and <code>y</code> is <code>y</code>).</p> <p>Harmony also supports set comprehension. In its simplest form, <code>{ f(v) for v in s }</code> returns a set that is constructed by applying <code>f</code> to all elements in s (where s is a set or a list). This is known as mapping. But set comprehension is much more powerful and can include joining multiple sets (using nested for loops) and filtering (using the <code>where</code> keyword).</p> <p>For example: <code>{ x + y for x in s for y in s where (x * y) == 4 }</code> returns a set that is constructed by summing pairs of elements from s that, when multiplied, have the value 4.</p>"},{"location":"textbook/values/#list-or-tuple","title":"List or Tuple","text":"<p>In Harmony, there is no distinction between a list or a tuple. You can denote a list by a sequence of values, each value terminated by a comma.  As per usual, you can use brackets or parentheses at your discretion.  For Python users, the important thing to note is that a singleton list in Harmony must contain a comma.  For example <code>[1,]</code> is a list containing the value <code>1</code>, while <code>[1]</code> is simply the value <code>1</code>.</p> <p>The <code>list</code> module contains various convenient routines that operate on lists or tuples. Native operations on lists or tuples include the following:</p> Operation Description t k indexing t + t + ... concatenation t * n n copies of t concatenated v [not] in t check if v is [not] a value in t len t the length of t min t the minimum value in t max t the maximum value in t any t <code>True</code> if any value is <code>True</code> all t <code>True</code> if all values are <code>True</code> <p>Lists and tuples support comprehension. In its most basic form: <code>[f(v) for v in t]</code>. For example, to check if any element in a list <code>t</code> is even, you can write: <code>any((x % 2) == 0 for x in t)</code>.</p> <p>The domain of a list \\(L\\) of length \\(n\\), interpreted as a function, are the integers \\(0..n-1\\).  It is illegal to read \\(L[n]\\).  However, unlike Python, it is possible to write into \\(L[n]\\).  For example, if variable <code>x</code> contains <code>[1, 2]</code>, then the statement <code>x[2] = 3</code> results in <code>x</code> having the value <code>[1, 2, 3]</code>.</p>"},{"location":"textbook/values/#dictionary","title":"Dictionary","text":"<p>A dictionary maps a set of values (known as keys) to another set of values. The generic syntax of a dictionary is \\(\\{ k_0:v_0, k_1:v_1, ... \\}\\). Different from Python, the empty dictionary is written as <code>{:}</code> (because {} is the empty set in Harmony). If there are duplicate keys in the list, then only the one with the maximum value survives. Therefore the order of the keys in the dictionary does not matter.</p> <p>Dictionaries support comprehension. The basic form is: { <code>f</code>(v):<code>g</code>(v) for v in s }.</p> <p>There are various special cases of dictionaries, including lists, tuples, strings, and bags (multisets) that are individually described below.</p> <p>Operations on dictionaries include the following:</p> Operation Description d k indexing len d the number of keys in d keys d the set of keys in d k [not] in d check if k is [not] a value in d min d the minimum value in d max d the maximum value in d any d <code>True</code> if any value is <code>True</code> all d <code>True</code> if all values are <code>True</code> d &amp; d &amp; ... dictionary intersection d \\(\\vert\\) d \\(\\vert\\) ... dictionary union <p>Because in Harmony brackets are used for parsing purposes only, you can write d[k] (or d(k)) instead of d k. However, if k is a string like .id, then you might prefer the notation k.id.</p> <p>Dictionary intersection and dictionary union are defined so that they work well with bags. With disjoint dictionaries, intersection and union work as expected. If there is a key in the intersection, then dictionary intersection retains the minimum value while dictionary union retains the maximum value. Unlike Python, Harmony dictionary intersection and union are commutative and associative.</p>"},{"location":"textbook/values/#bag-or-multiset","title":"Bag or Multiset","text":"<p>A bag is represented by a dictionary that maps each element to its multiplicity. For example: <code>{ 10:2, 12:1 }</code> is the bag containing two copies of 10 and one copy of 12. The <code>bag</code> module contains various convenient routines that operate on bags. Native operations on bags include the following:</p> Operation Description v [not] in b check if v is [not] in b t &amp; t &amp; ... bag intersection t \\(\\vert\\) t \\(\\vert\\) ... bag union"},{"location":"textbook/values/#program-counter","title":"Program Counter","text":"<p>A program counter is an integer that can be used to index into Harmony bytecode. When you define a method, a lambda function, or a label, you are creating a constant of the program counter type.</p> <p>Operations on program counters include the following:</p> Operation Description m a invoke method with program counter m and argument a countLabel l return the number of threads executing at label l <p>You can create lambda functions similarly to Python, except that the expression has to end on the keyword end. For example: lambda(x,y): x+y end.</p>"},{"location":"textbook/values/#address","title":"Address","text":"<p>A Harmony address is a closure consisting of a function and a list of arguments.  A function can be a constant or a variable and the arguments are all Harmony values. Given an address  <code>p = ?a[b][c]...</code>, you can use the notation <code>!p</code> to find its value. Harmony will first evaluate <code>a</code>, then apply the result to <code>b</code>, then apply the result to <code>c</code>, and so on.</p> <p>As a simple example, <code>?5</code> is the address of the constant 5, and therefore <code>!?5</code> evaluates to 5.</p> <p>Now consider the following program:</p> <pre><code>let p = ?5:\n    assert !p == 5\n    !p = 5\n    !p = 4\n</code></pre> <p>The only line in this program that fails is the last one, as you are not allowed to store 4 at the address of 5.</p> <p><code>a</code> can be a constant that maps Harmony values to Harmony values:  dictionaries, lists, and strings.  In that case, <code>?a[b]</code> refers to the value of entry <code>b</code> in <code>a</code>.</p> <p>The most common use of addresses is when <code>a</code> is a shared variable. In that case <code>!?a</code> evaluates to the current value of <code>a</code>.</p> <p>Finally, <code>a</code> can be a program counter value (method or lambda). <code>?a(b)</code> is then the closure of method <code>a</code> and argument <code>b</code>. In this case, <code>!?a(b)</code> evaluates <code>a(b)</code>.  For example, the following Harmony program, perhaps surprisingly, does not run into failing assertions:</p> <pre><code>counter = 0\n\ndef f():\n    counter += 1\n    result = counter\n\nlet p = ?f():\n    if !p != 1: assert False\n    if !p != 2: assert False\n    if !p != 3: assert False\n</code></pre> <p>Internally, Harmony uses the address of a method variable and sometimes you see them on the stack during a computation. If <code>k</code> is a method variable, then its address is output as <code>?@k</code>. However, at the Harmony language level there is no such thing as the address of a local variable. Consider the following two programs:</p> <pre><code>x = 1\nlet p = ?x:\n    x = 2\n    assert !p == 2\n</code></pre> <pre><code>var x = 1\nlet p = ?x:\n    x = 2\n    assert !p == 1\n</code></pre> <p>In the program on the left, <code>x</code> is a shared variable, and <code>?x</code> is the location of variable <code>x</code>.  In the program on the right, <code>x</code> is a local variable.  <code>?x</code> evaluates <code>x</code> and then takes its address, so in this case <code>?x</code> equals <code>?1</code>.</p> <p>Like C, Harmony supports the shorthand <code>p-&gt;v</code> for the expression <code>(!p).v</code>.</p>"},{"location":"textbook/values/#context","title":"Context","text":"<p>A context value (aka continuation) captures the state of a thread. A context is itself composed over various Harmony values.</p> <p>The following operations generate contexts:</p> <code>save e</code> returns a Harmony value (see below) <code>stop p</code> saves context in <code>!p</code> and stops the thread (see below) <p>The <code>save e</code> expression, when invoked, returns a tuple <code>(e, c)</code> where <code>c</code> is the context value of the thread right after the <code>save</code> instruction finished. Using <code>go c r</code> the context can be turned into a new thread that, instead, returns <code>r</code> from the <code>save e</code> expression.  See Figure A.1 for an example of how this could be used to fork a thread into two threads.</p> <p>The <code>stop p</code> expression stores the context of the thread right after the expression in <code>!p</code> (i.e., <code>p</code> must be an address value) and terminates the thread.  The thread can later be reinstantiated with <code>go !p r</code>, in which case the <code>stop</code> expression returns <code>r</code>. A thread can be for ever suspended using <code>stop None</code> or just <code>stop()</code>.</p>"},{"location":"textbook/values/#statements","title":"Statements","text":"<p>Harmony currently supports the following statements (below, <code>S</code> is a list of statements and an lvalue is an expression you can use on the left-hand side of an assignment statement):</p> Statement Description e e is an expression lv = [lv =]... e lv is an lvalue and e is an expression lv [op]= e op is one of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, and, or l: <code>S</code> l is a label assert b [, e] b is a boolean. Optionally report value of expression e await b b is a boolean const a = e a is a bound variable, e is a constant expression def m a [returns v]: <code>S</code> m is an identifier, a a bound variable, and v a variable del lv delete lv finally e e is a boolean expression that must hold in each final state for a[:b] in e [where c]: <code>S</code> a and b are bound variables, e is a set, dictionary, or string from m import ... m identifies a module go c e c is a context, e is an expression if b: <code>S</code> else: <code>S</code> b is a boolean, <code>S</code> is a list of statements import m, ... m identifies a module invariant e e is an invariant (must always hold) let a = e: <code>S</code> a is a bound variable, e is an expression pass do nothing print e e is an expression sequential v, ... v has sequential consistency spawn [eternal] m e [, t] m is a method, e is an expression, t is the thread-local state trap m e m is a method and e is an expression var v = e v is a new variable, e is an expression when b: <code>S</code> b is a boolean, <code>S</code> a list of statements when exists a in e: <code>S</code> a is a bound variable, e is an expression while b: <code>S</code> b is a boolean, <code>S</code> a list of statements <ul> <li> <p>Bound variables are read-only.</p> </li> <li> <p>A statement can be preceded by the atomically keyword to make     the statement atomic.</p> </li> <li> <p>Multiple for statements can be combined into a single statement.</p> </li> <li> <p>Multiple let and when statements can be combined into a     single statement.</p> </li> </ul>"},{"location":"textbook/values/#single-expression-evaluation","title":"Single expression evaluation","text":"<p>Any expression by itself can be used as a statement. The most common form of this is a function application, for example: <code>f</code>(). This statement evaluates <code>f</code>() but ignores its result. It is equivalent to the assignment statement \\(\\_ = \\mathtt{f}()\\).</p>"},{"location":"textbook/values/#assignment","title":"Assignment","text":"<p>The statement x = 3 changes the state by assigning\u00a03 to variable x (assuming\u00a0x was not already\u00a03). x may be a local variable or a shared variable. The statement x = y = 3 first updates\u00a0y, then\u00a0x. The statement x[<code>f</code>()] = y[<code>g</code>()] = <code>h</code>() first computes the address of x[<code>f</code>()], then computes the address of y[<code>g</code>()], then evaluates <code>h</code>(), then assigns the resulting value to y[<code>g</code>()] (using its previously computed address), and finally assigns the same value to x[<code>f</code>()] (again using its previously computed address). The statement a,b = c assumes that c is a tuple with two values. It first evaluates the addresses of a and b and first assigns to the latter and then the former. If c is not a tuple with two values, then Harmony will report an error.</p> <p>Assigning to <code>_</code> (underscore) evaluates the righthand side expression but is otherwise a no-op. The left-hand side can also contain constants. For example <code>(3, x) = (3, True)</code> assigns <code>True</code> to <code>x</code>. However, <code>(3, x) = (4, True)</code> fails.</p> <p>The statement \\(x~+\\)\\(= 3\\) loads x, adds 3, and then stores the results in x. In this case, it is equivalent to \\(x = x + 3\\). However, in general this is not so. For example, x[<code>f</code>()] += 3 only evaluates <code>f</code>() once. Unlike Python, however, x += [3,] is equivalent to x = x + [3,] in Harmony. (In Python, the following two compound statements lead to different results for y: x = y = [ ]; x += [3] and x = y = [ ]; x = x + [3].)</p>"},{"location":"textbook/values/#assert","title":"assert","text":"<p>The statement assert b evaluates b and reports an error if b is false. It should be considered a no-op---it is part of the specification, not part of the implementation of the algorithm. In particular, it specifies an invariant: whenever the program counter is at the location where the assert statement is, then b is always true.</p> <p>If b is an expression, then it is evaluated atomically. Moreover, the expression is not allowed to change the state. If it does change the state, Harmony will report an error as well.</p> <p>As in Python, you can specify an additional expression: assert b, e. The value of e will be reported as part of the error should b evaluate to false.</p>"},{"location":"textbook/values/#atomically","title":"atomically","text":"<p>A statement can be preceded by the atomically keyword to make the statement atomic. The statement atomically: <code>S1</code>; <code>S2</code>; ... evaluates statements <code>S1</code>, <code>S2</code>, ... atomically. This means that the statement runs indivisibly---no other thread can interleave in the atomic statement. The only exception to this is if the atomic block executes a stop expression. In this case, another thread can run. When the original thread is resumed (using a go statement), it is once again atomically executing.</p> <p>atomically statements are useful for specification and implementing synchronization primitives such as test-and-set. It is also useful for testing. It is not a replacement for lock/unlock, and should not generally be used for synchronization otherwise. Lock/unlock does allow other threads to run concurrently---just not in the same critical section.</p>"},{"location":"textbook/values/#await","title":"await","text":"<p>The statement await b is equivalent to when b: pass. It is intended to improve readability of your code.</p>"},{"location":"textbook/values/#const","title":"const","text":"<p>The expression const <code>N</code> = 3 introduces a new constant <code>N</code> with the value 3. Evaluating <code>N</code> does not lead to loading from a memory location. The assignment can be overridden with the <code>-c</code> flag: <code>harmony -cN=4</code> executes the model checker with 4 assigned to <code>N</code> instead of 3. Harmony also supports const <code>N</code>, <code>M</code> = 3, 4, which assigns 3 to <code>N</code> and 4 to <code>M</code>. Harmony has limited support for constant folding. For example, const <code>N</code> = 3 + 4 assigns value 7 to constant <code>N</code>.</p>"},{"location":"textbook/values/#def","title":"def","text":"<p>The statement def m a [returns v]: <code>S1</code>; <code>S2</code>: ... defines a new program counter constant m referring to a method that takes an argument a and executes the statements <code>S1</code>, <code>S2</code>, .... The argument a can be a tuple pattern similar to those used in let and for statements. Examples include (), (x,), (x, y), and (x, (y, z)). The given local variable names are assigned upon application and are read-only. Optionally, a result variable <code>r</code> can be declared.  If not declared, there is (for backwards compatibility), a default result variable called <code>result</code>, initialized to <code>None</code>. Harmony does not support a <code>return</code> statement that breaks out of the code before executing the last statement.</p>"},{"location":"textbook/values/#del","title":"del","text":"<p>The statement del x removes variable x from the state. x can be either a local or a shared variable. For example, the statement del x.age removes the .age field from dictionary x. Harmony automatically removes top-level local variables that are no longer in use from the state in order to attempt to reduce the number of states that are evaluated during model checking.</p> <p>Because Harmony lists are dictionaries, deleting from lists is different from Python: <code>del</code> can also be used to remove elements from a list. <code>x = [.a, .b, .c]; del x[1]</code> results in x having value <code>[.a, .c]</code>.</p>"},{"location":"textbook/values/#finally","title":"finally","text":"<p>The statement <code>finally c</code> declares that boolean expression <code>c</code> must hold in each final state. <code>c</code> is only allowed to read  shared variables and is evaluated in each final state. If it evaluates to <code>False</code>, Harmony reports an error.  Harmony also reports an error if the expression evaluates to a value other than <code>False</code> or <code>True</code>.</p>"},{"location":"textbook/values/#for-in-where","title":"for ... in ... [where ...]","text":"<p>The statement for x in y: <code>S1</code>; <code>S2</code>; ... iterates over y and executes for each element the statements <code>S1</code>, <code>S2</code>, .... y must be a set, list, dictionary, or string. y is evaluated only once at the beginning of the evaluation of this statement. In case of a set, the result is sorted (using Harmony's global order on all values). In case of a dictionary, the statement iterates over the keys in order. This makes iterating over lists intuitive and identical to Python. For each element, the statements <code>S1</code>, <code>S2</code>, ... are executed with local variable y having the value of the element. x can be a pattern such as \\((a)\\) or \\((a, (b, c))\\). If the pattern cannot be matched, Harmony detects and error. It is allowed, but discouraged, to assign different values to x within statements <code>S1</code>, <code>S2</code>, ....</p> <p>Harmony also supports the form for k:v in y: <code>S1</code>; <code>S2</code>; .... This works similar, except that k is bound to the key and v is bound to the value. If y is not a dictionary, then k ranges from 0 to len(y) - 1.</p> <p>The statement also supports nesting and filtering. Nesting is of the form for x1 in y1 for x2 in y2: <code>S1</code>; <code>S2</code>; ..., which is equivalent to the statement for x1 in y1: for x2 in y2: <code>S1</code>; <code>S2</code>; .... Filtering is of the form for x in y where z: <code>S1</code>; <code>S2</code>; .... For example, for x in 1 .. 10 where (x % 2) == 0: <code>S1</code>; <code>S2</code>; ... only evaluates statements <code>S1</code>, <code>S2</code>, ... for even x, that is, 2, 4, 6, 8, and 10.</p> <p>Harmony does not support break or continue statements.</p>"},{"location":"textbook/values/#from-import","title":"from ... import","text":"<p>The statement from x import a, b, ... imports module x and makes its constants a, b, ... also constants in the current module. If a module is imported more than once, its code is only included the first time. The constants will typically be the names of methods (program counter constants) within the module.</p> <p>You can import all constants from a module m (including program counter constants) using the statement from m import *. This, however, excludes constants whose names start with the character <code>_</code>: those are considered private to the module.</p>"},{"location":"textbook/values/#go","title":"go","text":"fork.hny<pre><code>def fork():\n    atomically:\n        let (r, ctx) = save True:\n            result = r\n            if r:\n                go ctx (False, None)\n\ndef main():\n    if fork():\n        print \"parent\"\n    else:\n        print \"child\"\n\nspawn eternal main()\n</code></pre> Figure A.1 (code/fork.hny):  Using `save` and `go` to implement `fork()` <p>The statement go c e starts a thread with context c that has executed a stop or save expression. The stop or save  expression returns value e. The same context can be started multiple times, allowing threads to fork. See Figure A.1 for an example.</p>"},{"location":"textbook/values/#if-elif-else","title":"if ... [elif ...]* [else]","text":"<p>Harmony supports if statements. In its most basic form, if c: <code>S1</code>; <code>S2</code>; ... evaluates c and executes statements <code>S1</code>, <code>S2</code>, ... if and only if boolean expression c evaluated to true. Harmony checks that c is either <code>False</code> or <code>True</code>---if neither is the case, Harmony reports an error. The statement if c: <code>S1</code>, <code>S2</code>, ... else: <code>T1</code>; <code>T2</code>; ... is similar, but executes statements <code>T1</code>, <code>T2</code>, ... if and only if c evaluated to <code>False</code>. You can think of elif \\(c:\\) as shorthand for else: if c:.</p>"},{"location":"textbook/values/#import","title":"import","text":"<p>The statement import m1, m2, ... imports modules m1, m2, ... in that order. If a module is imported more than once, its code is only included the first time. The constants (including method constants) and shared variables declared in that module can subsequently be referenced by prepending \"m.\". For example, method <code>f</code>() in imported module m is invoked by calling m.<code>f</code>(). If you would prefer to invoke it simply as <code>f</code>(), then you have to import using the statement from m import <code>f</code>.</p>"},{"location":"textbook/values/#invariant","title":"invariant","text":"<p>The statement invariant c declares that boolean expression c is an invariant. c is only allowed to read shared variables and is evaluated atomically after every state change. If it ever evaluates to <code>False</code> Harmony reports and error. Harmony also reports an error if the expression evaluates to a value other than <code>False</code> or <code>True</code>.</p> <p>The predicate has access to two immutable variables called <code>pre</code> and <code>post</code>.  <code>post</code> is a name for the current shared state, and thus <code>post.x == x</code> for any shared variable <code>x</code>.  <code>pre</code> is a name for the prior shared state in a state change.  For example, <code>invariant pre.p =&gt; post.p</code> (or equivalently <code>invariant pre.p = p</code>) states that <code>p</code> is a stable predicate: once true, it is always true. <code>invariant pre.x &lt;= x</code> states that variable <code>x</code> grows monotonically.</p> <p>Harmony (like TLA+) requires that such invariants are \"invariant under stuttering\", which means that for any predicate \\(P\\) and any reachable state \\(S\\) the following must hold: (<code>pre</code> = \\(S\\) = <code>post</code>)  \\(\\Rightarrow P\\).  Less formally, \\(P\\) must hold in a state change that does not affect the variables that \\(P\\) accesses.  For example, the following invariant would be problematic: <code>invariant pre.x &lt; x</code>, which states that \\(x\\) grows strictly monotonically no matter what state changes.  This is problematic because it would not hold in a state change that, say, changes \\(y\\) but leaves \\(x\\) untouched.</p> <p>Invariants can be useful to specify the type of a global variable. For example, you can write <code>invariant (type(x) == \"int\") and ((x % 2) == 0)</code> to state that <code>x</code> is an even integer variable.</p>"},{"location":"textbook/values/#let","title":"let","text":"<p>You can introduce new bound variables in a method using the let statement. The statement let a = b: <code>S1</code>; <code>S2</code>, ... evaluates b, assigns the result to read-only variable a, and evaluates statements <code>S1</code>, <code>S2</code>, .... let supports pattern matching, so you can write let x, (y, z) = b: <code>S1</code>; <code>S2</code>, .... This will only work if b is a tuple with two elements, the second of which also being a tuple with two elements---if not, Harmony will report an error.</p> <p>let statements may be nested, such as let a1 = b1 let a2 = b2: <code>S1</code>; <code>S2</code>; .... Doing so can improve readability by reducing indentation compared to writing them as separate statements. Compare the following two examples:</p> <pre><code>let a = y:\n\u00a0\u00a0\u00a0\u00a0let b = z:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\n</code></pre> <pre><code>let a = y\nlet b = z:\n</code></pre>"},{"location":"textbook/values/#pass","title":"pass","text":"<p>The pass statement does nothing.</p>"},{"location":"textbook/values/#print","title":"print","text":"<p>The statement print e evaluates e and adds the result to the print log. The print log is used to create an \"external behavior DFA\" for the Harmony program.</p>"},{"location":"textbook/values/#sequential","title":"sequential","text":"<p>In Harmony, shared variable <code>Load</code> and <code>Store</code> operations are atomic and have sequential consistency. However, Harmony does check for data races. A data race occurs when two or more threads simultaneously access the same shared variable, with at least one of the accesses being a <code>Store</code> operation outside of an atomic block. If so, Harmony will report an error. This error can be suppressed by declaring the shared variable as sequential. In particular, the statement sequential x, y, ... specifies that the algorithm assumes that the given variables have sequential consistency.</p> <p>Note that few modern processors support sequentially consistent memory by default, as doing so would lead to high overhead.</p>"},{"location":"textbook/values/#spawn","title":"spawn","text":"<p>The statement spawn m a starts a new thread that executes method m with argument a. m must be a program counter constant, and a is typically a tuple containing zero or more parameters to be passed to the method.</p> <p>The default thread-local state of the thread, called self, is the empty dictionary by default. It can be specified by adding a parameter: spawn m a, e specifies that e should be the initial value of the thread-local state.</p> <p>Harmony normally checks that all threads eventually terminate. If a thread may never terminate, you should spawn it with spawn eternal m a to suppress those checks.</p>"},{"location":"textbook/values/#trap","title":"trap","text":"<p>The statement trap m a specifies that the current thread should execute method m with argument a and some future, unspecified, time. It models a timer interrupt or any kind of asynchronous event to be handled by the thread. Such interrupts can be disabled by setting the interrupt level of the thread to <code>True</code> using the setintlevel operator.</p>"},{"location":"textbook/values/#var","title":"var","text":"<p>You can introduce new local variables in a method using the var statement. The statement var a = b evaluates b and assigns the result to local variable a. var supports pattern matching, so you can write var x, (y, z) = b. This will only work if b is a tuple with two elements, the second of which also being a tuple with two elements---if not, Harmony will report an error.</p>"},{"location":"textbook/values/#when","title":"when","text":"<p>The statement when c: <code>S1</code>; <code>S2</code>; ... executes statements <code>S1</code>, <code>S2</code>, ... after waiting until c evaluates to <code>True</code>. when statements are most useful when combined with the atomically keyword. If waiting is an unused local variable, then atomically when c: <code>S1</code>; <code>S2</code>; ... is equivalent to</p> <pre><code>var waiting = True\nwhile waiting:\n\u00a0\u00a0\u00a0\u00a0atomically:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if c:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0waiting = False\n</code></pre> <p>Multiple let and when statements can be combined. The expressions before the colon are re-evaluated repeated until all when conditions are satisfied.</p>"},{"location":"textbook/values/#when-exists-in","title":"when exists ... in ...","text":"<p>The statement when exists x in y: <code>S1</code>; <code>S2</code>; ... requires that y evaluates to a set value. The statement does the following three things:</p> <ul> <li> <p>it waits until y is non-empty;</p> </li> <li> <p>it selects one element of y non-deterministically (using a     choose expression);</p> </li> <li> <p>it executes statements <code>S1</code>, <code>S2</code>, ... with the selected element     bound to read-only variable x.</p> </li> </ul> <p>x may be a pattern, like in let, for, and def statements. Harmony reports an error if y evaluates to a value that is not a set.</p> <p>when statements are most useful when combined with the atomically keyword. If waiting is an unused local variable, then atomically when exists x in y: <code>S1</code>; <code>S2</code>; ... is equivalent to</p> <pre><code>var waiting = True:\n\u00a0\u00a0\u00a0\u00a0while waiting:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0atomically:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if y != {}:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0let x = choose(y):\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0waiting = False\n</code></pre> <p>The statement is particularly useful in programming network protocols when having to wait for one or more messages and executing a set of actions atomically after the desired messages have arrived.</p>"},{"location":"textbook/values/#while","title":"while","text":"<p>The statement while c: <code>S1</code>; <code>S2</code>; ... executes statements <code>S1</code>, <code>S2</code>, ... repeatedly as long as c evaluates to <code>True</code>. Harmony does not support break or continue statements.</p>"},{"location":"textbook/values/#harmony-is-not-object-oriented","title":"Harmony is not object-oriented","text":"<p>Python is object-oriented, but Harmony is not. For Python programmers, this can lead to some unexpected differences. For example, consider the following code:</p> <pre><code>x = y = [ 1, 2 ]\nx[0] = 3\nassert y[0] == 1\n</code></pre> <p>In Python, lists are objects. Thus x and y point to the same list, and the assertion would fail if executed by Python. In Harmony, lists are values. So, when x is updated in Line\u00a02, it does not affect the value of y. The assertion succeeds. Harmony supports references to values (Chapter 7), allowing programs to implement shared objects.</p> <p>Because Harmony does not have objects, it also does not have object methods. However, Harmony methods and lambdas are program counter constants. These constants can be added to dictionaries. For example, in Figure 7.1 you can add the <code>P_enter</code> and <code>P_exit</code> methods to the <code>P_mutex</code> dictionary like so:</p> <pre><code>{ .turn: 0, .flags: [ False, False ], .enter: P_enter, .exit: P_exit }\n</code></pre> <p>That would allow you to simulate object methods.</p> <p>There are at least two reasons why Harmony is not object-oriented. First, object-orientation often adds layers of indirection that would make it harder to model check and also to interpret the results. Consider, for example, a lock. In Python, a lock is an object. A lock variable would contain a reference to a lock object. In Harmony, a lock variable contains the value of the lock itself. Thus, the following statement means something quite different in Python and Harmony:</p> <pre><code>x = y = Lock()\n</code></pre> <p>In Python, this creates two variables x and y referring to the same lock. In Harmony, the two variables will be two different locks. If you want two variables referring to the same lock in Harmony, you might write:</p> <pre><code>lock = Lock()\nx = y = ?lock\n</code></pre> <p>or, using the <code>alloc</code> module,</p> <pre><code>from alloc import malloc\nx = y = malloc(Lock())\n</code></pre> <p>The second reason for Harmony not being object-oriented is that many concurrency solutions in the literature are expressed in C or some other low-level language that does not support object-orientation, but instead use <code>malloc</code> and <code>free</code>.</p>"},{"location":"textbook/values/#constants-global-and-local-variables","title":"Constants, Global and Local Variables","text":"<p>Each (non-reserved) identifier in a Harmony program refers to either a global constant, a global shared variable, a local bound variable, a local mutable variable, or a module. Constants are declared using const statements. Those constants are evaluated at compile-time.</p> <p>Mutable method variables can be declared using the <code>returns</code> clause of a <code>def</code> statement or using <code>var</code>. Bound variables, which are immutable, can be declared in def statements (i.e., arguments), let statements, for loops, and <code>when exists</code> statements. Mutable variables can be declared with the var statement. Also, each method has an implicitly declared result variable, which is initialized to <code>None</code>. Each thread has a mutable variable called this that contains the thread-local state. Method variables are tightly scoped and cannot be shared between threads. While in theory one method can be declared within another, they cannot share local variables either. All other variables are global and must be initialized before spawned threads are start executing.</p>"},{"location":"textbook/values/#operator-precedence","title":"Operator Precedence","text":"<p>In Harmony, there is no syntactic difference between applying an argument to a function or an index to a dictionary. Both use the syntax a b c .... We call this application, and application is left-associative. So, a b c is interpreted as (a b) c: b is applied to a, and then c is applied to the result. For readability, it may help to write \\(a(b)\\) for function application and \\(a[b]\\) for indexing. In case b is a simple string, you can also write \\(a.b\\) for indexing.</p> <p>There are three levels of precedence. Application has the highest precedence. So, !a b is interpreted as !(a b) and a b + c d is interpreted as (a b) + (c d). Unary operators have the next highest precedence, and the remaining operators have the lowest precedence. For example, \\(-2 + 3\\) evaluates to 1, not \\(-5\\).</p> <p>Associative operators (\\(+\\), \\(*\\), \\(|\\), \\(\\string&amp;\\), \\(\\string^\\), and, or) are interpreted as general \\(n\\)-ary operators, and you are allowed to write \\(a + b + c\\). However, ambiguous expressions such as  \\(a - b - c\\) are illegal, as is any combination of operators with an arity larger than one, such as \\(a + b &lt; c\\). In such cases you have to add parentheses or brackets to indicate what the intended evaluation order is, such as \\((a + b) &lt; c\\).</p> <p>In almost all expressions, subexpressions are evaluated left to right. So, a[b] + c first evaluates a, then b (and then applies b to a), and then c. The one exception is the expression a if c else b, where c is evaluated first. In that expression, only a or b is evaluated depending on the value of c. In the expression a and b and \\(...\\), evaluation is left to right but stops once one of the subexpressions evaluates to <code>False</code>. Similarly for or, where evaluation stops once one of the subexpressions evaluates to <code>True</code>. A sequence of comparison operations, such as \\(a &lt; b &lt; c\\), is evaluated left to right but stops as soon as one of the comparisons fails.</p> <p>As an aside: the expression a not in b is equivalent to not (a in b). Harmony generalizes this construct for any pair of a unary (except '\\(-\\)') and a binary operator. In particular, a not and b is the same as not (a and b). For those familiar with logic gates, not and is the equivalent of <code>NAND</code>. Similarly, not =\\(&gt;\\) is non-implication.</p>"},{"location":"textbook/values/#tuples-lists-and-pattern-matching","title":"Tuples, Lists, and Pattern Matching","text":"<p>Harmony tuples and lists are equivalent. They can be bracketed either by '(' and ')' or by '[' and ']', but the brackets are often optional. Importantly, with a singleton list, the one element must be followed by a comma. For example, the statement <code>x = 1,;</code> assigns a singleton tuple (or list) to x.</p> <p>Harmony does not support special slicing syntax like Python. To modify lists, use the <code>subseq</code> method in the <code>list</code> module.</p> <p>Harmony allows pattern matching against nested tuples in various language constructs. The following are the same in Python and Harmony:</p> <ul> <li> <p>x, = 1,: assigns 1 to x;</p> </li> <li> <p>x, y = 1, (2, 3): assigns 1 to x and (2, 3) to y;</p> </li> <li> <p>x, (y, z) = 1, (2, 3): assigns 1 to x, 2 to y, and 3 to     \\(z\\);</p> </li> <li> <p>x, (y, z) = 1, 2: generates an runtime error because 2 cannot     be matched with (y, z);</p> </li> <li> <p>x[0], x[1] = x[1], x[0]: swaps the first two     elements of list x.</p> </li> </ul> <p>As in Python, pattern matching can also be used in for statements. For example:</p> <p>for key, value in [ (1, 2), (3, 4) ]: ...</p> <p>Harmony (but not Python) also allows pattern matching in defining and invoking methods. For example, you can write:</p> <p>def <code>f</code>[a, (b, c)]: ...</p> <p>and then call <code>f</code>[1, (2, 3)]. Note that the more familiar: def <code>g</code>(a) defines a method <code>g</code> with a single argument a. Invoking <code>g</code>(1, 2) would assign the tuple (1, 2) to a. This is not consistent with Python syntax. For single argument methods, you may want to declare as follows: def g(\\(a,\\)). Calling g(1,) assigns 1 to a, while calling g(1, 2) would result in a runtime error as (1, 2) cannot be matched with (a,).</p> <p>Pattern matching can also be used in const, let, and when exists statements.</p> <p>### For Loops and Comprehensions   While Harmony does not support general iterators such as Python does,   Harmony allows iterating over sets, lists, and dictionaries.   When iterating over a set, the set is always traversed in order   (see Language Details for how Harmony values are ordered).   When iterating over a dictionary, it is always traversed in the order   of the keys.</p> <p>Harmony supports nesting and filtering in for loops.</p> <p>For example:</p> <p><pre><code>for i in { 1..10 } for j in { 1..10 } where i &lt; j: ...\n</code></pre> In case of dictionaries, you can access both keys and values (not supported in Python): <pre><code>for k:v in .a: 1, .b: 2: ...\n</code></pre> Harmony also supports set, list, and dictionary comprehensions. Comprehensions are similar to Python, except that filtering uses the keyword <code>where</code> instead of <code>if</code>.</p>"},{"location":"textbook/values/#dynamic-allocation","title":"Dynamic Allocation","text":"<p>Harmony supports various options for dynamic allocation. By way of example, consider a stack. Figure A.2 presents a test program for a stack. We present four different stack implementations to illustrate options for dynamic allocation:</p> <ol> <li> <p>Figure A.3 uses a single list to represent the stack. It is     updated to perform <code>push</code> and <code>pop</code> operations;</p> </li> <li> <p>Figure A.4 also uses a list but, instead of updating the list,     it replaces the list with a new one for each operation;</p> </li> <li> <p>Figure A.5 represents a stack as a recursively nested tuple     \\((v, f)\\), where v is the element on top of the stack and r is a     stack that is the remainder;</p> </li> <li> <p>Figure A.6 implements a stack as a linked list with nodes     allocated using the <code>alloc</code> module.</p> </li> </ol> <p>While the last option is the most versatile (it allows cyclic data structures), Harmony does not support garbage collection for memory allocated this way and so allocated memory that is no longer in use must be explicitly released using <code>free</code>.</p> stacktest.hny<pre><code>from stack import Stack, push, pop\n\nteststack = Stack()\npush(?teststack, 1)\npush(?teststack, 2)\nv = pop(?teststack)\nassert v == 2\npush(?teststack, 3)\nv = pop(?teststack)\nassert v == 3\nv = pop(?teststack)\nassert v == 1\n</code></pre> Figure A.2 (code/stacktest.hny):  Testing a stack implementation.  stack1.hny<pre><code>def Stack() returns stack:\n    stack = []\n\ndef push(st, v):\n    (!st)[len(!st)] = v\n\ndef pop(st) returns next:\n    let n = len(!st) - 1:\n        next = (!st)[n]\n        del (!st)[n]\n</code></pre> Figure A.3 (code/stack1.hny):  Stack implemented using a dynamically updated list.  stack2.hny<pre><code>import list\n\ndef Stack() returns stack:\n    stack = []\n\ndef push(st, v):\n    !st += [v,]\n\ndef pop(st) returns next:\n    let n = len(!st) - 1:\n        next = (!st)[n]\n        !st = list.subseq(!st, 0, n)\n</code></pre> Figure A.4 (code/stack2.hny):  Stack implemented using static lists.  stack3.hny<pre><code>def Stack() returns stack:\n    stack = ()\n\ndef push(st, v):\n    (!st) = (v, !st)\n\ndef pop(st) returns next:\n    let (top, rest) = !st:\n        next = top\n        !st = rest\n</code></pre> Figure A.5 (code/stack3.hny):  Stack implemented using a recursive tuple data structure.  stack4.hny<pre><code>from alloc import malloc, free\n\ndef Stack() returns stack:\n    stack = None\n\ndef push(st, v):\n    !st = malloc({ .value: v, .rest: !st })\n\ndef pop(st) returns next:\n    let node = !st:\n        next = node-&gt;value\n        !st = node-&gt;rest\n        free(node)\n</code></pre> Figure A.6 (code/stack4.hny):  Stack implemented using a linked list."},{"location":"textbook/values/#comments","title":"Comments","text":"<p>Harmony supports the same commenting conventions as Python. In particular, anything after a <code>#</code> character on a line is ignored. You can also enclose comments on separate lines within triple quotes. In addition, Harmony supports nested multi-line comments of the form <code>(* comment *)</code>.</p>"},{"location":"textbook/values/#type-checking","title":"Type Checking","text":"<p>Harmony is dynamically typed. You can add type annotations to your program in the form of assertions and invariants. For example:</p> <pre><code>invariant (type(x) == \"int\") and ((x % 2) == 0)\nx = choose { 0, 2, 4, 6 }\n\ndef double(n) returns result:\n    assert type(n) == \"int\"\n    result = n * 2\n    assert type(result) == \"int\"\n\ndef main():\n    x = double(x)\n\nspawn main()\n</code></pre> <p>The invariant in Line~1 states that <code>x</code> is an even integer. The assertion in Line~5 states that the argument to function <code>double</code> is an integer. The assertion in Line~7 states that the return value of the function is also an integer. Harmony checks these types as it evaluates the program.</p>"}]}